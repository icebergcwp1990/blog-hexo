[{"title":"Daily-读书意味着什么？","url":"http://icebergcwp.com/Daily-2018-08-14.html","content":"<p>读书意味着什么？这是我一直在思索的问题，也一直在寻找满意的答案。我觉得让我从厌恶读书变得有点喜欢读书的过程中，有两个关于读书意义的比喻对我影响很深。</p>\n<p>比喻一来源于一个故事：祖孙二人居住在山区庄园里，爷爷每天清晨都坚持读书，孙子受爷爷的影响，也尽自己最大的能力阅读书籍。有一天，他问爷爷：“我也每天读书，可我不能真正地理解它，那读书有什么用呢？”爷爷拿来一个装煤的竹篮，让孙子去打水，一趟，两趟，三趟……孙子以最快的速度跑回家，可竹篮总是空空如也。“竹篮是不能打到水的！”孙子说，可爷爷让他仔细看看篮子：原来黑乎乎、脏兮兮的竹篮变得洁净如新了。“孩子，阅读好书也是如此。”爷爷语重心长地说：“你可能无法完全理解它，也记不住多少内容，但只要你用心阅读它，它就会在不知不觉中净化了你的心灵。”是的，竹篮是打不来水的，但并不是一无收获，什么都没有留下来，一次次的打水，让竹篮一次次浸到水里，使竹篮一次比一次变干净了。读书其实也和竹篮打水一样，留不住其形，却留得住其神，知识不可能让我们吃饱穿暖，但它可以让我们的心灵变得宁静明洁，不会浮燥，天长日久可让人的灵魂得到净化。</p>\n<p>比喻二是北大教授陈原平教授的一段话：如果你半夜醒来发现自己已经好长时间没有读书，而且没有任何负罪感的时候，你就必须知道，你已经堕落了。不是说书本本身特了不起，而是读书这个行为意味着你没有完全认同这个现世和现实，你还有追求，还在奋斗，你还有不满，你还在寻找另外一种可能性，另一种生活方式。</p>\n<p>我一直坚信读书多的人能在这世上活得更明白，看得更全面，减少因信息不对称带来的无知与愚昧。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-用辩证的眼光看待消费主义","url":"http://icebergcwp.com/Daily-2018-08-13.html","content":"<p>当下消费主义被大肆宣传，许多尚无经济能力的年轻人深陷其中，于是出现了很多大学生裸贷或者高利贷的现象，甚至因为最终无力偿还贷款而选择结束自己年轻的生命。即便如此，我们也不宜多于妖魔化消费主义，我们只是恰巧处于消费主义的时代而已。分析它、正视它、趋利避害才是正确的做法。</p>\n<p>用辩证的方式看问题，任何矛盾都存在主要方面和次要方面。对于消费主义也同样如此。作为拉动经济的三驾马车之一，消费是经济运行的重要环节，有利于促进经济增长，且也是资本主义克服自身生产过剩原罪必不可少的因素；与此同时，消费主义在当今时代有过度泛滥的趋势，无数人成为了消费主义的奴隶，被盲目的、过度的、非理性的购物欲所驱使，被铺天盖地的广告和宣传所洗脑，已经严重影响到了正常生活和个人未来发展。这就是消费主义一体两面的存在。</p>\n<p>伟大的辩证法还告诉我们，矛盾的主要方面和次要方面在一定条件下会相互转换。所以消费主义究竟是积极的影响成为主要方面还是消极的影响成为主要方面，要具体问题具体分析。</p>\n<p>就比如苹果手机，首先它是伟大的科技革命的产物，是人类生产力发展进步的体现之一，把它说成是消费主义的产物实在是对不起乔布斯这样的天才。但同时，苹果手机有没有消费主义元素在其中，那当然还是有的，符号价值的溢价也组成了苹果产品的重要部分。就这个事例来看，如果我买了苹果手机，是追逐与一个当下人类工业化高度的结晶，是为了提升使用体验和工作效率，这时商品的使用价值占据了矛盾的主要方面；而我买一个苹果手机，是为了炫耀，为了有面子，是为了增益自己的身份，或者远超出了我的经济承受能力，我甚至去卖肾买手机，这就变成了消费主义的奴隶。</p>\n<p>认清事物的本质方能让其为己所用，否则只能一直处于被动的状态，随波逐流，最终感叹命运不公和生活不济。要么在网路上抱怨发泄内心的积怨，要么通过综艺娱乐节目虚度光阴，然后继续通过消费麻痹自己，通过购物找回自我本体的意志。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于诚信","url":"http://icebergcwp.com/Daily-2018-08-12.html","content":"<p>客观地自我评价，我以前不是一个讲诚信的人，或者说是一个轻易说谎的人。究其原因是从小到大没有接受太多这方面的教育，更不明白诚信之于人的重要性。</p>\n<p>第一次对诚信的重要性有比较深的感触是在大学毕业后的那一年，有一段时间很痴迷于曾国藩的传记。原因在于他也是从一个满身毛病的农村小孩成长为权倾朝野的大臣，并且被誉为中国历史上最后一个完人。如果说要对曾国藩的一生用几个词来总结的话，我个人觉得是自省和恒心。曾国藩一直都有写日记的习惯，几乎从来没有间断过，即便是在生命的最后几天仍然坚持着。他的日记内容多半是对自我的反省，这也让他不断地完善自我，完成从一个凡人到圣人的蜕变。在了解和学习曾国藩的成长历程的同时，我也在试着不断地反省自己。</p>\n<p>记得有一次看到曾国藩关于诚信的一些故事。他的价值观之一就是人无信而不立。他一般不会轻易的许下承诺，但是一旦答应的事情就一定会办到，不管阻力有多大。当时看完之后感触很深，也想起了自己以前做的那些失信于人的事情，经常信口开河，轻易许下诺言然后放别人鸽子。想到这里顿时心感惭愧，拿起手机跟那位朋友发了一条道歉短信…</p>\n<p>从那以后虽然也经常有失信于人的事情发生，但是每次都会自我反省，找出其中的原因。现在总结起来，其中一些是因为自己怕伤及感情而不懂得拒绝，殊不知言而无信才是最伤感情的；另外就是对于诚信为立人之本这层道理的认识不够深刻，那时候不知道每失信一次，自己内心就会被腐蚀一次，结果就是说谎的成本变得越来越低廉，个人的信誉也越来越低廉。</p>\n<p>现在我能感觉到自己越来越注重诚信的价值，一旦说过得话就会尽力去完成。尽管有时候会心生犹豫，但最终还是会因为无法说服或欺骗自己的内心而选择履行承诺。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-经济学概念-租","url":"http://icebergcwp.com/Daily-2018-08-11.html","content":"<p>最近在《姚兆丰经济学讲义》看到一个“租”的概念。从经济学的角度进行了重新定义，看完之后云里雾里、似懂非懂，于是做点笔记以加深理解。</p>\n<p>有一种资产，不以收费的变化而变化，这种资产带来的收入就是租。租就是相对资产的付费，这里说的资产是广义上的，包括土地、矿产、才能以及特权，只要能够带来收入的就是资产，而对资产付费就是租。</p>\n<p>每个人都享受一定程度的租。比如我们在平时上班时抽出半个小时刷朋友圈，老板并不会因此开除你或少付工资，这样你就赚了半小时的租。而且这一部分的租是属于旱涝保收的。然而现实生活中，随着时间和竞争条件的变化，真正让你旱涝保收的租是绝对不存在而是相对的存在的。</p>\n<p>基于成本是放弃的最大代价这一前提，如果你对目前的工作感到满意，觉得下一份工作的收入会比现在低很多，那你就是在享受当前工作带来的租；相反，如果你觉得你另外一份工作收入会高很多，那你选择留在当前岗位的成本就非常高。此外，即使你不换工作留在当前的岗位上，如果你每天不管努力工作还是得过且过，结果收入都一样，那你选择懒散度日的态度，就是在享受租；但如果努力或懈怠带来的收入会有明显差异，那么你选择懈怠就要付出很大的成本。</p>\n<p>不妨记住一句话：人人都是资本家，因为当你认识到自己是资本家之后，会把注意力放到提升自己的租值上，而不是所谓的被剥削。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于时间的感知能力","url":"http://icebergcwp.com/Daily-2018-08-10.html","content":"<p>第一次对时间的形象化感知应该是来自于朱自清的散文《匆匆》：“早上我起来的时候，小屋里射进两三方斜斜的太阳。太阳他有脚啊，轻轻悄悄地挪移了；我也茫茫然跟着旋转。于是——洗手的时候，日子从水盆里过去；吃饭的时候，日子从饭碗里过去；默默时，便从凝然的双眼前过去”。记得初中那会背诵这段文字的时候，脑海里浮现出时光如流水般溜走的景象。</p>\n<p>随着年龄和知识的增长，我感觉到自己对于时间的感知能力在逐渐减弱。后来才知道这是有科学依据的。在我们七八岁的时候，一年所经历的会占到我们大脑中记忆的1/5（考虑到两岁之前并不会形成完整的记忆）；大概当我们二十多岁的时候，一年的记忆只占到了总记忆的1/20左右，差不多一年过去这种感觉就像小时候过了个暑假；等到了六七十岁，一年所经历的只占到大脑中1/60，相比于二十多岁时，同样的一天给你的感觉却是快了三倍，那时候日子才跟飞一样的。</p>\n<p>如果每天做的事情比较规律且有一定的重复性，久而久之大脑会对这些事情形成“肌肉记忆”，因而有了对应的生物钟或者说条件反射。这容易让人误以为自己对于时间的感知和把控性比较好，正如我一直以来的自我感觉良好，其实不然，昨晚的一件小事让我对自己关于时间的感知能力有了新的认识。</p>\n<p>昨晚有一个要好的朋友从深圳来长沙，在结束家-公司-健身房三点一线的生活之后他刚好抵达长沙。他从地铁站过来至少需要一个小时，然而我当时对于这一个小时能做什么事情完全没有概念，觉得坐一会就过去了，于是选择先去饭店等他。事实是在等待的过程中我感觉到其实这一个小时我可以一些事情。比如回家用五分钟就能把衣服晾好，用半个小时就可以写完日记，最后提前二十分钟到家附近饭店即可，而不是坐在这里发呆。最后朋友因为堵车的原因，一个半小时之后才碰上面…</p>\n<p>事后自我反省，试着找出当时为什么没有做出最为合理的选择？结论之一就是我对于时间的感知能力不够强，严重低估了一个小时能够做的事情。此外，当时见友心切的心情也有一定影响，干扰了我的正常思考。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-焦虑","url":"http://icebergcwp.com/Daily-2018-08-09.html","content":"<p>最近睡眠质量很差，整个人的精神萎靡不振。最可怕的莫过于因为睡觉引发的后遗症：焦虑。</p>\n<p>过于我一直坚信人是有能力控制住自己的情绪，但是最近这两天的经历让我觉得这句话应该加一个前提：有充足的睡眠和正常的精神状态。一旦生理层面失去了控制，即便意志力再强都会有种无助感，很容易会因为一些琐事而产生一些平时少见的不恰当的言谈举止。</p>\n<p>我不认为自己的控制力还算是比较强，但是今天却很真实地感觉自己内心的浮躁和焦虑。上午坐在电脑面前发呆，盯着屏幕却处于游离状态。下午因为午睡质量好的原因，明显地感到整个人有了的精力，因此保持了一个下午高效率工作状态。</p>\n<p>之前总以为快乐和焦虑这些情绪都是由人的主观决定的，现在我对这个观点表示怀疑。不可否认人的主观意志能够影响到个人情绪，但是是否有决定性作用还有待商榷。我的理解是如果生理因为其他原因而出现异常，比如某些控制情绪的激素分泌低于了正常值等，那么主观意志力能发挥影响的余地也会随之减小。</p>\n<p>正如经济基础决定上层建筑一样，只有生理层面正常运转，主观层面才有发挥作用的机会。</p>\n<p>所以想要更好的控制自己的情绪，那就睡个好觉吧！</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-缺觉的一天","url":"http://icebergcwp.com/Daily-2018-08-08.html","content":"<p>昨晚健身回来已是十点多，等吃完晚餐差不多是十一点半。恰好是练胸日，晚餐的分量比较大，加上错过了最佳的用餐时间，肠胃的消化能力不足，导致到了十二点有点消化不良。以后凡是健身太迟便直接在沙县小吃来一份鸭腿饭，出于时间和健康考虑都是最佳选择。</p>\n<p>肚子太撑有时候没办法静下来思考或者看书，于是想起给尤克里里换一副新琴弦。之前原装的琴弦被我捣鼓坏了，已没办法调准音。更何况原装的琴弦过于坚硬，左手也因此吃尽苦头，手指头的茧换了一层又一层。我总结了一下，导致左手按弦困难的原因除了琴弦本身之外，另外一个主要原因是琴弦距离品丝的过高。而决定琴弦与品丝距离又包括三个因素，分别是上弦枕高度、下弦枕高度和琴头捆弦的位置。由于上弦枕是固定的，因此只能改良后面两个因素的影响。打磨下弦枕是一个技术活，除了确保打磨后的弦枕平面光滑之外，还要把握好打磨的高度，一般都是以毫米作为单位。如果打磨的过多，就有可能出现打品的情况，也意味着必须更换新的下弦枕。第三个因素是我在更换琴弦的过程中发现的，似乎很少被提及，也可能是影响很小被忽略不计。细节很简单，即在固定琴头位置的弦时尽量把琴弦往下绕圈，这样在调音收紧琴弦时可以让琴弦尽可能的靠近面板，从而减小了品丝距离琴弦的距离，进而更容易按住和弦。虽说换琴弦没有什么技术含量且细节较多耗时间。但是秉着多尝试的心态兴致勃勃地折腾到凌晨两点。</p>\n<p>本以为换好琴弦后应该能够睡个好觉，却还是因为肠胃不舒服辗转难眠，一直到凌晨四点才在疲惫中睡着。缺觉最可怕的不是黑眼圈，而是影响自控力和情绪。事实也确实如此。一个要好的兄弟与自己的女友重归于好，我本应该感到高兴，但是心里却莫名其妙的感觉到一丝恼火。我其实是不建议他们在一起，两人性格根本不适合。更何况就在前一天晚上因为他俩分手的事情彻夜长谈到凌晨四点，把他们的感情里里外外分析了一遍并达成一致的结论：他分手是正确且明智的。结果过了一天被告知他们复合了，当时心里有种智商和情商同时被侮辱的感觉，以及自己的感情受到了欺骗。不过事后想想我何必这么敏感？嗯，那暂且把产生这种情绪的原因归结于失眠吧。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-珍惜与把握现在的生活","url":"http://icebergcwp.com/Daily-2018-08-07.html","content":"<blockquote>\n<p>“你在池塘里活得很好，泥鳅很丑但会说喜庆的话，癞蛤蟆马虎但是很有趣，田螺是个温柔的自闭症，小鲫鱼是你们共同的女神。有一天你听说，江河湖海，哪个都要更大更好。你跳了出去，遇见了美丽的海豚🐬，雄壮的白鲸🐳，婀娜多姿的热带鱼🐟，的确都是好的。就是偶尔，觉得世界很空，生活很咸。—姬霄”</p>\n</blockquote>\n<p>人往高处走，这是人之常情。人类永不满足的欲望是社会进步、文化发展和经济增长的源动力，只是有时候记得停下匆忙前行的脚步，感受一下已经拥有的生活。</p>\n<p>人总是想要自己缺少的东西。因此我和很多人一样，把行业顶级人物所取得成就当做自己奋斗的方向，不断地推着自己向前。甚至有时候会感叹自己的出身背景不够好，起点不够高，羡慕精英阶层享受的教育和家庭支持，以及很认同阶级出身是他们的成功的最重要的因素这一说法。现在想想有点为自己这种嫉妒心理感到可笑。</p>\n<p>如果不是今天在网路上看到一篇报道，也许这种丑陋的嫉富心理会一直在我内心滋长。这篇报道讲述了中国三个不同阶层的小孩的十年成长史。第一个是底层贫农家庭的女孩，因为家里过于贫穷，在读完小学之后不得不辍学，最后在其他同龄人读高中的年纪嫁给了自己的表哥，人生也已成定局。她内心其实是渴望读书，但是客观原因让她没有一丝选择的权利。第二个男生来自一个普通的中国家庭，历经三次高考最终考上一所二本高校，毕业后在留在省会城市，并通过自己的努力成家立业，过上了中产阶级的生活。他代表着中国大多数家庭的孩子，通过高考这条唯一的途径改变了自己的命运。第三个是一个北京富裕家庭的女孩，为了满足自己的个性追求，放弃了别人梦寐以求的教育资源。在父母的资助下，一次又一次的得到自己想要的机会，过着自己想要的生活。三个人截然不同的命运，其背后的原因就是各自家庭的贫富差距太大。不同于统计数据，这种视觉上带来的感受更加深刻，也让我更明白自己能有现在的生活已属不易。客观地说，我的家庭背景比前面两个孩子都要好一点，虽然经济上也算不上富裕，但是从小衣食无忧，能够受到比较好的教育，并且有一个和睦的家庭环境。现在的我也算是通过高考改变了自己的阶级，走出了生我养我的大山，在大城市里面有了一席之地，并且过着还算舒适的生活。</p>\n<p>我似乎更加明白“这是一个最好的时代，也是最坏的时代”这句话的含义，珍惜与把握现有的生活，怀着一颗感恩的心对待身边的人，珍惜来自不易的学习机会，把握当下提升自己，让自己变得更好。</p>\n","categories":["日记"],"tags":[]},{"title":"OSX开发之Safari App Extension初探","url":"http://icebergcwp.com/OSX开发之Safari App Extension初探#草稿#.html","content":"<h4 id=\"Safari-App-Extension简介\"><a href=\"#Safari-App-Extension简介\" class=\"headerlink\" title=\"Safari App Extension简介\"></a>Safari App Extension简介</h4><h5 id=\"什么是Safari-App-Extension\"><a href=\"#什么是Safari-App-Extension\" class=\"headerlink\" title=\"什么是Safari App Extension\"></a>什么是Safari App Extension</h5><p>Safari App Extension，即Safari浏览器应用拓展。它是苹果新推出的一种Safari扩展开发技术，最低支持Safari10.0，主要由三个部分组成分别是：</p>\n<ul>\n<li><p>Safari App Axtension: 扩展app本身，使用JS、CSS等前端脚本语言。主要功能是包括两方面：</p>\n<ol>\n<li>在插件运行之前注入js和css代码到当前的Safari浏览器页面，进而实现对页面的增删改查等功能</li>\n<li>调用Safari提供的JS API接口与Containing app进行交互通信。</li>\n</ol>\n</li>\n<li><p>Containing App: 扩展app的容器，属于Native App。主要功能包括四方面：</p>\n<ol>\n<li>配置和加载扩展app</li>\n<li>与扩展app进行通信</li>\n<li>提供可在Safari工具栏显示的原生界面</li>\n<li>与Host App进行交互通信和共享数据</li>\n</ol>\n</li>\n<li><p>Host App: 主程序，也属于Native App。主要功能包括三方面：</p>\n<ol>\n<li>加载Containing App</li>\n<li>与Containing app通信交互</li>\n<li>发布Safari App Extension到Apple App Store</li>\n</ol>\n</li>\n</ul>\n<p>结合上述的分析，Safari App Extension可使用两种组合的形式发布产品。一种是三个部分的App同时存在；另外一种是Host App只是作为发布工具，仅在第一次打开并完成扩展app安装之后就不再需要，因为安装好的扩展可在Safari-&gt;偏好设置-&gt;扩展中找到。</p>\n<ol>\n<li>与 Safari Extension 的异同 <a href=\"https://developer.apple.com/documentation/safariservices/safari_app_extensions/converting_a_legacy_safari_extension_to_a_safari_app_extension?language=objc\" target=\"_blank\" rel=\"noopener\">参考资料</a></li>\n</ol>\n<h4 id=\"创建一个Safari-App-Extension\"><a href=\"#创建一个Safari-App-Extension\" class=\"headerlink\" title=\"创建一个Safari App Extension\"></a>创建一个Safari App Extension</h4><ol>\n<li>创建</li>\n<li>App配置</li>\n<li>运行 （Safari配置以及在Xcode中运行host app并不会加载Safari App Extension，但是如果双击启动host app则会加载）</li>\n<li>调试 <a href=\"https://medium.com/@euginedubinin/ios-debugging-application-extension-without-a-host-app-89abf35a36af\" target=\"_blank\" rel=\"noopener\">参考资料</a></li>\n</ol>\n<h4 id=\"核心代码讲解\"><a href=\"#核心代码讲解\" class=\"headerlink\" title=\"核心代码讲解\"></a>核心代码讲解</h4><ol>\n<li>Extension 与 containing app 以及 containing app 与 host app 之间的通信实现 <a href=\"https://developer.apple.com/documentation/safariservices/safari_app_extensions/passing_messages_between_safari_app_extensions_and_injected_scripts?language=objc\" target=\"_blank\" rel=\"noopener\">参考资料</a></li>\n<li>SFSafariApplication等几个核心类介绍</li>\n</ol>\n<p><a href=\"https://github.com/icebergcwp1990/SafariAppExtensionDemo\" target=\"_blank\" rel=\"noopener\">GitHub Demo</a></p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/214/\" target=\"_blank\" rel=\"noopener\">Extending your App with Safari App Extensions WWDC 2016</a></p>\n","categories":["专业","OSX"],"tags":["OSX"]},{"title":"Daily-关于提高效率","url":"http://icebergcwp.com/Daily-2018-08-06.html","content":"<p>最近学习上要做的事情一下子堆积了很多，随之而来的些许的焦虑。专业学习方面已经积压了好几篇博客等待完成，而且每一篇都是耗时几个小时的工作量。此外，本来就少的可怜的英语学习时间因为最近早上起床时间推迟进一步被压缩。尤克里里也因为琴出现了问题闲置了好几天了。</p>\n<p>现在要做的是进一步提高做事的效率以及更严格的作息时间，减少不必要的人际交往成本。</p>\n<p>首先是提高睡眠质量，确保早上能够按时起床。过去的一个星期晚上睡得太迟，有时候甚至要凌晨两点才能入睡，而且由于精力疲劳的原因导致没办法利用入睡前的时间来学习，大多时候是白白浪费在手机上。以后除特殊情况之外，必须确保在12点半之前离开手机进入睡眠状态。只有确保了充足的睡眠，才能为一天的工作与学习打下良好的基础。</p>\n<p>其次是，中午休息和晚上下班之后减少不必要的人际交往成本，比如不参与微信中无意义的聊天。健身回家之后，一般离入睡前都有两个小时的时间，除了留出半个小时和蜜柚妈妈视频聊天之外，其余时间如果没有特殊情况，都不能做没有意义的事情，比如刷朋友圈和短视频之类。</p>\n<p>最后，限本周之内修好尤克里里，坚持每天的半个小时练琴计划。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-这个是一个多元的世界","url":"http://icebergcwp.com/Daily-2018-08-05.html","content":"<p>世界是多元的，相比之下个人的生活圈显得单一，特别是像我这样在二线省会城市的普通青年。最近有两件事情让我感触挺深的，它们彼此之间没有交集，与我的生活也相差甚远。它们代表着世界在同一时段下的不同呈现方式，陌生却又是那么真实。</p>\n<p>第一件事是在朋友圈看到了一篇关于全球变暖导致两极的生态圈剧变，进而威胁了生存于其中的生物的生命。文章图文并茂，措辞严厉，搭配的图片更是让人看得触目惊心。如果仅从周围的生活圈一片“欣欣向荣”的样子，很难联想到离我们很远的地方正在为人类肆无忌惮地地污染环境而深受其害。可悲地是，我并不觉得这种文章会产生多少影响力，很多人包括我很可能只是停留在看完之后的一丝感叹与自责之中，随后又恢复到原有的生活节奏之中。我们常常听到的环保标语是“拯救地球母亲”，然而真相是地球并不需要拯救，真正需要拯救是人类本身，可是我们这个国家举国上下都似乎沉迷于高速的经济发展之中，恐怕想让他们出于环保的目的而放弃既得利益是一件很难做到的事情吧？</p>\n<p>第二件事是下午在YouTube上面看到一段采访视频，采访的主人公是一个在美国纽约追梦的中国女孩。她个人是纽约大学房地产金融专业硕士毕业，毕业之后选择留在纽约拼搏，证明自己的价值。她给我印象最深的除了高学历之外，更多地是一种由内而外的自信。如果仅从大众的审美角度来说算不上美女，属于一个很普通的女生类型。但是她得体的言谈举止、自律的生活节奏和不卑不亢的工作态度在不经意间让人心生敬佩。我认为自信分很多种，最常见也是最肤浅的自信来源于出众外貌或身材，这些先天的优势很容易让人产生优越感，本能也，无可厚非。而最稀缺也是最可贵的自信来源于内心的自律和成熟的心智，也许看似样貌平平无奇，一经接触或交谈便能吸引对方，让人觉得有趣。外貌总会随着时间的流逝慢慢失去了往昔的风采，而一个有趣或者说自信的灵魂却是随着在岁月中酝酿得愈加香醇浓郁。</p>\n<p>世界是多元的，且需要从宏观和微观地双重角度去看待。有时候太局限于个人的生活圈，容易变成井底之蛙，进而变得盲目乐观或者自大，导致对事物的判断出现严重的偏差。我一直觉得，贫穷不是一个人最可怕的状态，无知才是。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-7月小结","url":"http://icebergcwp.com/Daily-2018-08-04.html","content":"<p>过去的一个月去繁从简，除了工作之外，把精力按主次分别放下英语、专业以及尤克里里上面。</p>\n<p>首先说说英语学习。从大学毕业到现在，我一直都没有放弃过学习英语，尽管期间多次半途而废。归根到底是因为我没有找到一套适合我的学习方法。我一直相信一句话：让你能够坚持到最后的不是毅力而是科学的计划。这一次我再次鼓起勇气重头开始，将过去的积累全部清零。花了三天时间查阅关于成人学习英语的一些方法和他人经验，最终决定放弃过去赛西喵主张的以背单词（麦克米伦7000常用词汇）为主的入门方法，而是采用了恶魔的奶爸在《把你的英语用起来》一书中主张的“input+1”窄输入的学习思想，配合ESLPod+赖世雄美式音标，多听加跟读的方式。目前来说，这套学习方法挺适合我，也带给我一些学习的乐趣，感受到了英语的韵律之美。此外，这个方法能够很好的利用碎片时间，也有丰富的辅助资料。</p>\n<p>其次是专业学习。过去对于业余时间的专业学习采用的是“自上而下”的方式，即先确定需要学习的知识点，然后单独划出一大块的时间用来系统且全面的学习基础理论，最后通过课后练习题进行巩固。这有点像过去应试教育的学习方式，因此难免有点枯燥且脱离了实际应用。最近一段时间尝试使用“自下而上”的学习方式，以实际工作需求为出发点，抱着解决实际问题的心态去了解某一个或多个知识点，了解知识点在实际应用中的作用和用法。这种方式更为高效且更能激发大脑的积极思考，加深对知识点的理解。</p>\n<p>最后是尤克里里。起初学习尤克里里纯粹是因为了解到尤克里里很容易上手，而且它的外形很cute，有种一见钟情的感觉。然而，现实是除了确实很可爱之外，尤克里里并没有网路上说的那样简单易学。再加上我的尤克里里弦距较高，按和弦很疼，这一点让我吃了不少苦头。虽然现在只能勉勉强强弹唱几首简单的曲子，但是练琴的过程让我对于“量变到质变”这个过程有了一种“视觉化”的感受。这真的是一件很神奇的事情，通过不断地练习，可能前一天还弹的断断续续，但是到了第二天突然间就仿佛有如神助一般流畅地完成前一天的曲子。而且这种感觉随着时间的推移越深刻，很明显地感觉到之前感觉很难得曲子一下变得容易很多。也许这就是所谓的“熟能生巧”吧。通过尤克里里的学习，一定程度上让我对于英语学习更有耐心和信心，本质上它们都是需要不断练习，直到形成肌肉记忆。</p>\n<p>以前，我因为感觉到自己的局限性，所以内心总想着急于求成，结果是显得浮躁，多半半途而废。现在，我明白了慢才能成事，就像很多真理都与人类认知相反一样。只有稳扎稳打，步步为营，才是一个人的最快的成长捷径，这其中有一件很重要但是常常被忽视的事实是：这种方式积累的进步可能是指数增长的，一旦度过了平缓的煎熬期就会有明显的进步。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-知其然知其所以然","url":"http://icebergcwp.com/Daily-2018-08-03.html","content":"<p>今天在iOS开发过程中遇到了一个新的概念BitCode，简单的做法只要在Xcode关闭掉一个编译设置就能够解决这个问题。但是我的内心都有一种欲望想去了解BitCode的来龙去脉。</p>\n<p>我不能保证换做以前的我是否会有这样的冲动，但是因为最近对于学习这件事情有了一些新的领悟，对新的事物总有打破砂锅问到底的欲望。更重要的是这是一种由内而外的驱动力，而非外界的压力。</p>\n<p>很喜欢自己现在的状态，也很庆幸自己能有现在的状态。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-经济学中的成本","url":"http://icebergcwp.com/Daily-2018-08-02.html","content":"<p>最近在《薛兆丰经济学讲义》一书中看了“成本”这一概念在经济学中的定义，这与我过去的理解截然不同。</p>\n<p>书中专门有一章是讲成本的概念，可见成长在经济学中占有非常重要的地位。书中说如果我们对成本的概念有了深刻的理解，就可以说对经济学了解了一半。</p>\n<p>我以前对于成本的理解是做某件事情需要付出的代价，包括物质、金钱和劳动力等。然而，书中对成本的定义是：成本是放弃了的最大代价。换言之，如果做一件事情没什么可放弃的，也就不存在成本。比如，如果你选择做事情A的，那么就不能做事情B、C、D、E…。那么你做事情A的成本就是你所放弃的其他选项中价值最高的那个。</p>\n<p>与成本容易混淆的一个概念是沉没成本。沉没成本是指那些已经发生但是不可收回的支出。比如你买票去看一场电影，但是看了10分钟之后你觉得这个电影不好看，最合适和做法就是马上离开电影院。此时，买电影票的钱已经沉没了，不可再放弃，也就不再是成本了。但是很少有人会在这种情况下果断地离开电影院。</p>\n<p>既然成本的定义是“所有放弃了的选项中价值最高的那个”，但问题是所有放弃的选项并没有实现，我们又如何知道自己放弃东西的价值呢？答案是，这个价值只能靠想象。这正是成本深奥的原因所在。这个想象空间吸引了众多经济学家在成本的概念上下大功夫。他们充分挖掘了想象空间，分析公共品使用的成本、制度变迁的成本、社会成本、竞争本身带来的成本，将我们对世界的理解拓宽到前所未有的领域。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-学习学习再学习","url":"http://icebergcwp.com/Daily-2018-08-01.html","content":"<p>最近一个阶段的学习经历，我似乎体会到了一点点关于学习的奥义，简而言之即：学习学习再学习。</p>\n<p>过去的大多数，我都是处于一种“急于求成”的学习状态，对于看到的书，学过的知识点都不会有再次学习的想法。我想这种学习的方式来源于过去十几年的应试教育的影响，那时候的学习目的都是为了考试，属于填鸭式的被动式学习，自然效率很低。</p>\n<p>通过最近学习英语、尤克里里以及专业知识，都是一种反复和螺旋式的学习方式。比如英语学习，如果按照过去的学习方式，一篇文章听个几遍感觉得差不多就会进行下一篇文章。最后仅仅学了几篇文章之后开始信心动摇，半途而废。这一次我决定放慢节奏，同样是一篇文章我会反反复复地听，期间发现自己发音有问题，于是利用碎片时重新学习音标和发音标准，然后再通过听文章巩固发音的细节。</p>\n<p>实话说，这种学习-拆分-再学习-再拆分的学习过程是很枯燥且痛苦的。但是我想这就是学习的奥义，具体的说是学好的奥义。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于主动学习的一点体会","url":"http://icebergcwp.com/Daily-2018-07-31.html","content":"<p>最近一段时间在研究Google Protocol Buffer，期间看了很多资料，包括官方文档，技术博客，相关论坛等。总的来说，官方文档算是最为全面的，技术博客大多都是对官方文档的一些个人经验总结。不过也有几篇博客质量很高，剖析了其中的实现原理。等我对这项技术有了进一步的认识之后，也会写一篇相关的博客。</p>\n<p>意识并不是我今天想要表达的主题。我想要表达的是这几天对学习这件事情的思考，更准确地说是主动学习。如果说仅仅从应用的层面来说，我目前已经基本上掌握了Google Protocol Buffer的使用方式，以及如何集成到实际项目之中，这也是网路上大部分博客记录的内容。但是，我内心是渴望理解其内部的原理和思想，这才是我学习这项技术的初衷。</p>\n<p>主动学习的过程，在我看来是一个从根部出发，不断地发现知识盲点和扩展知识面的过程，最后形成一颗系统的知识树。比如，Google Protocol Buffer这项技术中使用了另外一个很重要的技术：zigzag，这是一项对正负数重新编码的技术，使负数能用更少的空间表达。之所以使用zigzag是因为负数的二进制表达使用的是补码，为此占用了很多无意义的空间，这与Google Protocol Buffer的目标是相违背的。为了理解zigzag算法，我不得不重新温习以前大学的基础知识：原码、反码和补码。更让我感到惭愧的是，通过这一次的“温习”，我发现自己过去对原码、反码和补码的由来和实际意义都缺乏了解，只是停留在它们表达式的层面。简单的说，原码的产生是为了表达正负数，用字节的最高位来标识正负。然而，原码的存储方式容易被人类接受，但是却很难被计算机理解，因为计算机不能识别符号标识位，因为正负数计算会得出错误的结果。为了解决这一问题，人们发明了反码：正数的反码是其本身，负数的反码保持符号位不变，其余位置取反。这样虽然解决了正负数计算问题，但是出现新的问题：同时存在+0和-0。为了解决这一问题，在反码的基础上（反码+1）产生了补码。因此，计算机最终使用的是补码。</p>\n<p>如果我的学习目的仅仅是停留在应用的层面，那么就不会有后续对zigzag和补码的进一步理解。这就是主动学习带来的知识扩展，且这种学习方式是高效率的。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-几个典型的幸存者偏差现象","url":"http://icebergcwp.com/Daily-2018-07-30.html","content":"<blockquote>\n<p>幸存者偏差，就是忽略了筛选条件，认为经过筛选的结果是随机产生的。</p>\n</blockquote>\n<p>幸存者偏差的现象的普遍的存在于我们现实生活中的，我们往往容易以自己的生活环境和经历为出发点去看待一件事情，把看到的结果当成是普遍存在的结果。</p>\n<p>最近网上有一个《假中国系列》恰好说明了幸存者偏差现象普遍存在且容易被我们忽视。下面一一列举其中的个例。</p>\n<ol>\n<li>中国本科生以上的学历占比不到4%</li>\n</ol>\n<p>实话说，刚开始看到这个观点，我有点难以接受。因为就我个人而言，朋友圈的好友有将近一半都是本科毕业，也就是50%。然而，我们很容易忽视一个客观事实，就是中国人口基数很大，有近14亿之多。国家统计局数据显示1998-2016年本科以上毕业生总数是4756万，2016年中国人口为13.83亿，算下来本科以上的毕业生占比3.44%。加上去年和今年的最新数据，以及1998年以前少的可怜的数据和中间计算的问题，可以肯定不会超过4%。</p>\n<ol>\n<li>中国只有不到0.4%的存款人全部存款超过50万。</li>\n</ol>\n<p>关于这一点，我的质疑不是很大，但是也刚开始也会产生质疑。毕竟时常看到知乎和虎扑上面很多人都年薪百万。不过，中国现在的贫富差距之大，以及高房价掏空了大部分中产阶级家庭的储蓄，真正有50以上的存款的人很少。而且，其中这0.4%中很大一部分都是巨富家庭。</p>\n<ol>\n<li>中国缴纳个税的人数只有2800万</li>\n</ol>\n<p>关于这一点，我还是倾向于相信的。除了公务员和事业单位，不缴纳个税的人往往是特别贫穷（不缴纳社保和五险一金的工作，或者没有到达起征点），或者是特别富裕（不拿工资所以不用缴纳个税）。</p>\n<ol>\n<li>全国居民人均可支配收入全年25974元</li>\n</ol>\n<p>2017年国家统计局数据，全国居民人均可支配收入25974元。目前中国20%低收入人群每月只有430多块钱，还有20%的中低收入平均不到一千块钱，这两个群体的总人数是5.5亿元。</p>\n<p>前不久看一个纪录片，在西北的一个村庄，一对夫妇为了送孩子去县城高考，把家里的羊买了凑了500块钱，作为一个生活在城市的人很难想象或者容易忽略这些贫困家庭的存在。</p>\n<ol>\n<li>A股持有100万以上市值的自然人账户占自然人账户比例的2.53%</li>\n</ol>\n<p>中登公司2016年6月数据，1/4账户市值不超过1万块，10万以下的占比3/4，100万以上的比例2.53%。</p>\n<ol>\n<li>中国目前有约8200万人，占总比人口比例6%领取低保</li>\n</ol>\n<p>这个是民政局今年5月公布的数据，此外，16岁以下和60以上不参加劳动的人口占总数人口35%比例（2-17年国家统计局数据）</p>\n<p>总体上中国1.8人养1个人。</p>\n<p>以上这些触目惊心的现象是客观存在的，但是因为幸存者偏差，造成了我一种对于中国现状过于乐观的假象，进而导致看待一些社会现象存在偏差和误解。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于手机对现代人的重要性","url":"http://icebergcwp.com/Daily-2018-07-29.html","content":"<p>刚刚一个朋友对我说起他昨天将手机关机一天，感觉到久违的安静。听后，我仔细回顾了我这一天，猛然发现自己浪费在手机上的时间至少占了三分之一以上，更可怕的是如果不是朋友提醒我，我完全没有察觉。</p>\n<p>毫不夸张地说，手机现在已经成为大部分人，更准确地说是大部分年轻人，不可或缺的东西。手机至于我们，就像空气之于生命，存在时觉得习以为常，一旦失去就会“窒息”，生活节奏完全被打乱，无所适从。</p>\n<p>手机上的诱惑实在是太多，这远非大部分年轻人能够抵抗住的。我自认为是一个比较克制的人，并且会刻意的远离微博和抖音这样的平台。但是，有时候还是会在无形中被其他的平台吸引。现在网络上充斥着各种所谓“有趣”的短视频和“治愈”的鸡汤文，它们不但浪费了年轻人的生命，还输出了各种片面的价值观，比如消费主义、自由主义和个人主义。在各种碎片知识和所谓的普世价值观中，我们很容易失去了主见，完全由媒体来主导我们的思想。</p>\n<p>最让我细思极恐地是，即便是你心里明白这些道理，但还是会在不知不觉中陷入其中而不自知。鉴于此，我决定以后限制性地使用手机，只在固定的时间段主动手机上的社交应用。具体时间如下：</p>\n<ol>\n<li>早上7:30 - 8:00</li>\n<li>中午12:00 - 12:30</li>\n<li>晚上22:00 - 22:30</li>\n</ol>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于中国的户籍改革","url":"http://icebergcwp.com/Daily-2018-07-28.html","content":"<p>今天这篇文章是看《意见中国–经济学家访谈录》第112期，秦晖教授谈论“户籍制度背后的三大不平等”的观后感。</p>\n<p><strong>观点一：户籍制度改革落后于人们的期望</strong></p>\n<p>有人说这种户籍制度只有中国和北朝鲜才有，其实把人分成不同等级和身份，享有不同权利的制度很大程度上在前现代很多民族都有。</p>\n<p>但是这种身份性等级制度是以国家法律的方式强制推行，并且普及到社会几乎所有人，且有具有很明显的原始记录功能的个例很少。另外一个类似的例子出现在南非种族隔离时代。</p>\n<p>这种制度的产生的主要原因是为了实现国家的原始积累。一方面，大量的农民工进城打工带来拥有廉价劳动力，又因为城市户籍人口远小于农村人口因此城市有大量的廉价土地，这是所谓的良好投资环境的基础要素。另一方面，一旦城市不需要这些农民工，可以通过户籍制度驱使其中的大部分人回到农村，避免了一些国家由于自由居住造成的城市贫民窟问题。</p>\n<p>户籍制度背后是人权、财产权和公共服务的不平等。普通的外来农民工对户籍改革的期望很低，只有不被赶出贫民窟，不需要任何补偿。很多发展中国家的飞速发展都是建立在低人权的基础之上。</p>\n<p>在户籍改革之前，即取消现存户籍类别之前，农村人口是不能随便进城，如果一定进城需要有相关的证明，否则就可能被抓，到后面逐渐改为罚款，再到现在的默认迁移。从这个趋势来看，都是朝着废除户籍和不合理的身份等级的方向发展。只不过离人们的预期还有相当大的距离。而造成户籍制度落后的原因是：政府权力不受限制和政府的责任不可追问。</p>\n<p><strong>观点二：户籍制度考验人的忍耐力</strong></p>\n<p>户籍制度需要改革其背后的三大平等：一是人权不平等，尤其是居住权；二是财产权不平等，即农民的土地不是他们真正的财产；三是公共服务福利的不平等。</p>\n<p>在一个宪政国家，比如欧美国家，一个国家政府能够承担多大的公共服务责任，公民就为让出相应的权利，这是由契约决定的。</p>\n<p>然而，现在的中国拥有一个无限权利的政府，但是百姓又不能对其进行问责。这就是造成这三个不平等的根本原因。</p>\n<p>对于受户籍制度管制的百姓来说，现在的户籍制度对他们没有什么积极的意义可言，只是一个忍耐力的问题罢了。</p>\n<p><strong>观点三：减少大城市的吸引力</strong></p>\n<p>很多人担心农村人口大量涌入城市，造成大城市规模的过度膨胀，因此需要“排挤”很大一部分外来人口。然而，从另外一个角度来看，之所以造成这种现象是因为这些大城市享有的特权远远大于其他地方。比如北京，即是集政治、经济、文化三个中心唯一体，享受最后的社会福利和资源。</p>\n<p>如果能够通过减少大城市的吸引力，平衡不同城市直接的吸引力和特权，才是解决问题的根本。</p>\n<p><strong>小记</strong></p>\n<p>早上与好友聊天，我们以前在一个镇上读小学。他对我感叹到现在我们镇上的孩子只能在镇上完成九年义务教育，除非你在县城买房子。记得我们读书那会还可以通过考试进入县城的高中读书。</p>\n<p>教育资源的稀缺的，县城的资源绝对不是镇上能比拟的。有稀缺就要区别对待，区别对待就意味着歧视。另外一个原因是，现在城市人口比例已经超过农村人口，不同与我们那个时候农村人口占多数。因此，现在对农村人口进行这样赤裸裸的歧视，其实是对于弱势群体的歧视。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于二元户籍制度","url":"http://icebergcwp.com/Daily-2018-07-27.html","content":"<p>作为一个农村的90后，尽管小时候中国的二元户籍还没有取消，但是一直到进城工作之前都没有感觉到这种制度带来的影响，或者说觉得它的存在是理所当然的。比如前不久因为要考驾照办理暂住证，并没有去想办暂住证的意义何在。</p>\n<p>最近看了秦晖教授关于中国户籍制度的一些观点，了解中国的二元户籍已经被取消了。秦晖教授认为取消二元户籍制度是一种进步，或是说把人口类别重新做一个归类。但是取消户籍制度并没有解决进城的农民工受到歧视的现象。实际情况，随着农村人口向城镇的迁移，农村人口和城市人口的界限已经变得模糊。但如果你是外地的穷人，意味着没有城市居住权，那么你在享受城市的福利和资源就会受到不平等对待，即受到歧视。</p>\n<p>中国过去是农业大国，农村人口占70%，二元户籍制度主要是为了限制农村人口流动，控制城市人口规模。现在中国逐渐从农业大国向工业大国转型，需要农村的劳动力向城市转移，取消二元制度的原因就在于此。但是因为城市和农村的福利和资源差不太大，因此导致大量的农村人口涌现城市。政府为了控制超大城市的人口规模，通过提升房价和提高落户条件，抬高了在大城市定居的门槛。然而，秦晖教授认为，政府如果减少对城市的特权，将部分福利转移到农村，那么也可以缓解这种情况。</p>\n<p>总体来说，形式上二元户籍制度已经成为历史，但是只要城市和农村的存在被差别对待，仍会有一种无形的“户籍制度”存在，将农村人口和城市人口区别对待。更可悲的是，没能在城市定居农民工在为城市化建设贡献完自己的力量和青春之后只能再回到农村。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-几个认知边际","url":"http://icebergcwp.com/Daily-2018-07-26.html","content":"<p>中午看了张维迎做客的《锵锵三人行》，里面谈及了几个认知边际，颇以为然，遂记录下来：</p>\n<ol>\n<li><p>语言的腐败：比如用正当的口号掩盖不正当的行为</p>\n</li>\n<li><p>人类对政府有着天然（从小被教育）的信任，认为政府是高尚的，行为是正当的。然而，政府也是个人运转的，政府官员也是有七情六欲的普通人，问题是如何约束他们。</p>\n</li>\n<li><p>信念对个人利益的影响，普遍认为的个人利益都是以金钱衡量的，然而本质上个人利益上最终上由信念决定的。比如棋圣吴清源的最在意的个人利益也许就是一个安全的环境和一个可以放下棋盘的空间。</p>\n</li>\n<li><p>现在很多官员喜欢说假话，然而说假话本身不可怕，可怕的是说假话还能信誓旦旦，不面不改色。</p>\n</li>\n<li><p>大部分的人祸都是由大多数人的无知和少数人的无耻造成的。</p>\n</li>\n</ol>\n<p><strong>一点感想</strong></p>\n<p>最近在看网易财经出品的《意见中国》访谈系列，里面做客的都是国内外知名的经济学家。我以前对经济学家的印象都是觉得他们是个人利益主义者，或者是政府的代言人。然而，通过最近对经济学的学习与认知，了解到经济学研究的是社会客观地运作方式以及与陌生人交流互动的学问。我改变了对经济学家过去的偏见，觉得他们很可能是世界上最有良知的一群人，也是最有预见性的一群人。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-经济学的基础：稀缺","url":"http://icebergcwp.com/Daily-2018-07-25.html","content":"<p><strong>稀缺与歧视</strong></p>\n<p>稀缺是人类一直面对的问题，也是客观存在的事实。稀缺的含义非常之广，不仅指矿产、森林和能源等有形资产的匮乏，还有空气、美貌、天资、意志力和时空等无形资产稀少。</p>\n<p>此外还有很多不易觉察到的稀缺资源，比如说地理位置的稀缺，如北上广这些一线城市的地理位置是稀缺的。另外信任也是稀缺的，不是可以随便建立起来的。同学之所以重要，是因为同学决定了你将来社交的圈子、工作层次。许多人读书的首要目的就是为了与同学建立信任这一项长期投资。</p>\n<p>稀缺之所以一直客观存在，主要由两个原因：一是我们想要的东西别人也想要；二是人的需求在不断变化和升级，人的欲望是无止境的。</p>\n<p>因为资源的稀缺，人们就不得不对资源的用途进行选择，而一旦做出选择就意味着存在区别对待，而区别对待就是歧视。（我觉得歧视在此处应该是中性词）</p>\n<p>稀缺、选择、区别对待和歧视这四个概念，其实是一体的，只要有一个就意味着同时有其他三个。因为稀缺是客观存在的，因此歧视也是客观存在的。</p>\n<p>既然不能逃避歧视，那么久只能直面歧视。有时候我们抱着平等主义的思想，试着消除歧视，结果却是产生了新的歧视，这也被称之为逆向歧视。</p>\n<p>所以说，歧视不是问题，如何歧视才是问题。</p>\n<p><strong>中年人的魅力</strong></p>\n<p>今天听了梁实秋先生的文章《中年人的魅力就在如此》，里面的观点我个人比较赞同。虽然尚未进入中年，但是中年的困境的没办法逃避的，遂记录自勉：</p>\n<ol>\n<li><p>某个时期，某个社会，即使所有的青年人和老年人都中魔了，只要中年人不荒唐，事情就怀不到哪里去。</p>\n</li>\n<li><p>到了该自立的年岁还不知道精神上的自立，这是中国很多中年人的共同悲剧。</p>\n</li>\n<li><p>中年人最容易犯的毛病，是把一切希望寄托于自己的老年。</p>\n</li>\n<li><p>如今天天节衣缩食、不苟言笑、忍气吞声，都是在争取一个有尊严、有资材、有自由的老年。</p>\n</li>\n<li><p>我们无数次看到，一个窝囊的中年抵达不到一个欢乐的老年。这正像江河，一个浑浊的上游不可能带来一个清澈的下游。</p>\n</li>\n<li><p>习惯了郁闷的，只能延续郁闷；习惯了卑琐的，只能保持卑琐。而且，由于暮色苍茫间的体力不支，有朋散失，郁闷只能更加郁闷，卑琐只能更加卑琐。</p>\n</li>\n<li><p>中年人失去方寸的主要特征是忘记了自己的年龄，一会儿要别人像对待青年那样关爱自己，一会儿又要别人对待老人那样尊重自己。</p>\n</li>\n</ol>\n","categories":["日记"],"tags":[]},{"title":"iOS开发之真机测试问题：Could not locate device support files","url":"http://icebergcwp.com/iOS开发之真机测试问题：Could not locate device support files.html","content":"<p>最近在做iOS真机测试时出现了运行失败的提示：“Could not locate device support files”。原因在于我的iPhone6上的iOS版本上11.4，而Xcode的版本是8.3.3，当前的Xcode过低不能将App安装到iOS11.4上。</p>\n<p>在目录<strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/</strong>下可以查看当前Xcode所能支持的最高iOS版本。在我的电脑上，Xcode8.3.3自带（默认）所能支持最高的iOS版本是10.3.1 (14E8301)，版本号后面的括号时该iOS版本的编译ID，可以忽略。</p>\n<p>解决方法一般有两种：</p>\n<ol>\n<li><p>安装与iPhone中iOS版本对应的Xcode版本，或者直接安装最新的Xcode版本。这种虽然简单，但是安装Xcode耗时太长，除非你恰巧有升级Xcode的需求，可以考虑这种方案。</p>\n</li>\n<li><p>拷贝与iPhone中iOS版本对应的Device Support文档到目录<strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/</strong>中，然后重启Xcode即可。</p>\n</li>\n</ol>\n<p>至于Device Support文档的来源，我想这个<a href=\"https://github.com/filsv/iPhoneOSDeviceSupport\" target=\"_blank\" rel=\"noopener\">GitHub仓库</a>应该能够满足你的需求。</p>\n","categories":["专业","iOS"],"tags":["iOS"]},{"title":"Daily-英语发音规则总结","url":"http://icebergcwp.com/Daily-2018-07-24.html","content":"<p><em>语句最常用的功能就是口语表达，一切的规则都是为了轻松且简单的表达！</em></p>\n<p>最近在学习ESLPod的“Introducation to the United States”系列，在跟读的时候感觉挺吃力，一方面是因为对音标熟练程度不够，另一方面就是对英语发音规则缺乏认知。秉着主动学习的态度，通过在网路上查阅资料，对英语发音规则有如下总结。</p>\n<p><em>英语发音规则的建立在对音标熟练且准确掌握的基础之上！</em></p>\n<p>英语发音规则除了连读还包括浊化、爆破、同化、异化、缩读和略读等。大致包括七大技巧，它们分别是：</p>\n<p><em>注：音标用-连接的地方表示要连读</em></p>\n<p><strong>第一大技巧 连读的两大规律</strong></p>\n<ol>\n<li><p>词尾辅音+词首元音<br> eg: Time is up =&gt; [taim-iz-ʌp]</p>\n</li>\n<li><p>词尾元音+词首元音</p>\n<p> (1). 在遇到前一个词是以[ei][ai][ɔi][i:][i][e]这几个元音结尾的情况，加[j]连读</p>\n<p> eg: Hurry up =&gt; [hʌri-j-ʌp]</p>\n<p> (2). 在遇到前一个词是以[aʊ][u:][ʊ]这个几个元音结尾时，加[w]连读</p>\n<p> eg: How often do you swim =&gt; [haʊ-w-ɔfən]</p>\n</li>\n</ol>\n<p><strong>第二大技巧 浊化的两大规律</strong></p>\n<p>所谓浊化就是把清辅音读成浊辅音</p>\n<p>清辅音：[p][t][k][f][s][θ]</p>\n<p>浊辅音：[b][d][g][v][z][ð]</p>\n<ol>\n<li><p>元音+清辅音+元音</p>\n<p> eg: letter =&gt; [‘lɛdɚ]  watter =&gt; [ˈwɔdɚ] , stay out of this matter =&gt; [stei-y-aʊ-dv-ðis mædɚ]</p>\n</li>\n<li><p>元音+T+L</p>\n<p> eg: battle =&gt; [bædl] cattle =&gt; [kædl]</p>\n</li>\n</ol>\n<p><strong>第三大技巧 爆破的四大规律</strong></p>\n<ol>\n<li><p>爆破音略读：当前一个单词的词尾是爆破音（[p][t][k][b][d][g]）且后一个单词的词首也是爆破音，则省略前一个单词的词尾。</p>\n<p> eg: take care =&gt; [tei-kɛr]</p>\n</li>\n<li><p>不完全爆破：所谓不完全爆破就是对于需要爆破的音，我们仅仅摆出对于的口型而不发出声音。</p>\n<p> (1). 词尾爆破音+摩擦音（[f][s][θ][v][z][ð][r][j][w][ʃ][ɛ]）</p>\n<p> eg: I’m almost there =&gt; [im ɔlmos(t) ðɛr]</p>\n<p> (2). 词尾爆破音+破擦音[tʃ][dʒ][ts][dz][tr][dr]</p>\n<p> eg: That joke =&gt; [ðæ(t) dʒok]</p>\n<ol>\n<li><p>鼻音爆破省略：同一意群内，爆破音在鼻音[m][n][ŋ]前，爆破音省略以停顿代替</p>\n<p>eg: Good night =&gt; [gʊ(d) nait]</p>\n</li>\n<li><p>舌边音爆破省略：爆破音+舌边音[l]</p>\n<p>eg: It’s deadly =&gt; [it z dɛ(d)li] , Old lady =&gt; [ol(d) ledi]</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>第四大技巧 同化的二大规律</strong></p>\n<ol>\n<li><p>相互同化</p>\n<p> (1). /t/+/j/-&gt;/tʃ/</p>\n<p> eg: I got you =&gt; [i gɑ tʃ u]</p>\n<p> (2): /d/+/j/-&gt;/dʒ/</p>\n<p> eg: Did you =&gt; [Di dʒ u]</p>\n<p> (3) /s/+/j/-&gt;/ʃ/</p>\n<p> eg: God bless you =&gt; [Gɑ blɛ ʃ u]</p>\n<p> (4) /z/+/j/-&gt;/ʒ/ </p>\n<p> eg: How is your boyfriend =&gt; [Haʊ iz ʒ ʊr]</p>\n</li>\n<li><p>顺向同化：主要同于词尾加s和ed的情况，这两个音都存在清辅音和浊辅音两种发音，具体发音与该音的前一个音标的清|浊一致。</p>\n<p> (1). 名词的复数</p>\n<p> eg: friends =&gt; [frɛndz] , books =&gt; [bʊks]</p>\n<p> (2). 第三人称单数</p>\n<p> eg: works =&gt; [wɜːks]</p>\n<p> (3). 过去式或过去分词</p>\n<p> eg: looked -&gt; [lʊkt]</p>\n</li>\n</ol>\n<p><strong>第五大技巧 异化：所谓异化就是当清辅音夹在/s/和元音之间时，清辅音发生浊化</strong></p>\n<ol>\n<li><p>sp+元音</p>\n<p> eg: speak =&gt; [sbi:k]</p>\n</li>\n<li><p>sk+元音</p>\n<p> eg: school =&gt; [sgʊl]</p>\n</li>\n<li><p>st+元音</p>\n<p> eg: start =&gt; [sdɑrt]</p>\n</li>\n<li><p>str+元音</p>\n<p> eg: strange =&gt; [sdrendʒ]</p>\n</li>\n</ol>\n<p><strong>第六大技巧 缩读：缩读规律性不强，不能一一列举</strong></p>\n<ol>\n<li><p>常见缩读</p>\n<p> (1). want to =&gt; [wanna]</p>\n<p> (2). be going to =&gt; [be gonna]</p>\n<p> (3). got to =&gt; [gotta]</p>\n<p> (4). because =&gt; [‘cause]</p>\n<p> (5). out of =&gt; [outta]</p>\n<p> (6). you =&gt; [ya]</p>\n<p> (7). what is the =&gt; [what’sa]</p>\n<p> (8). sure =&gt; [sher]</p>\n<p> (9). what are you =&gt; [wachya/wacha]</p>\n<p> (10). ing =&gt; [in’]</p>\n</li>\n<li><p>情态动词完成时和过去将来时的不规则缩读</p>\n<p> (1). could have =&gt; could’a</p>\n<p> (2). must have =&gt; must’a</p>\n<p> (3). should have =&gt; should’a</p>\n<p> (4). would have =&gt; would’a</p>\n</li>\n<li><p>of的不规则缩读 (本质上是由于语速+f的弱读+上下文导致)</p>\n<p> (1). kind of =&gt; kinda</p>\n<p> (2). a lot of =&gt; a lotta</p>\n<p> (3). lots of =&gt; lotsa</p>\n<p> (4). sort of =&gt; sorta</p>\n<p> (5). bunch of =&gt; buncha</p>\n<p> (6). because of =&gt; becausa</p>\n</li>\n</ol>\n<p><strong>第七大技巧 略读</strong></p>\n<ol>\n<li><p>词尾爆破音略读</p>\n<p> eg: very goo(d) , nerver give u(p)</p>\n</li>\n<li><p>意群结尾的爆破音</p>\n<p> eg: I thin(k) you shouldn(t) punish him too har(d)</p>\n<p> 注：I + think是一个意群，经过think后面紧接you，但是you属于宾语从句，不是一个意群。 </p>\n</li>\n<li><p>同类音：[s]/[θ] , [s]/[ʃ], [z]/[ð]，谁在前面谁先死</p>\n<p> eg: Thi(s) shop i(s) so romantic </p>\n</li>\n<li><p>t音的消失： 当[t]在[n]和元音之间（原因可能是[t]的音弱读像边音l因此可以直接略读）</p>\n<p> eg: Internet =&gt; [In(t)ɚnɛt] </p>\n</li>\n</ol>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于专业学习","url":"http://icebergcwp.com/Daily-2018-07-23.html","content":"<p>最近对“主动学习”与“被动学习”有了进一步的体会，从内心能够感受到“主动学习”带来的高效率。</p>\n<p>从小到大，我主要接受的教育都是以应试为目的的被动学习，为了考试而学习。这种填鸭式式的教育，不但效率低下，而且让我很长一段时间对学习这件事情有了排斥和厌恶感。更可悲的是，这种“被动学习”的思维一直潜移默化地影响着我。</p>\n<p>毕业之后，我有意识地想加强专业方面的知识积累，却一直没有实质性的进展。根本原因在于我一直处于一种“被动学习”，被动地接受各种新的知识且都是浅尝辄止。我内心渴望一下子就掌握多种专业知识，就像以前的应试教育一样，同时面对多门课程。然而，这种方式最终的结果多半是半途而废，且不断地消磨意志力。</p>\n<p>以后的学习方式，我都会采用“主动学习”的方式，一次只专注一个知识点的学习，并以这个知识点为主干建立对应的知识体系。恰巧最近工作上接触到了“google protocol buffer”–一种轻便高效的结构化数据存储格式，很好奇其内部原理，因此第一个“主动学习”的知识点就它吧。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-健忘的国人","url":"http://icebergcwp.com/Daily-2018-07-22.html","content":"<p>最近的假疫苗事件闹得沸沸扬扬，网路各大平台、微信公众号以及朋友圈都在围绕这件事发表个人的观点和愤怒。我内心也很愤怒，憎恨那些万恶的商人和腐败的官僚，为了个人利益，不惜将魔爪伸向孩子的健康领域。与此同时，我也感到很无助，对中国现在政府对待这类事件的态度感到很失望，对国人的健忘性感到很无奈，我也是其中一员。</p>\n<p>我们这个民族最缺的就是记性，我们总是很快将以往发生的那些重大事情忘记，不会自我反思和自我反省，而是一味地“与时俱进”，将注意力着眼于当下很多无意义的热门话题，其中大多数都是娱乐话题。</p>\n<p>我不知道我们的民族为什么会这样，可能以后会知道原因，但是现在我很困惑。好像健忘性一直以来都根植在我们这个民族的血液里面。即便是对待南京大屠杀这样的民族之耻，我们给出的只是一个笼统的数字而已。</p>\n<p>我相信有一部分人是明智且清醒的，但是我更愿意相信大多数人是愚昧且无知的。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-亚当·斯密的人性观","url":"http://icebergcwp.com/Daily-2018-07-21.html","content":"<p>亚当·斯密作为市场经济之父在经济学界德高望重，他最为人们熟知的两本书分别是《道德情操论》和《国富论》。然而，这两本书阐述的人性观却是截然相反。</p>\n<p>《国富论》主张人性是自私的。斯密有句名言：“每一个人，不需要自己关心社会福利，他也不知道自己怎么去推动社会的福利，他只需要关心自己，追求自己的福利就可以了。与此同时，会有一只看不见的手让他的努力转变为对公共事业的推动。这只看不见的手会让个人的自私自利推动社会福利的改进。”</p>\n<p>《道德情操论》主张人不仅仅是自私的，同时有道德且具有同情心，也就是有一种设身处地为他人着想的能力。人们把自己认为的别人是否幸福，当做自己是否幸福的一部分。这是一种天生的能力，叫“同情心”。</p>\n<p>亚当·斯密的两种观点表面上看来是自相矛盾，然而斯密的第三个观点告诉我们之前的两种人性观是共存的。斯密认为：“人的同情心是随着人与人之间距离的拉远而急速减弱的。”</p>\n<p>有一种说法认为经济学是建立在人性自私的基础上的，结合人际互动二分法：小圈子靠爱心，大世界靠市场。这种说法在市场范围内是成立的。小圈子靠爱心、讲同情心，而大世界靠市场、讲规则。斯密的重要建议是：在家庭和朋友圈内不斤斤计较，过分讲究市场规则。但是在市场上则不要强求陌生人表现出不切实际的爱心。</p>\n<p>简而言之，人性具有两面性，在不同的情况下用不同的方式对待。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-平淡的一天","url":"http://icebergcwp.com/Daily-2018-07-20.html","content":"<p>今天过得很平淡，上午一到公司便全身心地投入工作之中。要不怎么说兴趣是最好的源动力呢，最近做的项目还有点意思，所以主观能动性很强，工作也比以往更加投入。</p>\n<p>这让我联想到主动学习和被动学习。二者的效率差别很大：主动学习是有目的性的完善知识体系，能够引发更为深入的思考。而被动学习则与接受的知识有关系，如果接收到的信息恰好能填补现有知识体系的缺口，那么才有可能被吸收，否则都会被遗忘。</p>\n<p>然而我们大多数时候都是处于最低效的被动学习。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于英语学习的困惑","url":"http://icebergcwp.com/Daily-2018-07-19.html","content":"<p>最近的英语学习计划执行的很糟糕，脑海里似乎对目前自己使用的学习方法没有足够的信心或者理论支撑。于是今天又看了一遍《把你的英语用起来》书中Dr.Krashen教授提出的最适合中国人学英文的理论，以下是相关笔记：</p>\n<ol>\n<li><p>input输入假说。Dr.Krashen认为英文学习的根本在于input输入，缺乏输入就不可能学好任何一门外语。</p>\n</li>\n<li><p>i+1理论，也叫可理解性输入假说。在一条是在上一条的基础上作进一步补充说明。进行输入练习时，一定要遵循i+1的原则。i代表目前的水平，1代表稍微高一点点的难度。随着自己水平的提高，需要主动的调整输入材料的难度，使之符合i+1。</p>\n</li>\n<li><p>narrow input假说。输入的材料类型和难度级别在一定时间内相对要狭窄。这样做有极大的好处，只输入自己感兴趣的材料，可以把熟悉的语言知识以不同的模式快速熟悉起来。</p>\n</li>\n<li><p>情绪机制。学习材料和环境应该是有趣的、轻松自如的，才能实现效果的最大化。</p>\n</li>\n<li><p>系统化量化。英文学习必须建立一个系统化、量化的流程，规定好整个学习周期的时间，彻底突破。</p>\n</li>\n</ol>\n<p><strong>自勉</strong></p>\n<p>笛卡尔曾经有一个比喻：在森林里迷路，如果不停地换方法，最后的结果很可能是走不下去。然而如果你认准一个方向坚定地走下去，最后一定能走出森林，哪怕你绕了一段远路，但胜利最终是属于你的。所以，如果只有方法没有坚持下去的勇气，一切都是空谈。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于中国房价","url":"http://icebergcwp.com/Daily-2018-07-18.html","content":"<p>今天看张五常先生的讲座，期间被问及：“中国房价是否存在泡沫？”</p>\n<p>张五常先生给出了的解释让我有种醍醐灌顶的感觉，作为在世界都享有名誉的经济学家，看待问题的角度很深刻，往往能够抓住事情的本质。</p>\n<p>他的解释是，中国房价之所以居高不下并且一直呈上升趋势，本质的原因是一定程度上是为了均衡人口分布，减缓长三角和珠三角的人口密集程度，为了防止人口大量的涌入一线城市，高房价是唯一且最有效的闸门。</p>\n<p>张五常先生说，让中国房价降下来很简单，只要提高土地供应以及容积率。但是这样不是政府愿意看到的，不可能让一线城市人口过于密集。</p>\n<p>这让我想起之前的一句话，经济学所代表的是这个世界真实的运转方式，不随个人意志转移的。与之相对的道德，则是我们主观认为这个世界应该的运转方式。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-慢，能成事","url":"http://icebergcwp.com/Daily-2018-07-17.html","content":"<p>很多时候，我们都是用社会通用的成功标准来衡量自己，以至于迷失了自我。</p>\n<p>其实每个人都自己的节奏，按照自己的节奏走，可能有时候会慢一点，但是只要坚持下去，最终都会有所收获。</p>\n<p>人生和健身有一定相似，有的人天赋好，短时间内就能有立竿见影的效果。而大多数人都需要经历漫长的过渡期，可能是一两年，也可能更久。最终坚持下来的人都找到了自己的训练方式，并且塑造出自己的完美身材。</p>\n<p>慢，能成事。我喜欢这种文火慢炖的感觉，以及量变到质变的升华。然而，有时候这个物欲横流的社会容易让人变得浮躁，进而急于求成。</p>\n<p>为此，做成一件事情除了自控力和毅力之外，更需要更为科学的计划。为乏味且漫长的自我提升过程保驾护航，进而顺利地的完成前面的九十九下的积累，最终得到第一百下的成功与喜悦。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于英语学习","url":"http://icebergcwp.com/Daily-2018-07-16.html","content":"<p>我的英语学习链条是很脆弱的，过于碎片化，且抗扰性弱。本质原因是没有一套行之有效的学习系统。</p>\n<p>目前接触到两种英语的学习方式：</p>\n<p>第一种是赛门喵Simo提出的，先通过死记硬背的方式搞定“麦克米伦7000高频词汇”，然后再通过阅读进行巩固。</p>\n<p>第二种是恶魔的奶爸提出的，先根据“听-半跟读-全跟读”的方式搞定入门教材EnglishPod，实现基础积累，再接着搞定进阶的AAT（American Acent Training）,纠正和练习发音。</p>\n<p>我个人更偏向于第二种方式，觉得更符合成人学习的方式。但是，我目前还没有全身心的执行。个中原因除了时间安排不科学之外，更主要是自己没有下定恒心，心理还没做好准备，害怕半途而废。</p>\n<p>晚上再翻阅一下恶魔的奶爸写的《把你的英语用起来》，加深对里面学习方法的理解。此外，把英语学习时间调整到早上，专业学习改为晚上。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-中国传统文化","url":"http://icebergcwp.com/Daily-2018-07-15.html","content":"<p>最近在家看《舌尖上的中国》，见识到中国人们自古以来积累的对食材的独特见解。各地人们根据当地的气候和环境，找到与大自然和谐相处的方式。经过一代又一代人的历史沉淀和打磨，不断地完善具有当地特色的食物和味觉，从而成为了一种文化传统。</p>\n<p>今天和家人一起去了一趟省博物馆，也是一种历史洗礼。以前很少去历史博物馆，所以对于它们没有大多的感受。这次我似乎有点明白了博物馆存在的意义，这是一种历史的传承，文化的传承。</p>\n<p>中国之所以为中国，其根本还是因为它们的传统文化。</p>\n<p>中国在民国以前经历过多次改朝换代，但是都不同于清末时期被西方列强侵略。本质区别在于，之前的朝代变动本质上都是在中国不同民族之间轮流坐庄而已，而且最终不论是谁当权，主流文化还是没有发生变化，因此普通百姓不会觉得有什么不同。而清末民初的社会变革则不一样，这次是中国文化受到了另外一种完全不同的文化的冲击。很多有识之士意识到了这一点，才会带领群众奋起反抗，抵御外来侵略者，普通百姓也有了家破国亡的危机感。</p>\n<p>如今，中国再一次崛起，在国际社会有了举足轻重的地位。随着全球化的进程不断加快，中国的传统面临着消亡和被取代的危险。一想到这一点，觉得有点可悲，但似乎有找不到解决方法。</p>\n<p>说起关于传统文化的传承和保护，日本是我脑海首先想到的国家。他们之所以能够做的很好，很大程度上和这片土地上面的人们有很大关系。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-自律才有自由","url":"http://icebergcwp.com/Daily-2018-07-14.html","content":"<p>自律才有自由，这已经是一句烂大街的口头禅，几乎人人都知道，但是能正确理解并知行合一的人寥寥无几。</p>\n<p>今天在看《圆桌讲究派》时，姜文也说道这句话，并且给出了一个我认为是比较新颖的解释。他说：真正自律的人是能够做到肉体和灵魂，就是能够通过灵魂（我理解为主观意识）操控自己的身体。比如早起这件事情，身体是想留在被窝里面的，但是如果你能通过大脑强制自己起床，那么你就是有一定自律的人。</p>\n<p>我以往对这句话的理解并没有把灵魂和身体区分开来，将整个人作为自律的主体，以至于有时候很难做到自律，毕竟很多时候你不清楚是一件事情的决策者是自己身体还是主观意识。</p>\n<p>今天通过姜文得到了一个新的理解，让我突然想起以前看到的一句话，可以作为佐证。以前在刚开始接触跑步的时候，看到一个观点：“身体是很难达到极限的，有时候放弃是因为人的意念不够导致的”。我当时对此深信不疑，也正是这个观点让我顺利的完成了自己人生的第一个马拉松。</p>\n<p>身体处于本能会在潜意识的情况下帮我们做出决定，有时候对我们是一种帮助，而有时候这成为了懒惰的源头。这样意外着失去了思考的自由和主导自己身体的自由，成为了本能的奴隶，也就成为了普通大众中的一员。而这显然不是我所期望的模样。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-先锋队","url":"http://icebergcwp.com/Daily-2018-07-13.html","content":"<p>以前在初中学中国近代史的时候，书上经常提到一些有识之士作为先锋队，带领学生、工人和群众闹革命。那时候一直不明白为什么一定要有先锋队，并且似乎很强调先锋队的重要性。我当时认为既然革命的主要力量是工人群众，他们才是最重要的组成部分。</p>\n<p>直到最近一段时间通过看视频和听演讲或多或少的了解了一些更为详细的近代史，而且是书本上没有的知识。这恰好解开的关于先锋队的疑惑。我个人觉得先锋队的存在是很有必要的，并且有以下两个主要的依据。</p>\n<p>一是，先锋队都是当时时代背景下的知识分子或精英阶层，他们对大局势有着更为清晰的认识和嗅觉。正因为如此，他们是最早的看清局势的一群人，也是最先觉悟的一群人。而这些能力是普通群众所不具备的。</p>\n<p>二是，群众是愚昧的。这并非贬义，而是阐述一个客观的事实。中国历朝历代的统治者都是使用愚民政策来巩固自己的政权，维持社会稳定。统治者很善于把握一种分寸，让百姓处于一种似懂非懂的认知状态，用温水煮青蛙的方式消耗他们的生命。一旦社会发生动荡，普通群众大都采取一种保守和观望的态度，不会轻易的打破现有的生活状态。此时，先锋队的出现，可以帮助群众分析和看清局势，进而产生觉悟。</p>\n<p>在当下和平年代，虽然没有了先锋队，但是有知识公知的存在。他们的作用和先锋队的一样的。这个社会在看似稳定和谐的外表下，其实隐藏了很多问题。这些问题就像蛀虫一样在不知不觉间“啃食”着这个社会的良知。所以说即便是现在，先锋队的存在还是很有必要的。</p>\n<p>人最可悲的状态就是“愚昧”的过完一生。</p>\n<p><strong>为什么要成为一个懂得双语的人</strong></p>\n<p>今天在听陈丹青在新加坡演讲时，他提到一个观点，大致意思是：一个人应该至少懂得两门以上的语言，这意味着了解两种以上的不同的文化，有助于培养一个人的世界观和价值观。</p>\n<p>其实，新加坡就是一个多语言的国家，其中英语为官方语言，马来语为第二语言，其次是华语。新加坡本身也是一个多元民族的国家，主要有马来人、汉人和印度人等。作为只有一个普通城市大小的国家，新加坡却有着惊人的生产力和经济实力。我想这和它是一个多语言国家是分不开的。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-民国的精英","url":"http://icebergcwp.com/Daily-2018-07-12.html","content":"<p>最近在听关于民国人物列传，里面除了大家耳熟能详的人物，包括鲁迅、蔡元培、胡适、陈寅恪等，还有一些不常出现在大众视野的人物，包括黄侃、赵元任、马一浮、刘文典等。</p>\n<p>这些人物都可谓是民国时期的精英，个个才华横溢，学识渊博。他们都是民国时期的公众人物，展示着民国先进的教育环境和自由的言论氛围，但是也因此容易被世人过度美化或者扭曲。所以，想要知道他们真实的模样只能通过人物传记和野史了解他们普通人的一面。</p>\n<p>在他们光鲜亮丽的光环下面，他们的日常生活和普通没有太多区别。同样会八卦、斗嘴、嫉妒、记仇等七情六欲。我坚信认识一个人最好的角度是平视而非仰视或俯视。</p>\n<p>除此之外，他们几乎都有一个共同的特点，就是出身书香门第或者富裕家庭，差不多都有留学的经历，接受的都是那个时代最好的教育。了解到这一点，其实我多少有一点沮丧。对比与自己的出身和教育水平，与他们相去甚远。虽说不奢望能有他们的成就，但是他们的经历证明了出身和教育对一个人的影响之大。</p>\n<p>通过了解他们的人生经历，让我更深刻地意识到自己的渺小与不足。像他们尚且能不断地看书学习，自我提升，我更没有借口和理由不努力让自己变得更优秀了。</p>\n","categories":["日记"],"tags":[]},{"title":"iOS开发之storyboard中三种常用的页面跳转方式","url":"http://icebergcwp.com/iOS开发之三种常用的页面跳转方式.html","content":"<p>页面跳转属于iOS开发中很常用的一个功能，然而即便是这个看似简单的功能也可以根据不同需求有三个实现方式。下面一一介绍。</p>\n<h4 id=\"方式一：建立Button与目标VC之间Segue\"><a href=\"#方式一：建立Button与目标VC之间Segue\" class=\"headerlink\" title=\"方式一：建立Button与目标VC之间Segue\"></a>方式一：建立Button与目标VC之间Segue</h4><p>这种方式可直接在storyboard上完成，右击源VC上的一个按钮会出现一个接菜单，选择菜单中的“Triggred Segues”下的“action”，然后与目标VC建立一条指定跳转类型（比如Present Modally）的segue。</p>\n<p>特点：操作简单，在storyboard上即可完成，不需要额外的手写代码。</p>\n<h4 id=\"方式二：建立源VC与目标VC之间Segue\"><a href=\"#方式二：建立源VC与目标VC之间Segue\" class=\"headerlink\" title=\"方式二：建立源VC与目标VC之间Segue\"></a>方式二：建立源VC与目标VC之间Segue</h4><p>这种方式是在两个VC之间建立一条segue，然后在代码中根据Identify来获取对应的segue对象，调用performSegue函数来触发跳转。</p>\n<p>特点：可以将跳转操作的触发与任意的控件绑定，需要添加额外的手写代码来完成绑定功能。</p>\n<h4 id=\"方式一：基于既有的Segue重复显示同一个目标VC\"><a href=\"#方式一：基于既有的Segue重复显示同一个目标VC\" class=\"headerlink\" title=\"方式一：基于既有的Segue重复显示同一个目标VC\"></a>方式一：基于既有的Segue重复显示同一个目标VC</h4><p>这种方式其实是建立在第二种方式之上的，不同的地方在于这种方式会retain目标VC，这样确保在除第一次跳转之后不会再创建新的VC。因为前面两中方式都会在每次跳转时创建一个新的VC。</p>\n<p>特点：可以重复使用和显示目标VC的数据。</p>\n<p><a href=\"https://github.com/icebergcwp1990/PageJumpDemo\" target=\"_blank\" rel=\"noopener\">GitHub Demo</a></p>\n","categories":["专业","iOS"],"tags":["iOS"]},{"title":"iOS开发之framework多框架编译","url":"http://icebergcwp.com/iOS开发之framework多框架编译.html","content":"<p>iOS开发之framework多架构编译</p>\n<p><a href=\"https://www.cnblogs.com/lurenq/p/7068468.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lurenq/p/7068468.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/5b91223a1bf5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5b91223a1bf5</a></p>\n<p>//支持模拟器的库必须同时之i386与x86_64，即便是模拟器运行在x86_64的Mac电脑上<br><a href=\"https://stackoverflow.com/questions/28033635/why-does-the-ios-simulator-require-i386-and-x86-64-symbols-even-though-im-on-an\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/28033635/why-does-the-ios-simulator-require-i386-and-x86-64-symbols-even-though-im-on-an</a></p>\n","categories":["专业","iOS"],"tags":["iOS","BitCode"]},{"title":"Daily-煎熬的过度期","url":"http://icebergcwp.com/Daily-2018-07-11.html","content":"<p>本以为昨晚提前睡觉，今天早上能够早起。然而事与愿违，早上非但没有早起，反而比以往起床的时间推迟了半个小时。不过起床后精神状态不错，脑袋没有昏昏沉沉的感觉，整天的工作效率很高。</p>\n<p>换个角度思考，如果只需要保证白天正常上班的八个小时，现阶段的作息时间完全满足要求。但是如果要确保业余时间也能有一个较高的效率和较好的状态，即使延长作息时间也可能于事无补，因为这取决于心理层次的因素：毅力和自控力。</p>\n<p>我能感觉到自己有一种逃避的心理。即使我不愿意承认，但是确实是存在的。我记得大三做磁盘分析的那段时间，整个人全身心的投入到项目当中，即便是做梦都会想到项目相关的问题。那段时间每天实际睡觉时间不超过五个小时，但是每天早上起来都是一副精神饱满的样子。这是一段难以忘记的经历，也让我明白自己是可以做的足够好的。</p>\n<p>现在之所以效率不够且主观能动性低，我想与事情本身的性质也有一定关联。比如说学英语，真的是一件枯燥的事情，而且短时间内几乎看不到任何进步。这与人的本能是相违背的，这也是为什么会感觉到煎熬的原因。</p>\n<p>自从大学毕业之后，期间几次尝试自学英语都半途而废了。这一次我一定要坚持下去，宁可进展很缓慢也没关系。另外，结合过去的失败经历，多吸取他人学习英语的经验，不断地优化学习计划，总结一套适合自己的学习方法。</p>\n<p>对比考驾照和练习尤克里里的经验，我自知在英语学习上投入的积极性还不够，还是处于一种被动学习的状态。特别是在过渡期间，只有投入更多的激情和精力才能保持学习的积极性！切记！切记！</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于时间和精力","url":"http://icebergcwp.com/Daily-2018-07-10.html","content":"<p>近段时间总感觉有点疲惫和犯困，每天回到家有点无精打采。虽说人的精力是一个定值，但是根据以往的经验不至于现在这样。经过一番自我总结，我觉得可能是以下两个原因：</p>\n<p>一是，最近业余时间安排的事情有点多，而且大多都是一些需要坚持和消耗毅力的事情。这是以往没有的挑战，大脑目前应该是处于一个适应期或者是逃避期，毕竟人的本性就是趋利避害。根据健身的经验，其实大脑和身体类似，很难达到真正疲劳的状态，很多时候就是人的懒惰天性或者舒适区在阻碍自我前进。这个时候是一个煎熬期，需要不断提醒自己当初的初衷和目标，并且不断完善计划，让学习过程变得更为科学和可行。</p>\n<p>二是，近半年以来在不知不觉中作息时间发生了变化。现在每晚上床睡觉时间已经从以前的12点左右变成了凌晨一点左右。这严重影响了睡眠质量，导致第二天很难早起以及精力不够旺盛。记得刚毕业有一半年时间，我严格地执行每天晚上10点半上床，然后看半个小时书，十一点左右准时睡觉。第二天五点起床准备早餐和午饭，然后六点出门坐一个多小时的公交车到公司，有时候是骑一个小时自行车。即便如此，那时候总是一副打鸡血的状态，有着用不完的精力。而且，五六点的早上很安静，有一种整个世界都是自己的感觉。</p>\n<p>结合以上的分析，针对第一点，优化学习计划是一个循序渐进的过程，所以只能慢慢改善。至于第二点，今天晚上先把睡觉时间提前到12点。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-糟糕的一天","url":"http://icebergcwp.com/Daily-2018-07-09.html","content":"<p>这篇日记也许在早上五点写更为合适，毕竟那个时候我刚从派出所回来，疲惫不堪。实话说，这是我生平第一次进派出所的审讯室，而且是以监护人的身份作为旁听。</p>\n<p>在得知我的堂侄子因为入室行窃被拘捕之后，因为未满18周岁，根据法律规定在录口供的过程中需要有监护人在场。而我作为他在长沙唯一的近亲，自然是“义不容辞”的履行这一份义务了。</p>\n<p>录口供的过程是煎熬的，尽管我只是旁听，但是里面的氛围严肃且压抑，录口供一共花了近五个小时（从凌晨12点一直到凌晨5点）。让我感到和吃惊的是派出所的民警很尽职与文明执法。这与我之前通过外界信息对公安人员所形成的印象完全不一样。客观地说，这是一件比较普通的案件，但是因为构成了刑事犯罪，所以他们的态度确实很严谨，对每一个细节都很耐心核对，直到当所有嫌疑人的口供没有出入时才算满意。</p>\n<p>起初，我本以为我过去只是走一个过场，并且期望这个案件可以通过私下和解撤销立案。但是事情远不是我想象的那样。办案民警的敬业态度超出了我的认知，从他们的微胖的体态和略带疲惫的神情可以推测他们应该是经常熬夜办案，饮食和作息都很不健康。可悲的是，很多人可能和我一样对他们已有了成见，我如果不是亲眼所见也很难改变我以往对他们的固有认知。</p>\n<p>现在，这个案子的法律文书已经递交给检察院那边，并且由检察院对嫌疑人提起公诉。接下来法院会怎么判决尚不得知。</p>\n<p>我感觉我这个堂侄子已经不再是我以前认识的那个人，从他的眼神里似乎已经看不到亲情和感恩。这一点让我感到有点心寒。希望这次事件能够给他的内心带来一些触动，并且以后能够改过自新，把握住自己的大好年华。</p>\n<p>最后，我还想多说一句。其实我堂侄子走到今天这个地步，与我堂哥堂嫂错误的家庭教育方法也有很大关系。他们在孩子最需要陪伴的时候没有在身边，而是送自己的儿子一个人到一个陌生的城市，接受他们心里认为的更好的教育，结果却是适得其反。在孩子成长的任何时候，家人的陪伴和正确的家庭教育都是最重要的。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-非充实的一天","url":"http://icebergcwp.com/Daily-2018-07-08.html","content":"<p><strong>非充实的一天</strong></p>\n<p>今天是周末，难得的休息日。每当到周末，我的懒癌就容易发作，看似平静的外表下，内心在消遣娱乐和看书学习这个选择中挣扎。姑且称呼二者分别为甲方和乙方吧。</p>\n<p>甲方观点是辛苦的工作了一个星期，并且工作日的每个早上和晚上都会看书学习。俗话说劳逸需结合嘛，周末既然的休息日，就应该好好休息，不要去考虑学习的事情。</p>\n<p>乙方观点是现在需要的做的事情很多：专业学习、英语学习以及阅读计划。周末虽然是休息日，但也是难得的一整块时间，不同于平时的碎片时间，有些学习是需要整块时间的。更何况，过去的校园时光以及毕业的前几年浪费了那么多宝贵的时间，像英语的基础学习和很多书本的阅读应该在那些时间就应该完成的事情。现在更应该抓紧时间，提升自己，毕竟自己距离自己的目标还有很长的一短距离。</p>\n<p>在这两中观点的纠结下，我选择了折中，或者偏向于甲方。早上睡到自然醒以及下午两个小时的午觉让我很满足。其他时间选择性地用于写代码和记单词。</p>\n<p>除了以上的主观原因，还有一点客观存在的原因。通过这些的学习经验，我明白学习过程的有高低起伏的，很难一直保持高效的状态。此外，专业学习和英语学习目前都处于初步阶段，没有形成自己的一套方法论和成熟的流程。换句话说就是还没真正进入状态。我相信自己一旦完善学习计划，摸索出一种适合自己的方法，我会沉迷于其中。届时，一切都会水到渠成，而不需要刻意的监督和思想挣扎。</p>\n<p><strong>我的一个小想法</strong></p>\n<p>吃晚饭的时候看了几集纪录片《舌尖上的中国》，心里有些莫名的触动。中国是世界上家庭观念最强的国家，各地的百姓与出生的土地有着浓厚的感情，老一辈的人甚至一辈子都生活其中，朝夕相处。美食，不仅体现了人们的生活智慧，更是象征着人们对脚下这片土地的热爱。</p>\n<p>我希望以后在条件允许的前提下，能够沿着《舌尖上的中国》的美食之路遍访中国各地，品尝当地的传统特色美食。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-越成熟的人，越少晒生活","url":"http://icebergcwp.com/Daily-2018-07-07.html","content":"<p><strong>心智越成熟的人，越懂得体谅别人的不易</strong></p>\n<p>村上春树曾经在《没有女人的男人》一书中写道：所谓的绅士，就是从不谈起交纳多少税金和睡过多少女性。</p>\n<p>一个真正心智成熟的人，不会刻意炫耀自己拥有的成就、头衔、家产，因为他们深知这个世界还有不如他们的人。也正是这份体谅与理解，才使得他们很少将自己的生活晒出来。<br>心智越成熟的人，越懂得体谅别人的不易，这份体谅之中也包含着一个人的气度和涵养。</p>\n<p>对比之下，我的心智远谈不上成熟。我也很少发朋友圈，原因更多是觉得很多事情都没有晒的必要性。其实，我内心深处还是有着强烈的“炫耀”欲望，只是目前生活不能满足罢了。我想即便以后有了炫耀的资本也应该低调一些，这种急切想要表达的心理恰恰透露着自己内心的自卑与渺小。</p>\n<p><strong>见过世面，才会明白眼前的可贵</strong></p>\n<p>正所谓，夏虫不可语冰，井蛙不可语海，凡夫不可语道。若一个人没有真正的看过世界，很容易囿于自己所认知的天地，常常误以为自己已经足够的优秀，从而忘记了世界之大。</p>\n<p>最近因为学习英语的原因常常浏览youtube网站，在上面看到很多优秀的年轻人为自己的梦想拼搏着，并且乐于与他人分享自己的经历。其中很多在国外工作的中国年轻人都有着刻骨铭心的奋斗史，尽管他们的起点可能比国内大多数人都高，但是他们仍然很努力地追求着自己的目标。</p>\n<p>越是真正见过世面的人，越会明白什么才是自己的上限，什么又是自己的底限。知识和认知是有边际递减效应的，随着你知道越多，就会越发现自己不知道的更多。</p>\n<p><strong>真正值得关注的风景，是自己</strong></p>\n<p>与其期待别人的肯定，我更喜欢自己内心世界的笃定。这个世界是怎么样的存在最终取决于我们这么看待这个世界。</p>\n<p>当你对世界真相了解的越多，看到的世界就是越完整的。我常常在想人的生命其实不超过900个月，除去心智和思想不健全和独立的青春期和七十岁之后的大脑衰退期之外，真正可以按照自己意志来度过的时间不过600个月而已。</p>\n<p>人获得是否有意义，不在于他认识多少人，去过多少地方，看过多少书，这些都是手段而已。真正的取决是否能认清自己，是否能建立健全成熟的心智。</p>\n<p>人生的这趟旅程，真正值得关注的风景是自己。一个爱自己的人，才能更好的爱身边的人。</p>\n<p><strong>一件小事</strong></p>\n<p>今天是大侄女萱萱的生日，婷婷作为婶婶给她买了一个小礼物，并且在知道家里没有准备生日蛋糕的情况下特地在晚饭后带她去吃了小蛋糕。虽然这是一件小事，但是我挺感动的。婷婷就是这样一个善良和有爱心的女孩子，这也是为什么家里的小屁孩都喜欢跟她玩。我也为自己娶到这样的媳妇感动欣慰和自豪。希望即将出生的蜜柚也能像她妈妈那样善良美丽。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-静下来","url":"http://icebergcwp.com/Daily-2018-07-06.html","content":"<p>最近在喜马拉雅电台听“民国人物列传”，发现了这些民国大师都有一个共同的特点，就是能够静下心来专注的做一件事情。而且，最终的结果往往是事半功倍。正因为如此，在他们的一生才能铸就那么多杰出的作品。</p>\n<p>我觉得人最可悲的一种状态不是贫穷，而是无知。物质上的东西都是可以被剥夺的，只有大脑里的思想和知识是自己的。这些民国的大师有着自己独立的人格和深厚的知识底蕴，这也是为什么世人敬仰他们的原因。</p>\n<p>反观我自己，内心容易浮躁，很难静下心来专注的做一件事情。脑海里的杂念太多，这与外界的诱惑有一定关系，更主要的还是自己内心的不够坚定。比如记单词，每天一百个单词的量没办法保质保量的完成。其实我有很多碎片时间，我打大脑也在为此挣扎用来休息还是背单词，最终我还是选择了更舒适的消遣方式。</p>\n<p>我很清楚，但凡有点成就的人都是耐得住寂寞，静得下心得人。这样的例子比比皆是。比如网易的创始人丁磊，喜欢享受一个人的时光，懂得与自己独处，耐得住寂寞。现在的我欲望太强，想要的东西太多，急于求成的心理主导了我的思考和做事的方式。我明白自己内心的渴望，因正是这股强烈的渴望让我变得浮躁。我想这也是大多数人的通病吧。</p>\n<p>记得我大学一个很尊重的老师说过的一句话：“把事情做好，该有的都会有”。他自己就是这样的一个人，不以追求功名为目的，而是踏踏实实做好自己的事情。这样的人由内而外都散发着一种自信与正气。</p>\n<p>写这篇日记的目的就是在于自我反省。告诉自己静下来，专注地把事情做好，慢一点也没有关系。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-一些趣闻","url":"http://icebergcwp.com/Daily-2018-07-05.html","content":"<p><strong>夫妻肺片的由来</strong></p>\n<p>“夫妻肺片”这道菜其实最开始的名称是“夫妻废片”。在20世纪30年代，四川成都很多底层的穷苦人吃不起荤菜，肚子缺油水。特别是做苦力的人吃不着油水也就使不上劲。有一对摆小摊的夫妇，他们看到一些废弃的内脏都被扔掉，觉得很可惜，小两口反正也还没有事做，正耽于生计，于是就清晨就到屠场，在堆积的内脏堆中翻翻捡捡，挑选自己觉得还有吃相的打理干净上锅煮熟，反复试验，终于做到了牛肚白嫩如纸，牛舌淡红如桦，牛头皮透明微黄，此后再配以夫妻精心搭配的红油、花椒、芝麻、香油、味精、上等的酱油和鲜嫩的芹菜等各色调料，而炮制出这后世传诵的美食来。而后随着食客的日益增多，名声越传越远，就有人嫌其“废片”二字不好听，于是主张将“废”字易为“肺”字，这一改动就造成了成都这个著名菜品名字的由来。</p>\n<p><strong>解手的来历</strong></p>\n<p>明代洪武年间，因为之前的战乱，中原十室九空，为填补中原地区的人力，明朝数次从陕西山西等处强制移民到中原地区。由于中国人乡土观念很重，不愿意背井离乡。因此押送移民的官员为防止移民逃跑，便用长绳将移民的手都捆了起来，在一路上要是有人想去上厕所，就必须央求押解的人将捆住的手解开。时间一久，解手这个词便演化会上厕所的意思了。</p>\n<p><strong>总结</strong></p>\n<p>中国的语言因为有着悠久的历史文化作为沉淀，很多词语都有着与字面意思不同的含义。换句话说，世界上其他语言也有类似的情况。因此，如果想要真正学好一门语言，一定不能脱离这门语言的文化历史背景。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-普通人也应该懂点音乐","url":"http://icebergcwp.com/Daily-2018-07-04.html","content":"<p>昨天去上尤克里里培训课时恰巧碰到一位即将退休的大叔在咨询吉他相关的事情。后面问老师才知道原来这位大哥想丰富退休生活准备学吉他。于是，我打趣道：“我现在学尤克里里也算是为以后的老年生活做准备了”。</p>\n<p>其实，我学尤克里里还有另外两个主要原因。</p>\n<p>一是，我打心底认同音乐是一门跨种族跨国界跨时代的语言，亦是生活的精华所在。正所谓“乐之入人也深，其化人也速。 移风易俗、莫善于乐。 大声不入里耳、 曲高和寡。 兴于诗、立于礼、成于乐。 德者，性之端也;乐者，德之乐也。 凡音之起，由人心生也，人心之动，物使之然也”。如果不懂一点音乐或者不会一门乐器真的是人生一大憾事。</p>\n<p>二是，我想通过自己学习尤克里里和陶笛这样简单的乐器，为即将出生的宝贝营造一个音乐的环境。让她从小能够了解和接触一些简单乐器，慢慢地感受音乐带来的美好。我觉得越早接触像音乐这样美好事物越有助于塑造一个正确的人生观和审美观。</p>\n<p>然而，学习乐器是一件比较枯燥且属于长周期低回报的事情。就目前的学习情况来说不算好也不算太差，每天都有一点点进步。有时候会如痴如醉练一个多小时，有时候则毫无耐心地敷衍几下，总体来说还是朝着一个好的方向发展，我想等我能够熟练地弹奏尤克里里时，我的耐心也会有一定的进步吧。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-说话有分寸是成熟的标志之一","url":"http://icebergcwp.com/Daily-2018-07-03.html","content":"<p>今天发生一件小事让我意识到自己有时候说话没有分寸，不够考虑对方的感受。</p>\n<p>对方是我一个很铁的哥们，在高中群里发了一张与女友在家里烛光晚餐的照片。我这哥们的本意是“炫耀”自己的浪漫。其实我也知道他的用意，但是我却故意“调侃”他是乡村版烛光晚餐。等说完之后，我才意识到自己可能说错话了。</p>\n<p>这种例子时有发生，特别是在对待关系比较亲近的朋友时，有时候我变得口无遮拦。今天的这件事让我意识到，自己不都成熟。其实，越是亲近的朋友越应该尊重对方，把握分寸。</p>\n<p>记得梁宏达曾在节目里面夸葛优人好，所以人都愿意和他做朋友。原因在于葛优懂得照顾对方的感受，给对方足够的尊重，并且不会乱说话。</p>\n<p>我的缺点之一就是有时候开玩笑不懂得把握分寸，其实我在话说出去之前我意识到可能造成不好的影响，但是为了达到自己预期的效果我还是选择继续说下去。这是一种不成熟的表现，以后我会在所谓的幽默感和成熟之间选择成熟一点。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-应该倍加珍惜已拥有的","url":"http://icebergcwp.com/Daily-2018-07-02.html","content":"<p>人呐，最容易犯的毛病之一就是不懂得珍惜自己拥有的事物。有时候我会因为忙于自己的事情而忽略了自己最爱的人的感受，忽略了仪式感的重要性。我想一个合格的丈夫是不应该犯这样低级的错误的，我该好好反省。</p>\n<p>首先，我承认自己做得不够好，有时候缺乏耐心。为此，我思考了整整一天，关于我为什么最近会表现出一种焦躁的情绪的原因。</p>\n<p>简单地说，可以总结为是一种对未来的焦虑症。如果和周边的同龄朋友相比较，我目前的现状还算是过得去，有较为可观的收入，有一定的生活品质，有时间做一些自己喜欢的事情。然而，这与我个人期望的高度还相去甚远。</p>\n<p>王小波说：人的一切痛苦，本质上都是对自己无能的愤怒。这句话或多或少能够表达我现在的内心状态。我之所以感觉到焦虑与些许恐慌的原因主要有两个：一是我想给自己的妻子和孩子一个更好更富裕的生活，让她们在未来的日子里过得安心和幸福；二是我需要给自己一个交代，目前的职业状态我不是很满意，不论从平台的高度、工作的稳定性以及对个人成长的帮助都不是很满意。</p>\n<p>其实，这种类似的情绪以前也是存在的。或者说这种情绪的间歇性出现的，每次出现时我都会变得有些焦虑。我想在我个人成长取得质的突破之前这种情绪还是会一直存在的吧。缓解这种情绪的最佳方式就是让自己朝着目标前进，慢慢地靠近它。</p>\n<p>当然，以上不是我做错事的借口，没能控制好自己的情绪本身就是一种错误。写这篇日志的原因就是为了自我反省，避免下次又在不经意间犯同样的错误。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-朋友圈与圈子","url":"http://icebergcwp.com/Daily-2018-07-01.html","content":"<p>我的朋友圈目前来说以高中同学为主，其次是大学毕业之后认识的几个好哥们。由于平时的生活大多数时间都是局限于这些朋友，特别是高中的朋友，有一种时间停滞的感觉。</p>\n<p>毋庸置疑，孩童和校园时期的友谊是最弥足珍贵的，那时候的彼此没有利益的目的，纯粹是因为大家有共同的爱好和话题。这是一种大家坐在一起即便不说话也不会觉得尴尬的友谊，我很珍惜这些友谊，在利益场的衬托下显得更加可贵。</p>\n<p>然而，我也发现自己目前的朋友圈也存在着弊端：缺少一种积极向上的氛围，感觉多数人更多是在追求安逸或抱怨工作或讨论以及贷款买房等暂且称之为“接地气”的事情。我并不认为讨论这些与社会个体息息相关的事情有什么错，我只是反对大家聊天的话题只局限于这些内容，而没有更长远更高的期许。</p>\n<p>我更愿意看到大家都在努力地突破自己的局限性，分享一些正能量和彼此鼓励。客观的说，我对于目前的朋友圈多少有一点失望，对我自己也很失望。我的这些朋友中不乏一些潜力和资质都很优秀的优等生，但是他们似乎都没有实现阶级晋升的冲动和愿望。我也很少在群里讨论看书学习等“高大上”的话题，因为这很容易会被看做是一种炫耀，更何况大家似乎都在逃避这些话题。</p>\n<p>我的智力和学习能力很一般，但是我渴望突破自我。就目前来说，很遗憾，这个“纯粹的”朋友圈不是我期望中的那个圈子。与此同时，我也明白，关于圈子，有一个赤裸裸的现实：不会是你进入圈子，只能是圈子进入你。社会是一个圆锥，每个人都在往圆锥的高处爬。你和同等水平但不同领域的人的距离就是你所处平面圆的直径。换句话说，随着所处的水平越高，你接触别的领域的人的距离就会更近。你只能先变得优秀，才能接触到与你同样的优秀的那些人和圈子。</p>\n<p>既然“与生俱来的”的朋友圈不能满足自己现有的需求，那只能是自己不断提升自己，让期望中的圈子接纳自己。</p>\n<p>这个世界远比我想象的精彩与广阔，给自己一个可期的未来。不过实现突破的第一步就是克服英语的语言障碍，它可是我走向更广阔舞台的通行证。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-经济与理财","url":"http://icebergcwp.com/Daily-2018-06-30.html","content":"<p>从小到大由于家庭背景和成长环境的原因，我对于经济和理财方面几乎一无所知，甚至有意识的排斥它们并将它们隔离于自己的生活。一直以来，我认为作为一个非专业的人不需要懂得经济，作为一个没有多少积蓄的普通百姓以不需要知道如何理财。</p>\n<p>现在才知道，自己是本末倒置了。经济是社会的命脉所在，影响这社会的稳定与繁荣。作为一个生活其中的社会成员，如果对于其经济现状与发展没有一定的认识，很难在经济的浪潮中保值个人资产，从而使自己陷入更为被动的局面。</p>\n<p>中国尽管现在打着发展市场经济的口号，实质上还是有着比较浓重的计划经济色彩。这与中国的特殊国情有关系，国家不可能完全放任经济由市场自由发展。</p>\n<p>钱作为货币，只有流动起来才能体现其作为货币的属性。这一点与我的以往的金钱观相违背。我和大多数中国百姓意义倾向于将钱存银行，以备不时之需，而不愿意用来再投资。这种观念对我影响很大，在没有真正了解经济本质之前很难改正过来。</p>\n<p>此外，理财这个名词在我大学毕业之前都是陌生的。一来是因为压根没有积蓄可以用来理财，二者是完全没有理财的意识。现在我知道理财对于一个普通人同样很重要性。然而，很多人的理财方式都是盲目跟风，属于最初级阶段的理财。我认为正确的理财方式是建立在对经济有一定认识的基础之上的，对于理财产品的机制与原理有一定认识，这样才能在风险来临之前作出正确的选择。</p>\n<p>做一件事情最好的时间就是现在，一切都来得及。从内心明白了学习经济和理解的重要性本身就是一个好的开始。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-睡眠、兴趣","url":"http://icebergcwp.com/Daily-2018-06-29.html","content":"<p><strong>睡眠</strong></p>\n<p>记得小时候，老妈经常会在做完饭之后往煤炉上放一大锅水，利用煤炭的余热把水烧热。等吃完饭，热水也好了。一家人各自搬一个凳子，坐在客厅的大脚盆的四周，围成一个圈。因为老妈有时候会往锅里放一些艾草，所以水会是草绿色的，沿着上升水气散发出一股淡淡的艾草香。我们先后把各自的大脚丫伸进脚盆，频繁表演着蜻蜓点水试探水的温度，等水温到达一个适宜的问题时，再把脚整个钻进水里，顿时感觉一股热流贯穿全身，整个人也随之慢慢地放松下来，静静地享受泡脚的舒适感和家人陪伴的幸福感。</p>\n<p>现在想来自己从小到大的睡眠质量之所以一直都很好，想必和小时候养成的睡前泡脚的习惯有一定的关系。睡眠好的表现之一就是不睡懒觉和不赖床，记得小时候的我是全家起床最早的一个，每次都是一个人孤零零地出去溜达一圈，回到家发现其他人都还没有起床。</p>\n<p>直到现在，我都很少有失眠的情况。关于这一点，我心怀感激。睡眠质量真的太重要，人的差不多一生有三分之一的时间是处于睡眠状态。睡眠质量的好坏直接影响你的判断力、思考方式和情绪的稳定性。小时候没有感觉到睡眠的重要性，随着年纪的增长这种感觉也越发明显。</p>\n<p>一直以来我都一度认为睡眠好是天经地义的事情，后来才明白这是一种珍贵的恩赐，现实生活中很多人都饱受失眠的折磨。意识到这一点也让我渐渐地摒弃了以往睡前玩手机的坏习惯，更加地珍惜睡眠。</p>\n<p><strong>兴趣</strong></p>\n<p>兴趣是最好的老师，如果能以兴趣为原始驱动力做一件事情本身就是一件幸福的事情。</p>\n<p>坦诚地说，自己目前做事的功利性占主导地位。比如学尤克里里、学英语、看书等。这些目前在做的事情都算不上因为兴趣才接触的，而是出于某种目的。</p>\n<p>学尤克里里是觉得人活一世，多少要懂得一点乐理知识，懂得弹奏一门乐器，才不枉此生。此外也给家庭带来一点音乐的元素，对孩子的教育提供一些帮助。</p>\n<p>学英语一是出于专业的需要，对英语阅读能力有一定的要求。其次，英语作为全球通用的语言，理论上是每一个渴望接触更大的世界的人都应该掌握的语言。惭愧地是目前我还没有形成一套属于自己的英语学习方法。庆幸地一点是我隐约地感觉自己慢慢从内心开始喜欢上英语，有想去了解它的发展历史的念头。</p>\n<p>看书的最初原因是想通过看书这一捷径快速的积累自己的知识储备，从而达到突破自己局限性的目的。实话说，最开始我是排斥看书的，毕竟十多年的应试教育让我对书本产生了一定的厌恶感，更别提阅读的兴趣。直到大学毕业那一年，意识到了自己的局限性是多么的大，也明白看书是一种性价比最高的自我提升方式。经过这些年的坚持，现在慢慢地有了一点读书写字的兴趣，慢慢地体会到读书带给我的乐趣。</p>\n<p>也许成人培养兴趣的方式就是这样的吧，先是带有目的性的接触，在功利的驱使下慢慢地转变成兴趣。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-科目二考试总结","url":"http://icebergcwp.com/Daily-2018-06-28.html","content":"<p>今天是一个值得记录的日子，上午顺利的通过了驾照科目二的考试。</p>\n<p>科目二对许多人来说都是属于考驾照过程中最难的一关，对于我也不例外。等待考试之前内心也是忐忑不安，甚至在考试的时候出现腿发抖的情况。好在基本功扎实，稳住了离合器，最后才能顺利的完成考试，总算是有惊无险。</p>\n<p>科目二一共练了七次车，每次一个小时。我觉得自己之所以能在短时间内掌握每一个考试项目的技巧，跟自己的主观能动性有很大关系。</p>\n<p>每一次练完车后，我都会在脑海了过一遍这次练车的过程，然后总结自己这次练车不足之处，对有疑问的地方通过上网查阅资料和看视频教程，寻找出解决方法，等到下一次练车再加以实践。通过这种不断总结与实践的方式，形成一个正反馈良性循环，让我慢慢地对于每一个项目的操作方式与原理有了更深的理解，从而更快的掌握其中技术。</p>\n<p>尽管科目二相较于生活来说只是一件小事，但是体现的是对待一件事情的态度。通过练习科目二的过程，让我更加坚信自己的这一套学习机制的正确的，也相信付出一定是有收获的，机会一定是会眷顾有准备的人。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-人性的善与恶","url":"http://icebergcwp.com/Daily-2018-06-27.html","content":"<p>这几天网上热议的一个话题再次让我们感叹人性的善与恶和群众效应的威力。一位高三女孩由于班主任猥亵精神受到极大的刺激，从而患上了抑郁症，最终产生轻生的念头，选择了跳楼来结束自己花样年华的生命。这位猥琐的班主任最终逃过了法律的制裁，但是我相信社会的舆论和人类区别于禽兽的良知会让他的后半生不得安宁。</p>\n<p>其实让我感到更加心寒的是女孩跳楼的时围观起哄的群众的冷血无情，他们站在地面上看着热闹，没有去热心地劝说开导，而是嘲讽女孩是在作秀，压根没有勇气跳下来，甚至有人在催促女孩赶紧跳下来。我不禁怀疑这是我正生活于其中的社会吗？我知道人性的丑陋，但是不知道人性可以这般的丑陋与无情。</p>\n<p>看客的冷漠与变态，自然让人绝望。但每个个体都是社会环境的产物，他们为什么会变得如此的丑陋无情，很有必要细细琢磨。</p>\n<p>我觉得那些围观起哄的群众看客大致有以下的心理：他们大多都是处于生活的中下层，生活平淡或不如意，且长期处于一种焦虑的状态，对于未来缺乏安全感。所以，当看到他人承受不了生活的压力痛不欲生或者选择轻生时，他们会获得一种满足感甚至是自豪感，让他们暂时忘记了远期的焦虑。他们为自己能够活着感到庆幸与满足，这种虚荣感侵蚀了良知，泯灭了他们的同理心。</p>\n<p>这种心理的根源有一个专有名词叫做“公正世界信念”：个体有这样的需要，相信他们生活在一个公正的世界里。在这样一个世界里，人们得其所应得。这种世界是公正的信念，可使得个体相信他们所处的物理和社会环境是稳定有序的，从而有利于个体适应这些环境。如果这种信念缺失，个体就很难使自己致力于长远目标的追求，难以遵循社会规范行事。因此，当一个选择轻生时，人们不会去关心背后的真相，而是倾向于认为是轻生者自身的原因导致其不能适应社会，而与社会没有任何瓜葛。</p>\n<p>此外，群众效应也是原因之一。如果围观的只有一两个人那很可能不会出现起哄的想象。但是一旦人进去一个群体，人的自身道德标准就会被群体的特征取代。一旦群体中有一个人开始起哄，那么其他人也会不自觉地加入其中，群体中的个体或多或少都会抱有法不责众的心理。如果人一旦不需要为自己的行为付出代价时，他们就会将自己本性展露无疑。</p>\n<p>最后，我想很多人都忽视了与起哄群众对立的另外一个群体：救人的消防队员。当女孩从消防队员手中挣脱时，女孩说了一声谢谢。而消防员看着一个年轻的生命从自己手中消失，哭喊得撕心裂肺。我想这样的经历对消防员战士来说也会产生一定的心理阴影吧，但是又有多少人在乎呢？</p>\n<p>生活还是鲁迅先生一百年前的那个吃人社会。社会如此，人性亦如此。我们以为社会在进步，其实并没有。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-关于真相","url":"http://icebergcwp.com/Daily-2018-06-26.html","content":"<p>都说现在的人越来越浮躁，愿意思考的人越来越少，导致整个社会都显得浮躁不安。我觉得其实我们一直以来都是这样的，与这个时代的关系不大。之所以当代人会这么认为，是因为大多数人相较于不熟悉的历史更了解自己当下生活的年代。一旦自己所处的社会没有达到自己的预期，往往更愿意相信以前的年代比现在更好，人也更单纯。现在网络上很多人都在追捧民国时代，认为那个年代更加自由与开明。这是因为他们看到的都是民国精英贵族的事迹，认为自己如果生活在那个年代会同样的潇洒与自由，但是如果你深入了解了民国普通老百姓的生活你就不会这么认为了，毕竟你我都是属于普通阶层。</p>\n<p>我觉得造成这种现象的原因至少包含了两个原因：一是大多数人缺乏辩证思想，往往会选择自己那些与自己意愿相符的事物来构成对某一件事情的认知，从而容易忽略其他的客观事实；其次是信息的不对称，如果对一件事情没有足够的深入了解是不可能接近真相的，我一直相信真相永远是掌握在少数人手里。</p>\n<p>记得心理学上有一个著名的“棉花糖实验”：研究者给幼儿园小朋友一颗棉花糖，并且说你可以现在就吃掉它，但如果你等上15分钟都不吃，就会得到第二颗棉花糖。根据后续跟踪，得到第二颗棉花糖的孩子在未来更加成功。这项研究发表在1990年，当时学者认为，忍耐不吃糖的小孩具备更强的意志力，能为了长远利益放弃暂时的欢愉，这种“延迟满足能力”正是他们成为人生赢家的原因。然而，研究者忽略了一个很重要的因素：小孩子的家庭背景。事情的真相是那些推迟吃掉棉花糖的小孩子几乎都是来自富裕家庭，棉花糖对于他们来说压根没有什么的诱惑力，日常生活中随时可以获得。而那些没有经受住诱惑的小孩子基本上是来自于经济条件较差的家庭，棉花糖对于他们来说是稀缺资源，因此也就很具有诱惑力。</p>\n<p>即便网络再发达，信息不对称还是会一直存在的。网络的出现只是帮助我们减缓信息不对称带来认知偏差。更何况人的言论都是带有倾向性的，说话的人的目的就是让听者认同自己的观点。因此，面对网络上海量的信息时，一定要学会思考，并尽量用辩证的态度去质疑和思考问题。</p>\n<p>最后想起一句话，历史是任人打扮的姑娘。因此，有些历史的真相也许是我们永远都不会知道的。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-贫穷的根源和匠人精神","url":"http://icebergcwp.com/Daily-2018-06-25.html","content":"<p><strong>贫穷的根源</strong></p>\n<p>贫穷的根源是什么？一部分人将原因归结于穷人自身，典型的代表人物包括英国历史上第一位女首相撒切尔夫人，她曾经说过：贫穷是一种性格缺陷（Poverty is a personality defect）。此外，另外一部分人认为贫穷的根源在于缺乏教育。之所以有上述两种较为普遍的观点，是因为穷人往往更容易做出糟糕的决定，从而进入恶性循环。</p>\n<p>然而最新的研究结果表明贫穷的根源是穷人长期被一种稀缺性心态（scarcity mentality）困扰。穷人由于生活基本需求得不到保障，大部分时间在为生计奔波，根本没有多余精力去学习和思考如何改善贫穷的处境。</p>\n<p>其实早在五百年前，哲学家托马斯·莫尔其实已经指出了解决贫穷的根本在于：给予穷人基本的生活保障。</p>\n<p>一旦穷人的基本生活的到保障，当他们不再为日常生活发愁时做出的选择和决定也可以和其他人一样的理智和正确。</p>\n<p>一直以来，社会解决贫穷的办法都是给穷人提供大量的生活物资。其实更好的方式是给穷人现金，让他们去购买自己真正需要的东西，从而有了支配生活的基本能力。</p>\n<p><strong>匠人精神</strong></p>\n<p>中午在TED上看到一个话题：破解学习外语的奥秘。主讲人是一个以英语为母语的普通人：资质一般，曾多次尝试学习外语都以失败告终。直到他遇到一些会讲多国语言的人，明白了自己以往学习外语的初衷是错误的。学习外语最好的出发点是从内心里喜欢这门语言，体会语言的乐趣，而不是由应试或者出国等表面的原因驱使。此外，另外一个关键是要把自己置身于一个外语的环境中。主讲人自己每次学习一门新的外语就会到对应的母语国家和当地人交流沟通，即使表达错误也没关系，只要对方能听懂就行。</p>\n<p>另外，下午在练车回公司的路上看到一篇关于豆瓣创始人阿北创办豆瓣的文章。阿北从最初创办豆瓣到现在一直坚持着自己的初衷，为了给用户提供一个干净和文艺的平台而拒绝了多数商业盈利方式，比如投放广告等，维持豆瓣收支平衡即可。正因为这一份坚持，豆瓣已经成为了很多文艺青年心中最后的一块净土。阿北的偶像是乔布斯先生，也像乔布斯一样有着一种匠人精神。文章末尾引用了乔布斯的一段话，这段话也让我深有感触：</p>\n<p>“你的时间有限，所以不要为别人而活。不要被教条所限，不要活在别人的观念里。不要让别人的意见左右自己内心的声音。最重要的是，勇敢地去追随自己的心灵和直觉，只有自己的心灵和直觉才知道你的真实想法，其他的一切都是次要的。”</p>\n<p>目前来说很惭愧，我身上没有一丝匠人精神，但是我可以先做到不以金钱为直接目标，而是专注于个人能力的提升。每个人的处境是不同的，目前的我需要做的是努力提升专业技能和扩展知识面，只有当经济水平达到一定层次才有多余的精力去追求匠人精神，毕竟经济基础决定上层建筑。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-恶魔与天使","url":"http://icebergcwp.com/Daily-2018-06-24.html","content":"<p><strong>恶魔与天使</strong></p>\n<p>发现自己必须时刻提高警惕，不然心中的恶魔就会占据主动，从而自控力下降，做一些明知道不对的事情。</p>\n<p>因为是周末，忙碌了一周终于可以休息，似乎心态也随之放松，进入了另一种完全不同的生活方式，更准备地说的糟糕的生活方式。我内心很厌恶这样的自己，却往往要慢半拍才反应过来，而此时自己已经做出了错误的选择。比如下面的两件事情：</p>\n<p>一是早餐的选择，如果按照其他六天的标准，早餐是一个紫薯和两个鸡蛋，外加一杯牛奶。因为紫薯已经吃完了，我本可以去公司喝燕麦（刚好今天要去公司加班），但是我却毫不犹豫地选择提前出门去公司楼下的米粉店点了一份肉丝拌面。其实我清楚这个月的米粉早餐的特权（根据健身的标准，一个月只能吃一次米粉）已经在前几天使用了，即便如此我的整个决策过程没有丝毫迟疑，完全抛弃了自己定下的规则。</p>\n<p>二是下班之后去超市买菜，期间竟然不自觉走向零食区，这是我平时几乎是不会涉足的地方。我清晰地记得自己当时的心理读白：“今天是周末也在公司加班，整周都没休息，应该好好犒劳自己一下。再说了，最近健身体重有下降，腹肌也变得更清晰一些，吃一点零食没关系的”。就这样推着购物车在零食区溜达，选了两包零食，庆幸地是最终还是控制住了自己，看了看零食包装上面的营养参照表，忍受不了脂肪比重太大而放回了柜台。这完全得益于自己平时较为良好的饮食和健身习惯，形成了一套选择食物的最低标准。</p>\n<p>想起《自控力》书中提到的“三思而后行”法则：在做一个决定前停下来思考5秒左右，如果5秒之后你仍然决定去做，那么你的选择很可能不是一时冲动。</p>\n<p>自律才有自由，比自己优秀的人往往比自己更懂的自律，懂得合理地管理自己的精力和时间，从而实现它们的效率最大化。因此，比自己优秀的人进步的幅度是递增的，拉开的距离也就越来越大，这就是所谓的知识边际递增效应吧。</p>\n<p><strong>奇怪的心理</strong></p>\n<p>下周四就要靠科目二了，以目前的水平来说顶多七成把握，更多地是依赖当天的临场发挥。这就涉及到一个心理状态。在知乎看到很多人都有科目二恐惧症，实话说我自己多少也有一点，而且不能保证自己考试那天是否可以调整心态且发挥正常。换一个角度来说，大不了就是补考，一切以后能够安全驾驶为首要准则，更何况站在生活的层次来说考驾照压根不能算重要的事情，生活中比这更重要的事情多了去了。但是为什么心理还是会莫名地紧张呢？</p>\n<p>我大概归纳了一下自己产生这种紧张心理的原因。首先是人对于没有十足把握的事情多少会有点紧张，这是人之常情。其实是外界的压力，由于多年的应试教育，我们习惯地认为挂科是一件很丢脸的事情，从而给自己造成了一些额外的负担。</p>\n<p>我是这么安慰自己的：考驾照的最终目的是能够熟练地操作机动车，确保自己和乘客的安全，而且多数情况下是自己家人的安全。与这些事情相比，是否挂科这件事就显得微不足道了。</p>\n","categories":["日记"],"tags":[]},{"title":"Daily-Time waits for no one","url":"http://icebergcwp.com/Daily-2018-06-23.html","content":"<p><strong>为什么要写日记？</strong></p>\n<p>写日记的本质是什么？为什么那些很多人特别是有所作为的人，热衷于日复一日地去做这么一件看似枯燥乏味的事情？</p>\n<p>因为它代表的是我们逝去的时光，毕竟生命中重大意义的日子是少数，大部分时间我们都是过着有点重复或者平凡的日子。</p>\n<p>可以肯定的是多年以后你一定不会记得某一个平凡的日子发生了事情，但是日记可以帮助你唤醒记忆。</p>\n<p>如果在生命这辆高速前行地列车上，我能通过日记穿越到多年一前的某一站点，看看那里的风景，重温那一站带给我的感动，那该是多少有趣的一件事。</p>\n<p><strong>关于是否存在比人类文明更高级的文明？</strong></p>\n<p>站在地球生态链顶端的人类，很自然地会去思考一个问题：浩瀚的宇宙是否存在更高级的文明？</p>\n<p>然而，在探索这个问题之前我们需要明白一个思维困境。即我们一直以来都是以人类的认知方式去感知其他文明的，即便找到了也是与人类文明没有本质区别的，可能科技更为发达。</p>\n<p>假设其他文明是以一种人类无法感知的方式交流，那我们又如何能够发觉他们的存在呢？就好比寄生虫无法感知人类的存在一样，它是不会知道有人类这个物种存在的。</p>\n<p><strong>网易云音乐看到的美句</strong></p>\n<p>Leaving you is easy as forgetting how to breathe.</p>\n","categories":["日记"],"tags":[]},{"title":"iOS开发之何为BitCode？","url":"http://icebergcwp.com/iOS开发之何为BitCode#草稿#.html","content":"<p><em>Note：这篇博客不是严格意义上的原创，更准确地说是一篇对BitCode这个知识点自我总结和理解的文章。因此文章的内容难免与参考资料【见博客末尾】有雷同之处，特此声明</em></p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://lowlevelbits.org/bitcode-demystified/\" target=\"_blank\" rel=\"noopener\">Low Level Bits: BitCode Demystified</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/f42a33f5eb61\" target=\"_blank\" rel=\"noopener\">戴维营教育：深入理解iOS开发中的BitCode功能</a></p>\n</li>\n</ol>\n","categories":["专业","iOS"],"tags":["iOS","BitCode"]},{"title":"清理使用Xcode产生的衍生文件","url":"http://icebergcwp.com/清理使用Xcode产生的磁盘空间.html","content":"<p>昨天在查阅关于“Device Support files”相关资料时，无意间看到了一篇关于清理使用Xcode时产生的衍生文件的英文博客，觉得有一定实用价值，遂翻译之。</p>\n<p><a href=\"http://ajithrnayak.com/post/95441624221/xcode-users-can-free-up-space-on-your-mac\" target=\"_blank\" rel=\"noopener\">原文博客链接</a></p>\n<p><strong>以下是译文</strong></p>\n","categories":["专业"],"tags":["Xcode"]},{"title":"为什么计算机中要使用补码","url":"http://icebergcwp.com/为什么计算机中要使用补码.html","content":"<p>作为一个科班出身的软件开发从业者，知道今天才弄明白计算机中使用补码的原因，说来多少有点惭愧。</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_4e183aeb010112ba.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n","categories":["专业"],"tags":["补码"]},{"title":"iOS开发之App签名的原理","url":"http://icebergcwp.com/iOS开发之App签名的原理.html","content":"<p><a href=\"http://wereadteam.github.io/2017/03/13/Signature/\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<p>个人疑点： </p>\n<p>关于在苹果后天注册设备的步骤，自己在实际使用中并没有这一步操作。可能是在下载provisioning Profile时Xcode自动注册到苹果后天，有待验证。</p>\n","categories":["专业"],"tags":["补码"]},{"title":"在一台电脑搭建两个不同的hexo+github博客","url":"http://icebergcwp.com/在一台电脑搭建两个不同的hexo+github博客#草稿#.html","content":"<p>草稿：</p>\n<p>大概思路：<br>1、先完成一台电脑配置两个不同的github账号，参考<a href=\"https://www.jianshu.com/p/3fc93c16ad2d\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3fc93c16ad2d</a><br>~/.ssh/config文件下有两个host，分别对应不同的ssh秘钥：<br># default<br>Host github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa<br># industriousonesoft<br>Host ios.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa_ios</p>\n<p>2、每个账号分别搭建一个hexo博客<br>3、在hexo的目录下，在完成hexo安装和初始化后,以及配置主题之后，运行hexo g，如果运行hexo d，会因为权限限制导致发布失败<br>4、在当前目录下ls -la，进入隐藏目录：.deploy_git中，这个是hexo与github对接的目录，本质上就是git项目文件夹。<br>5、在.deploy_git目录下，运行<br># 取消全局 用户名/邮箱 配置<br>git config –global –unset user.name<br>git config –global –unset user.email<br># 单独设置每个repo 用户名/邮箱<br>git config user.email “xxxx@xx.com”<br>git config user.name “xxxx”</p>\n<p>重新关联git项目：如果是industriousonesoft上的则使用ios.github.com，如果是default则使用github.com，这一步是关键！！!<br>git remote rm origin<br>git remote add origin git@ios.github.com:whatever</p>\n<p>坑：_config.yml文件中设置下列属性，否则hexo s可以正常加载，hexo d加载失败：<br>url: <a href=\"https://industriousonesoft.github.io\" target=\"_blank\" rel=\"noopener\">https://industriousonesoft.github.io</a> //github账号<br>root: /gTunes-Mini-Player //仓库名称</p>\n","categories":["专业"],"tags":["hexo","github"]},{"title":"Audio Unit中I/O units详解","url":"http://icebergcwp.com/AudioUnit I:O units详解#草稿#.html","content":"<p><a href=\"https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/AudioUnitHostingFundamentals/AudioUnitHostingFundamentals.html#//apple_ref/doc/uid/TP40009492-CH3-SW43\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p><a href=\"https://stackoverflow.com/questions/16674760/how-to-set-scope-and-element-when-using-audio-unit\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></p>\n<p>Input/Output/Global scope与Element 0 1的关系</p>\n","categories":["专业"],"tags":["Core Audio"]},{"title":"在MacOS系统中使用OpenCV库（sandbox supported）","url":"http://icebergcwp.com/在MacOS系统中使用OpenCV库（sandbox supported）.html","content":"<p>最近因工作需要研究图片格式转换相关的知识点，其中使用到OpenCV库（一个基于BSD许可（开源）发行的跨平台计算机视觉库，很强大）中的ssim（结构相似性）算法实现来计算两张图片的相似度，用以做图片转换前后的对比。因此需要在Xcode中配置OpenCV库并且能在沙盒下使用，这一过程花费了将近一天的工作时间才配置成功，由于网上大多数资料基本上都是在非沙盒条件下的配置教程，对我没有太多实质性的帮助，这也是笔者写这篇博客的意义所在。</p>\n<h3 id=\"安装OpenCV库\"><a href=\"#安装OpenCV库\" class=\"headerlink\" title=\"安装OpenCV库\"></a>安装OpenCV库</h3><p>在Mac下，安装OpenCV库的方式一般有两种：使用brew命令或者使用make编译源代码。笔者用的是第一种：在终端执行命令：brew insall opencv，即可安装opencv库及其所依赖的动态库。安装成功之后，会在命令行终端的最后一行显示当前OpenCV库的安装路径和版本号，笔者电脑上的安装路径为：/usr/local/Cellar/opencv/3.4.0_1，版本号为3.4.0_1。</p>\n<p>在/usr/local/Cellar/opencv/3.4.0_1/include目录下有两个文件夹：opencv和opencv2，里面是OpenCV相关的头文件。/usr/local/Cellar/opencv/3.4.0_1/lib/下有许多前缀为libopencv_的dylib文件，这些都是OpenCV的链接库文件。</p>\n<h3 id=\"在MacOS下配置并使用OpenCV库\"><a href=\"#在MacOS下配置并使用OpenCV库\" class=\"headerlink\" title=\"在MacOS下配置并使用OpenCV库\"></a>在MacOS下配置并使用OpenCV库</h3><p>笔者项目中用到OpenCV库中的libopencv_imgproc.3.4.0.dylib库。因此下文以这个库为例进行展开，其他的库类似操作即可。</p>\n<h4 id=\"使用otool查看库依赖关系\"><a href=\"#使用otool查看库依赖关系\" class=\"headerlink\" title=\"使用otool查看库依赖关系\"></a>使用otool查看库依赖关系</h4><p>首先使用otool命令查看libopencv_imgproc.3.4.0.dylib的依赖关系，必须确保其这些依赖的库在系统中能够找到。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ otool -L /usr/local/Cellar/opencv/<span class=\"number\">3.4</span><span class=\"number\">.0</span>_1/lib/libopencv_imgproc<span class=\"number\">.3</span><span class=\"number\">.4</span><span class=\"number\">.0</span>.dylib </span><br><span class=\"line\">/usr/local/Cellar/opencv/<span class=\"number\">3.4</span><span class=\"number\">.0</span>_1/lib/libopencv_imgproc<span class=\"number\">.3</span><span class=\"number\">.4</span><span class=\"number\">.0</span>.dylib:</span><br><span class=\"line\">\t/usr/local/opt/opencv/lib/libopencv_imgproc<span class=\"number\">.3</span><span class=\"number\">.4</span>.dylib (compatibility version <span class=\"number\">3.4</span><span class=\"number\">.0</span>, current version <span class=\"number\">3.4</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t@rpath/libopencv_core<span class=\"number\">.3</span><span class=\"number\">.4</span>.dylib (compatibility version <span class=\"number\">3.4</span><span class=\"number\">.0</span>, current version <span class=\"number\">3.4</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class=\"number\">0.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">0.0</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t/usr/lib/libc++<span class=\"number\">.1</span>.dylib (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">120.1</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t/usr/lib/libSystem.B.dylib (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">1226.10</span><span class=\"number\">.1</span>)</span><br></pre></td></tr></table></figure>\n<p>可以看到libopencv_imgproc.3.4.0.dylib一共依赖了4个库，忽略系统自带的libc++.1.dylib和libSystem.B.dylib，因为这两个库任何Mac电脑上都可以找到。另外两个库分别是@rpath/libopencv_core.3.4.dylib和/usr/local/opt/tbb/lib/libtbb.dylib，分别查看这两个库所依赖的库。</p>\n<p>查看libopencv_core.3.4.dylib库的依赖关系。这个库是以libopencv_开头的，与libopencv_imgproc.3.4.0.dylib在同一个目录下。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ otool -L  /usr/local/Cellar/opencv/<span class=\"number\">3.4</span><span class=\"number\">.0</span>_1/lib/libopencv_core<span class=\"number\">.3</span><span class=\"number\">.4</span><span class=\"number\">.0</span>.dylib </span><br><span class=\"line\">/usr/local/Cellar/opencv/<span class=\"number\">3.4</span><span class=\"number\">.0</span>_1/lib/libopencv_core<span class=\"number\">.3</span><span class=\"number\">.4</span><span class=\"number\">.0</span>.dylib:</span><br><span class=\"line\">\t/usr/local/opt/opencv/lib/libopencv_core<span class=\"number\">.3</span><span class=\"number\">.4</span>.dylib (compatibility version <span class=\"number\">3.4</span><span class=\"number\">.0</span>, current version <span class=\"number\">3.4</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class=\"number\">0.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">0.0</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t/usr/lib/libz<span class=\"number\">.1</span>.dylib (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">1.2</span><span class=\"number\">.5</span>)</span><br><span class=\"line\">\t/System/Library/Frameworks/OpenCL.framework/Versions/A/OpenCL (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">1.0</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t/System/Library/Frameworks/Accelerate.framework/Versions/A/Accelerate (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">4.0</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t/usr/lib/libSystem.B.dylib (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">1226.10</span><span class=\"number\">.1</span>)</span><br><span class=\"line\">\t/usr/lib/libc++<span class=\"number\">.1</span>.dylib (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">120.1</span><span class=\"number\">.0</span>)</span><br></pre></td></tr></table></figure>\n<p>可以看到，忽略系统自带的库之后其所依赖的库只有一个：/usr/local/opt/tbb/lib/libtbb.dylib。说明libtbb.dylib这个库同时被libopencv_core.3.4.dylib和libopencv_imgproc.3.4.0.dylib引用到。</p>\n<p>查看libtbb.dylib库的依赖关系，在目录/usr/local/opt/tbb/lib/目录下可找到这个库。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ otool -L /usr/local/opt/tbb/lib/libtbb.dylib</span><br><span class=\"line\">/usr/local/opt/tbb/lib/libtbb.dylib:</span><br><span class=\"line\">\t/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class=\"number\">0.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">0.0</span><span class=\"number\">.0</span>)</span><br><span class=\"line\">\t/usr/lib/libSystem.B.dylib (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">1226.10</span><span class=\"number\">.1</span>)</span><br><span class=\"line\">\t/usr/lib/libc++<span class=\"number\">.1</span>.dylib (compatibility version <span class=\"number\">1.0</span><span class=\"number\">.0</span>, current version <span class=\"number\">120.1</span><span class=\"number\">.0</span>)</span><br></pre></td></tr></table></figure>\n<p>可以看到libtbb.dylib库所依赖的都是系统自带的库，所以库依赖关系遍历到此结束。如果当前库还依赖于其他非系统自带库，则需要继续查找下去。</p>\n<p>弄清楚库之间的依赖关系之后，接下来将库配置到Xcode中。</p>\n<h4 id=\"无沙盒\"><a href=\"#无沙盒\" class=\"headerlink\" title=\"无沙盒\"></a>无沙盒</h4><p>如果是无沙盒条件下使用OpenCV还是很简单的，因为使用brew命令安装OpenCV过程中所有依赖的库都已帮你配置好了，只需要配置好头文件和库文件即可，不需要关心库之间的依赖关系。</p>\n<p>首先配置OpenCV库头文件的查找路径，在Xcode-&gt;Target-&gt;Build Settings中找到“Header Search Paths”选项，新添加一项：/usr/local/Cellar/opencv/3.4.0_1/include。</p>\n<p>配置OpenCV库文件的查找路径：在Xcode-&gt;Target-&gt;Build Settings中找到“Lib Search Paths”，新添加一项：/usr/local/Cellar/opencv/3.4.0_1/lib。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/1.png\" alt=\"无沙盒配置头文件\"></p>\n<p>接着切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Link Binary With Libraries”中，将软件依赖的OpenCV链接库拖拽其中。笔者只用到了libopencv_imgproc.3.4.0.dylib库，因此只需要拖拽这一个库即可。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/2.png\" alt=\"无沙盒配置库文件\"></p>\n<p>对于 Lion 操作系统，需要在Xcode-&gt;Target-&gt;Build Settings中，将“C++ Language Dialect”设置成 C++11，将“C++ Standard Library”设置成libstdc++ ，如下图所示。个人感觉是由于Xcode默认设置的GNU++11、libc++与OpenCV库有一些兼容性问题，我在更改该设置前老是出现编译错误。后续版本在Montain Lion系统中解决了这个问题，因此不需要此操作。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/3.png\" alt=\"无沙盒配置编译器\"></p>\n<p>注意，如果使用OpenCV库函数的源文件扩展名是.m的，你还需要改成.mm，这样编译器才知道该文件混合使用C++语言和Objective-C语言。</p>\n<p>以上，无沙盒条件下配置完成。这种配置存在一个严重的缺陷，即如果想要编译后的软件在其他电脑上正常运行则必须确保其他电脑在同样系统目录下安装了OpenCV库，即OpenCV库头文件与链接库文件目录与编译电脑一致，显然这是不能接受的。常规的解决方法是将软件所依赖的库一并打包到软件中，具体配置过程可见于下文的有沙盒配置过程。</p>\n<h4 id=\"有沙盒\"><a href=\"#有沙盒\" class=\"headerlink\" title=\"有沙盒\"></a>有沙盒</h4><p>有沙盒与无沙盒的区别出来签名之外，还有一个重要的区别就是访问权限。无沙盒条件下，软件和Xcode一样拥有当前用户下的最高权限，可以访问当前用户下的任何目录，这也是为什么在Xcode的配置项中可以直接使用当前用户的系统路径的原因。</p>\n<p>一旦为添加沙盒条件后，软件所能访问的目录局限于自己的沙盒下，不再有访问当前用户系统目录的权限。此时，只有将软件所依赖的库一并打包到软件中，才能使软件正常运行。具体步骤如下所示。</p>\n<p>首先，将软件所依赖的库文件和头文件拷贝到项目工程下的OpenCV目录中，分别存放于lib目录和include目录中：</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/4.png\" alt=\"有沙盒配置拷贝库相关文件\"></p>\n<p>然后，配置OpenCV库头文件的查找路径，在Xcode-&gt;Target-&gt;Build Settings中找到“Header Search Paths”选项，新添加一项：\\$(PROJECT_DIR)/OpenCV/include。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/5.png\" alt=\"有沙盒配置头文件\"></p>\n<p>接着，配置OpenCV库文件的查找路径：在Xcode-&gt;Target-&gt;Build Settings中找到“Lib Search Paths”，新添加一项：\\$(PROJECT_DIR)/OpenCV/lib。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/6.png\" alt=\"有沙盒配置库文件\"></p>\n<p>其中PROJECT_DIR宏是Xcode自带的，表示xxx.xcodeproj文件所在的目录路径。</p>\n<p>然后，切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Link Binary With Libraries”中，将软件用到依赖的OpenCV链接库拖拽其中。笔者只用到了libopencv_imgproc.3.4.0.dylib库，因此只需要拖拽这一个库即可。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/2.png\" alt=\"有沙盒配置关联库文件\"></p>\n<p>接着，切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Copy Files”中，将libopencv_imgproc.3.4.0.dylib库及其所依赖的库拷贝到软件目录下的Frameworks中。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/7.png\" alt=\"有沙盒配置关联库文件\"></p>\n<p>最后一步，使用install_name_tool命令修改依赖库之间、软件与依赖库的依赖关系。因为使用brew安装，库之间的依赖关系以及库本身的加载路径都是系统路径，在沙盒条件下是无效的。</p>\n<p>切换到Xcode-&gt;Target-&gt;Build Phases的tab下，点击左上角的“+”，选择“New Run Script Phase”，新建一个“Run Script”项目，里面是一个shell脚本文件，在Xcode编译运行前执行。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/8.png\" alt=\"有沙盒配置修改库依赖关系\"></p>\n<p>修改依赖关系的顺序很重要，如果依赖关系是：软件-&gt;dylibA-&gt;dylibB-&gt;dylibC，则修改依赖关系的顺序是：dylibC-&gt;dylibB-&gt;dylibA-&gt;软件。</p>\n<p>笔者当前软件中的依赖关系是：软件-&gt;libopencv_imgproc.3.4.0.dylib-&gt;libopencv_core.3.4.0.dylib-&gt;libtbb.dylib。</p>\n<p>由于libtbb.dylib库所依赖的都是系统自带库，因此不需要修改。</p>\n<p>修改命令与参数简单介绍，详细使用方式可通过终端执行命令：man install_name_tool查看：<br>install_name_tool -change oldPath newPath lib(or executable file)</p>\n<p><strong>1. 修改libopencv_core.3.4.0.dylib对libtbb.dylib的依赖关系</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">install_name_tool -change <span class=\"string\">\"/usr/local/opt/tbb/lib/libtbb.dylib\"</span> <span class=\"string\">\"@loader_path/libtbb.dylib\"</span> <span class=\"string\">\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_core.3.4.0.dylib\"</span></span><br></pre></td></tr></table></figure>\n<p>其中@loader_path是Xcode自带的宏，表示库加载路径，即libopencv_core.3.4.0.dylib的加载路径，因为libtbb.dylib与libopencv_core.3.4.0.dylib是在同一目录，因此@loader_path/libtbb.dylib表示告诉libopencv_core.3.4.0.dylib在自身所在目录中加载libtbb.dylib。</p>\n<p>$TARGET_BUILD_DIR是Xcode自带的宏，表示Xcode编译目录，即编译后的软件存放的目录。PRODUCT_NAME宏也是Xcode自带的，表示软件名称。因为笔者项目中是先拷贝库文件到软件目录中，再修改依赖关系。因此libopencv_core.3.4.0.dylib库所在路径为：$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_core.3.4.0.dylib。</p>\n<p>以下修改命令类似，不再赘述。</p>\n<p><strong>2. 修改libopencv_imgproc.3.4.0.dylib对libtbb.dylib和libopencv_core.3.4.0.dylib的依赖关系</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">install_name_tool -change <span class=\"string\">\"/usr/local/opt/tbb/lib/libtbb.dylib\"</span> <span class=\"string\">\"@loader_path/libtbb.dylib\"</span> <span class=\"string\">\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_imgproc.3.4.0.dylib\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">install_name_tool -change <span class=\"string\">\"@rpath/libopencv_core.3.4.dylib\"</span> <span class=\"string\">\"@loader_path/libopencv_core.3.4.0.dylib\"</span> <span class=\"string\">\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_imgproc.3.4.0.dylib\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>3.软件对libopencv_imgproc.3.4.0.dylib库的依赖关系</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">install_name_tool -change <span class=\"string\">\"/usr/local/opt/opencv/lib/libopencv_imgproc.3.4.dylib\"</span> <span class=\"string\">\"@executable_path/../Frameworks/libopencv_imgproc.3.4.0.dylib\"</span> <span class=\"string\">\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME\"</span></span><br></pre></td></tr></table></figure>\n<p>值得注意的是，软件路径必须可执行文件的路径$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME，而不能是$TARGET_BUILD_DIR/$PRODUCT_NAME.app，因为xxx.app文件本质上的一个目录。</p>\n<p><strong>注意：如果在软件编译后运行时crash，并提示类似ImageLoaderMachO的错误则很可能是因为从系统目录下拷贝过来的库文件没有写的权限。因为OpenCV使用的是brew命令安装，brew使用的是root权限，而Xcode只有当前目录下的最高权限，所以必须确保库文件在当前用户下有读写权限，可以使用chmod +rw /path/to/dylib添加读写权限</strong></p>\n<p>以上，在有沙盒条件下的配置完成。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>笔者在刚开始配置过程中，由于自身知识储备不足的原因被折腾得够呛。现在看来整个配置过程其实不难，通过博客记录一遍思路和流程显得更为清晰，理解也更为深刻。</p>\n","categories":["专业"],"tags":["OpenCV"]},{"title":"Effective Objective-C 2.0读书笔记","url":"http://icebergcwp.com/Effective Objective-C 2.0读书笔记.html","content":"<h3 id=\"第1章-熟悉Objective-C\"><a href=\"#第1章-熟悉Objective-C\" class=\"headerlink\" title=\"第1章 熟悉Objective-C\"></a>第1章 熟悉Objective-C</h3><h4 id=\"1-了解Objective-C语言的起源\"><a href=\"#1-了解Objective-C语言的起源\" class=\"headerlink\" title=\"1: 了解Objective-C语言的起源\"></a>1: 了解Objective-C语言的起源</h4><ul>\n<li>Objective-C语言是由Smalltalk演化而来，后者是消息型语言的鼻祖。</li>\n<li>消息机构的语言，不论是否多态，其运行时所执行的代码都由运行环境来决定；而使用函数调用的语言则由编译器决定，但调用函数是多态的，则是在运行时通过查询“虚方法表（virtual table）”决定具体执行函数。</li>\n<li>如果只需要保存int、flot、double、char等非对象类型，通常使用CGRect这种结构体，因为结构体可以使用栈空间，而不用分配和释放堆空间，避免额外开销。</li>\n</ul>\n<h4 id=\"2-在类的头文件中尽量少引用其他头文件\"><a href=\"#2-在类的头文件中尽量少引用其他头文件\" class=\"headerlink\" title=\"2: 在类的头文件中尽量少引用其他头文件\"></a>2: 在类的头文件中尽量少引用其他头文件</h4><ul>\n<li>除非确实有必要，否则不要引入头文件，尽量使用向前声明，这样不但可以缩短编译时间和降低类之间的耦合。</li>\n<li>如果无法使用向前声明，比如要声明某个类遵循一项协议。尽量把所遵循的协议移至实现文件中的匿名分类。如果必须在头文件引入协议头文件，则把协议单独放在一个头文件中。</li>\n</ul>\n<h4 id=\"3-多用字面量语法，少用与之对等的方法\"><a href=\"#3-多用字面量语法，少用与之对等的方法\" class=\"headerlink\" title=\"3: 多用字面量语法，少用与之对等的方法\"></a>3: 多用字面量语法，少用与之对等的方法</h4><ul>\n<li>使用字面量语法创建字符串、数值、数组、字典更为简单扼要。</li>\n<li>使用取下标操作访问数组下标或者字典中的键对应的元素。</li>\n<li>使用字面量语言更为安全，遇到nil对象会抛出异常。</li>\n<li>字面量语法的限制：除了字符串以外，所创建出来的对象必须属于Foundation框架才行。</li>\n</ul>\n<h4 id=\"4-多用类型常量，少用-define预处理指令\"><a href=\"#4-多用类型常量，少用-define预处理指令\" class=\"headerlink\" title=\"4: 多用类型常量，少用#define预处理指令\"></a>4: 多用类型常量，少用#define预处理指令</h4><ul>\n<li>若常量局限于某个实现文件之内，则前面加字面k，若常量在类之外，则通常以类名为前缀。</li>\n<li>static修饰符意味着变量仅在定义此变量的编译单元中可见，在Objective-C的语境下，编译单元通常指每个类的实现文件，即以.m为后缀名。</li>\n<li><p>常量必须使用const修饰符声明，常量定义从右至左解读，下面例子中定义了一个常量指针，const修饰的是指针，指向NSString对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> ECOStringConstant;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> ECOStringConstant = <span class=\"string\">@\"VALUE\"</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果一个变量同时声明为static和const,那么编译器根本不会创建符号，而是会像#define预处理指令一样，把所有遇到的变量都替换为常值。</p>\n</li>\n<li>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号中，因此通常与之相关的类名做前缀加以区分。</li>\n</ul>\n<h4 id=\"5：用枚举表示状态、选项、状态码\"><a href=\"#5：用枚举表示状态、选项、状态码\" class=\"headerlink\" title=\"5：用枚举表示状态、选项、状态码\"></a>5：用枚举表示状态、选项、状态码</h4><ul>\n<li>C++11标准修订了枚举的某些特性，其中包括可以指定何种“底层数据类型”来保存枚举类型的变量。这样做的好处是可以向前声明枚举变量了，如果编译器不清楚底层数据类型就不知道分配空间大小。</li>\n<li>如果枚举类型是多个选项且同时使用，那么久将各选项值定义为2的幂，以便按位或操作进行组合。</li>\n<li>用NS_ENUM与NS_OPTION宏来定义枚举类型，并指明其底层数据类型，这样确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li>\n<li>在处理枚举类型的switch语句中不要实现default分析，这样加入新的枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</li>\n</ul>\n<h3 id=\"第2章-对象、消息、运行期\"><a href=\"#第2章-对象、消息、运行期\" class=\"headerlink\" title=\"第2章 对象、消息、运行期\"></a>第2章 对象、消息、运行期</h3><h4 id=\"第6条：-理解“属性”这一概念\"><a href=\"#第6条：-理解“属性”这一概念\" class=\"headerlink\" title=\"第6条： 理解“属性”这一概念\"></a>第6条： 理解“属性”这一概念</h4><ul>\n<li>使用@property语法编译器会自动创建一套存取方法，因此访问属性实质上就是调用存取函数，走消息派发流程。</li>\n<li>@synthesize语言可以指定属性实例变量的名字，默认的属性名前加下划线。</li>\n<li>@dynamic关键字可以阻止属性创建实例变量和存取方式，编译器即使在编译过程中没有发现该属性的存取方法也不会保存，而是相信这些方法在运行期能够找到。</li>\n<li>原子性只能确保每次都能获取属性的有效值，即确保属性修改完成再被其他线程访问，但是不能确保线程安全。</li>\n<li>处于性能考虑，iOS程序所有属性都是nonatomic，Mac OS X程序使用atomic属性通常不会有性能瓶颈。</li>\n<li>对应一个属性定义的变量来说，直接访问实例变量会绕开指定的属性特质和消息派发流程。</li>\n</ul>\n<h4 id=\"第7条：在对象内部尽量直接访问实例变量\"><a href=\"#第7条：在对象内部尽量直接访问实例变量\" class=\"headerlink\" title=\"第7条：在对象内部尽量直接访问实例变量\"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul>\n<li>使用“点语法”（本质上使用实例变量存取方法）与直接访问实例变量的区别：<ul>\n<li>直接访问实例变量不经过Objective-C的消息派发流程，因此速度比点语法快。</li>\n<li>直接访问实例变量不会调用属性配置的存取方法，从而绕过了属性指定的相关特质。</li>\n<li>直接访问实例变量不会触发“键值观测KVO”通知，因为键值观测是建立在存取方法之上的。</li>\n</ul>\n</li>\n<li>在初始化方法和dealloc中尽量直接访问实例变量，因为子类可能覆写父类属性的存取方法，从而无法输出预期。</li>\n<li>在对象内部读取数据时，应该直接通过实例变量来读，除惰性初始化技术之外。而写入数据时则应通过属性来写。</li>\n</ul>\n<h4 id=\"第8条：理解“对象等同性”这一概念\"><a href=\"#第8条：理解“对象等同性”这一概念\" class=\"headerlink\" title=\"第8条：理解“对象等同性”这一概念\"></a>第8条：理解“对象等同性”这一概念</h4><ul>\n<li>检测对象的等同性，必须提供“isEqual:”和hash方法。相等的对象hash值必须相同，但是has值相同的对象未必相等。</li>\n<li>计算hash值时应考虑减少碰撞。因为collection检索哈希表时会用对象的哈希值作为索引。hash方法的高效与低碰撞率可以使collection减少开销。</li>\n<li>等同性判定的执行深度根据具体的对象决定，不一定将整个对象进行判定，有时候只需要判定代表对象唯一性的值即可。</li>\n<li>在容器中放入可变类对象时，确保对象加入后就不再改变哈希值，否则容易造成未知行为。</li>\n</ul>\n<h4 id=\"第9条：以“类簇模式”隐藏实现细节\"><a href=\"#第9条：以“类簇模式”隐藏实现细节\" class=\"headerlink\" title=\"第9条：以“类簇模式”隐藏实现细节\"></a>第9条：以“类簇模式”隐藏实现细节</h4><ul>\n<li>类簇模式可以把实现细节隐藏在一套简单的公共接口后面。</li>\n<li>系统框架中经常使用类簇，比如NSArray、NSNumber等。</li>\n<li>从类簇的公共抽象基类中继承子类时，遵循几条规则：<ul>\n<li>子类应该继承自类簇中的抽象基类。</li>\n<li>子类应该定义自己的数据存储方式。</li>\n<li>子类应当覆写超类文档中指明需要覆写的方法。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"第10条：在既有类中使用关联对象存放自定义数据\"><a href=\"#第10条：在既有类中使用关联对象存放自定义数据\" class=\"headerlink\" title=\"第10条：在既有类中使用关联对象存放自定义数据\"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><ul>\n<li>使用关联对象可以将两个对象以属性的方式关联起来，并指定类似于@property的内存管理语义和存储策略。</li>\n<li>设置关联对象的键值是个“不透明指针”，若想令两个键值匹配到同一个值，二者必须是完全相同的指针才行。鉴于此，设置关联对象值时通常使用静态全局变量做键值。</li>\n<li>由于关联对象容易引入难于排查的bug，所以不要轻易使用。</li>\n</ul>\n<h4 id=\"第11条：理解objc-msgSend的作用\"><a href=\"#第11条：理解objc-msgSend的作用\" class=\"headerlink\" title=\"第11条：理解objc_msgSend的作用\"></a>第11条：理解objc_msgSend的作用</h4><ul>\n<li>objc_msgSend通过在运行期搜索接收者类的方法列表实现“动态绑定”，以选择子为key值搜索函数指针。</li>\n<li>函数原型与objc_msgSend函数很像，在objc_msgSend函数内部搜索到选择子对应的函数并在函数最后return语句调用，利用“尾调用优化”进行优化。</li>\n</ul>\n<h4 id=\"第12条：理解消息转发机制\"><a href=\"#第12条：理解消息转发机制\" class=\"headerlink\" title=\"第12条：理解消息转发机制\"></a>第12条：理解消息转发机制</h4><ul>\n<li>消息转发分两大阶段：动态方法解析和完整的消息转发机制（分两阶段）</li>\n<li>动态方法解析：实例对象收到无法解析的消息会触发类方法：+（BOOL）resolveInstanceMethod:(SEL)selector，如果是类对象对应的类方法为：+（BOOL）resolveClassMethod:(SEL)selector。在这个方法中可以通过class_addMethod动态插入方法，所添加的方法是用纯C函数（IMP指针）。</li>\n<li>完整的消息转发机制第一阶段：调用函数-(id)forwardingTargetForSelector:(SEL)selector，看是否能把消息转发其他对象处理。通过此方案可以用“组合”来模拟”多重继承“的某些特性。</li>\n<li>完整的消息转发机制第二阶段：- (void)forwardInvocation:(NSInvocation *)invocation;此阶段可以在转发消息前修改消息内容。若本类不处理，则需调用父类同名方法。</li>\n</ul>\n<p>###第4章 协议与分类</p>\n<h4 id=\"23：通过委托与数据源协议进行对象间通信\"><a href=\"#23：通过委托与数据源协议进行对象间通信\" class=\"headerlink\" title=\"23：通过委托与数据源协议进行对象间通信\"></a>23：通过委托与数据源协议进行对象间通信</h4><ul>\n<li>委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象</li>\n<li>当某对象需要从另外一个对象中获得数据时，可以使用委托模式【数据源协议】。</li>\n<li>若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。</li>\n</ul>\n<h4 id=\"24：将类的实现代码分散到便于管理的数个分类之中\"><a href=\"#24：将类的实现代码分散到便于管理的数个分类之中\" class=\"headerlink\" title=\"24：将类的实现代码分散到便于管理的数个分类之中\"></a>24：将类的实现代码分散到便于管理的数个分类之中</h4><ul>\n<li>使用分类机制将类的实现代码划分成易于管理的小块</li>\n<li>将应该视为“私有”的方法归入名叫private的分类中，以隐藏实现细节。</li>\n</ul>\n<h4 id=\"25：总是为第三方类的分类名称加前缀\"><a href=\"#25：总是为第三方类的分类名称加前缀\" class=\"headerlink\" title=\"25：总是为第三方类的分类名称加前缀\"></a>25：总是为第三方类的分类名称加前缀</h4><ul>\n<li>分类机制通常用于向无源代码的既有类中增加新功能，且分类中的方法会覆盖既有类的同名方法，后一个分类会覆盖前一个分类的同名方法。</li>\n<li>为了减少同名函数覆盖的概率，以命名空间来区分各个分类的名称与其中所定义的方法，在Objective-C中实现命名空间的方法就是给分类名和函数名添加专用的前缀。</li>\n</ul>\n<h4 id=\"26：勿在分类中声明属性\"><a href=\"#26：勿在分类中声明属性\" class=\"headerlink\" title=\"26：勿在分类中声明属性\"></a>26：勿在分类中声明属性</h4><ul>\n<li>属性是封装数据的方式，尽管可以通过关联对象的方式合成实例变量，但是建议最好全部在主接口中实现，分类的作用在于扩展类的功能，而非封装数据</li>\n<li>除了“class-continuation分类【匿名分类】”之外可以定义属性，其他分类最好只定义方法</li>\n</ul>\n<h4 id=\"27：使用“class-continuation分类”隐藏实现细节\"><a href=\"#27：使用“class-continuation分类”隐藏实现细节\" class=\"headerlink\" title=\"27：使用“class-continuation分类”隐藏实现细节\"></a>27：使用“class-continuation分类”隐藏实现细节</h4><ul>\n<li>匿名分类可以定义方法和实例变量，原因在于“稳固的ABI”机制（详见第6条）</li>\n<li>在实现块中添加匿名分类可隐藏实现细节，即私有变量和方法。</li>\n<li>编译objective-C++时，在匿名分类中定义c++相关的变量，从而避免了因为在头文件中声明C++变量，进而导致凡是引用该类的其他类都必须改为Objective-C++类。</li>\n<li>利用匿名分类扩展头文件中声明为“只读”的属性为“可读写”状态</li>\n<li>利用匿名分类隐藏该类遵循的协议。</li>\n</ul>\n<h4 id=\"28：通过协议提供匿名对象\"><a href=\"#28：通过协议提供匿名对象\" class=\"headerlink\" title=\"28：通过协议提供匿名对象\"></a>28：通过协议提供匿名对象</h4><ul>\n<li>使用协议可将具体的对象类型谈化成遵循某种协议的id类型，协议中规定了对象需实现的方法</li>\n<li>如果对象类型不重要，重要的是对象是否实现了某些方法，此时可用“匿名对象”来实现这一概念，与Python的“鸭子类型”有点相似。</li>\n</ul>\n<p>###第5章 内存管理</p>\n<h4 id=\"第29条：理解引用计数\"><a href=\"#第29条：理解引用计数\" class=\"headerlink\" title=\"第29条：理解引用计数\"></a>第29条：理解引用计数</h4><ul>\n<li>悬挂指针：对象在release之后，内存被放回“可用内存池”，但是不一定保证马上被回收，此时指针属于悬挂指针，容易导致crash。</li>\n<li>为了避免不经意间使用了悬挂指针，在调用完release之后清空指针</li>\n<li>autorelease能延长对象生命周期，使其在跨越方法调用边界后依然跨越存活一段时间，释放操作会在清空最外层自动释放池时执行，即在当前线程进入下一次事件循环时释放。</li>\n<li>通常采用“弱引用”来避免循环引用发生，从而避免内存泄漏</li>\n</ul>\n<h4 id=\"第30条：以ARC简化引用计数\"><a href=\"#第30条：以ARC简化引用计数\" class=\"headerlink\" title=\"第30条：以ARC简化引用计数\"></a>第30条：以ARC简化引用计数</h4><ul>\n<li>Clang的静态分析器（static analyzer）不但可以指明程序中引用计数出现问题的地方，还能根据需要预先加入适当的retain和release操作以避免这些问题。自动引用计（ARC）数的思路也是源于此。</li>\n<li>ARC在执行retain、release和autorelease等操作时，不是通过普通的Objective-C消息派送机制，而是直接调用其对应的C语言版本，这样效率更高。</li>\n<li>ARC通过命名约定将内存管理标准化，方法名以下列词语开头，其返回的对象归调用者所有：<ul>\n<li>alloc</li>\n<li>new</li>\n<li>copy</li>\n<li>mutableCopy<br>否则，返回对象会自动释放，即相当于执行autorelease操作.</li>\n</ul>\n</li>\n<li>在编译期和运行期，ARC都把能够相互抵消的retain、release、autorelease操作约简。</li>\n<li>运行期，为了优化代码，在方法返回自动释放的对象时，调用objc_autoreleaseReturnValue,此函数会检视当前函数调用的代码是否需要对返回对象执行retain操作，如果是则设置一个全局标志位。而不执行autorelease操作；与只对应的是在调用代码如果要保留对象，则不执行retain操作，而是调用objc_retainAutoreleasedRetuenValue.此函数检测之前设置的全局标志位，如果已经置位，则不执行retain操作。</li>\n<li>ARC环境优化方式具体实现由编译器决定，比如将全局标志位存储在STL(Thread Local Storage:线程局部存储，以key-value的形式读写)中，STL只适用于调用和被调用方都是ARC模式的情况，使用__builtin_return_address可以在被调用函数中获得调用函数的栈空间，进而可以推算出调用方后续操作是否调用了objc_retainAutoreleasedReturnValue，如果调用则是ARC环境，反之使用没优化的老逻辑。</li>\n<li>变量的内存管理的边界问题，在设置变量值时，需要先保留新值，释放旧值，最后设置实例变量，确保即便是新值与旧值是同一对象也不能引发错误。在ARC情况下，无需考虑这种“边界情况”</li>\n<li>ARC下清理实例变量是借用Objective-C++的析构函数实现的，不需要重载dealloc，如果存在CoreFoundation等非Objective-C对象时，只需在dealloc函数中执行CFRetain/CFRelease等释放操作，而不需要调用超类的dealloc方法。</li>\n</ul>\n<h4 id=\"第31条：合理使用dealloc方法\"><a href=\"#第31条：合理使用dealloc方法\" class=\"headerlink\" title=\"第31条：合理使用dealloc方法\"></a>第31条：合理使用dealloc方法</h4><ul>\n<li>在dealloc中只释放对其他对象的引用，解除监听和取消订阅的KVO等，不要做其他事情</li>\n<li>不要在dealloc中释放开销大或系统内稀缺资源，如文件描述符、套接字以及大块内存等，因为这些资源可能被其他对象持有，不宜保留过长时间，而是实现一个专门用于清理的函数，如close等</li>\n<li>出于优化效率的目的，系统不能保证每一个对象的dealloc都会执行</li>\n<li>不应在dealloc中调用执行异步任务的方法或只能在正常状态下执行的方法，因为dealloc所在的线程会执行final release。</li>\n</ul>\n<h4 id=\"第32条：编写“异常安全代码”时留意内存管理问题\"><a href=\"#第32条：编写“异常安全代码”时留意内存管理问题\" class=\"headerlink\" title=\"第32条：编写“异常安全代码”时留意内存管理问题\"></a>第32条：编写“异常安全代码”时留意内存管理问题</h4><ul>\n<li>MRC环境下，在@try中创建的对象应在@finaly中释放而非@try中，以避免因抛出异常导致内存泄漏</li>\n<li>ARC环境下，出于对运行期的性能考虑默认情况下是不会处理异常捕获过程中出现的内存泄漏情况。</li>\n<li>ARC环境下，可以通过-fobjc-arc-exceptions这个编译标志开启安全处理异常功能，默认情况是关闭的，但是出于Objectve-C++模式下会自动打开。</li>\n</ul>\n<h4 id=\"第33条：以弱引用避免保留环\"><a href=\"#第33条：以弱引用避免保留环\" class=\"headerlink\" title=\"第33条：以弱引用避免保留环\"></a>第33条：以弱引用避免保留环</h4><ul>\n<li>虽然垃圾回收机制可以检测并回收保留环，但是Mac OS X 10.8之后以及iOS平台不支持这个功能</li>\n<li>MRC环境下，使用unsafe_unretained（表明属性不安全且不归实例所拥有）或者weak属性来避免保留环，且效果等同</li>\n<li>ARC环境下，weak属性在修饰对象被回收后自动清空，更为安全，避免访问悬挂指针。</li>\n</ul>\n<h4 id=\"第34条：以“自动释放池块”降低内存峰值\"><a href=\"#第34条：以“自动释放池块”降低内存峰值\" class=\"headerlink\" title=\"第34条：以“自动释放池块”降低内存峰值\"></a>第34条：以“自动释放池块”降低内存峰值</h4><ul>\n<li>GCD或主线程都默认自带自动释放池。</li>\n<li>自动释放池是以栈的形式存在的，对象收到autorelease消息后，会被放入最近的自动释放池的栈顶。</li>\n<li>合理运用自动释放池，用以降低应用程序的内存峰值，如for循环中。</li>\n<li>ARC环境下的@autoreleasepool比MRC环境下NSAutoreleasepool更为轻便与安全。</li>\n</ul>\n<h4 id=\"第35条：用“僵尸对象”调试内存管理问题\"><a href=\"#第35条：用“僵尸对象”调试内存管理问题\" class=\"headerlink\" title=\"第35条：用“僵尸对象”调试内存管理问题\"></a>第35条：用“僵尸对象”调试内存管理问题</h4><ul>\n<li>向已回收的对象发送消息是不安全与不稳当的，如果内存已经被复用且复用的对象不能响应此消息则会crash，如果复用对象能够响应消息也许输出不能达到预期，如果内存部分存活则可能消息可能依然有效。</li>\n<li>“僵尸对象”是调试内存管理问题最佳方式。</li>\n<li>僵尸类是从名为<em>NSZombie</em>的模板类复制而来，通过创建一个名为<em>NSZombie</em>原类名的新类，再将已回收对象的指针指向新类，原对象的类变了，但是内存结构不变，便于调试。示例代码：</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *clsName = class_getName(cls);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *zombieClsName = <span class=\"string\">\"_NSZombie_\"</span> + clsName;</span><br><span class=\"line\">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!zombieCls) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> baseZomeCls = objc_lookUpClass(<span class=\"string\">\"_NSZombie_\"</span>);</span><br><span class=\"line\">\tzombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Perform normal destruction of the object being deallocated</span></span><br><span class=\"line\">objc_destructInstance(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"><span class=\"comment\">//Set the class of the object being deallocated to the zombie class</span></span><br><span class=\"line\">objc_setClass(<span class=\"keyword\">self</span>, zombieCls);</span><br></pre></td></tr></table></figure>\n<p>代码的关键在于：对象的内存没有释放，因此这块内存不可被其他对象复用，虽然会造成内存泄漏，但是出于调试的目的可以忽略。</p>\n<ul>\n<li>僵尸类的作用是通过消息转发机制体现，因为僵尸类没有实现任何方法，和Object一样是根类，只有一个实例变量isa。在消息转发机制通过类名检测到当前对象是一个僵尸对象时会进行特殊处理：打印原类的相关信息，然后终止程序。示例代码：</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *clsName = class_getName(cls);</span><br><span class=\"line\"><span class=\"comment\">//If so, this is a zombie</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (string_has_prefix(clsName, <span class=\"string\">\"_NSZombie_\"</span>)) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *originClsName = substring_from(clsName, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *selectorName = sel_getName(_cmd));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tLog(<span class=\"string\">\"*** - [%s %s]: message sent to deallocated instance %p\"</span> , originalClsName, selectorName, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第36条：不要使用retainCount\"><a href=\"#第36条：不要使用retainCount\" class=\"headerlink\" title=\"第36条：不要使用retainCount\"></a>第36条：不要使用retainCount</h4><ul>\n<li>retainCount返回的保留计数只是某个给定时间点上的值，并未考虑到对象加入自动释放池的情况，因此不能反映真实的保留计数。</li>\n<li>有时系统出于优化的目的，retainCount可能永远都不返还0，在保留计数为1的时候就被回收了。</li>\n</ul>\n<p>###第6章 块与大中枢派发</p>\n<p>####第37条 理解“块”这一概念</p>\n<ul>\n<li>块在定义与使用方面与函数类似，但是块本身是一个对象，有引用计数。</li>\n<li>在块中直接访问实例变量，虽没有显性使用self，但是self变量还是会被块捕获。</li>\n<li>块的内存结构中，最重要的是invoke函数指针，指向块的实现代码，第一个void *参数指代块，用于访问块对象所捕获的变量。此外descriptor变量指向结构体指针，每个块里都包含此结构体，其中声明了块对象的总大小和copy与dispose两个辅助函数的指针。</li>\n<li>根据内存位置分为全局块、栈块和堆块。</li>\n<li>栈块只在定义氛围有效，下述代码存在一个比较隐蔽的错误，存在危险：块的内存都分配在if及else范围内，在离开相应范围后如果编译器覆写了分配给块的内存则会导致crash，否则正常运行。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> (^block)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"comment\">/* some condition */</span>) &#123;</span><br><span class=\"line\">\tblock = ^&#123; <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"I am block A\"</span>); &#125;;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\tblock = ^&#123; <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"I am block B\"</span>); &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//解决方式：将块拷贝到堆中，成为堆块</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> (^block)();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"comment\">/* some condition */</span>) &#123;</span><br><span class=\"line\">\tblock = [^&#123; <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"I am block A\"</span>); &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">\tblock = [^&#123; <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"I am block B\"</span>); &#125; <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在全局范围声明的块及为全局块，其所使用的内存区域也在编译器全部确定。</li>\n</ol>\n<h4 id=\"第38条-为常用的块类型创建typedef\"><a href=\"#第38条-为常用的块类型创建typedef\" class=\"headerlink\" title=\"第38条 为常用的块类型创建typedef\"></a>第38条 为常用的块类型创建typedef</h4><ul>\n<li>以typedef重新定义块类型，可令块变量用起来更简单</li>\n<li>定义新类型时应遵循现有的命名习惯，勿使其名称与别的类型相冲突。</li>\n<li>可以为同一个块签名定义多个类型的别名，便于理解类型的用途。</li>\n</ul>\n<h4 id=\"第39条-用handler块降低代码分散程度\"><a href=\"#第39条-用handler块降低代码分散程度\" class=\"headerlink\" title=\"第39条 用handler块降低代码分散程度\"></a>第39条 用handler块降低代码分散程度</h4><ul>\n<li>异步任务执行完成之后，可使用委托协议或者内联块。相比于委托代理，块更为简洁和聚合。</li>\n<li>建议使用同一个块来处理成功与失败的情况。</li>\n<li>设计API时如果用的了handler块，可以增加一个参数，使调用者可通过此参数来决定块执行的队列。</li>\n</ul>\n<h4 id=\"第40条-用块引用其所属对象时不要出现保留环\"><a href=\"#第40条-用块引用其所属对象时不要出现保留环\" class=\"headerlink\" title=\"第40条 用块引用其所属对象时不要出现保留环\"></a>第40条 用块引用其所属对象时不要出现保留环</h4><ul>\n<li>如果块所捕获的对象直接或者间接地保留了块本身，那么得注意是否存在保留环的问题。</li>\n<li>一定要找个适当的时机解除保留环，而不能把责任推给API调用者。</li>\n<li>网络下载器可在任务启动时将自己加入全局的容器对象中，在任务结束后移除，从而保证自己在任务执行期间存活的同时不需要API调用方引用，大部分网络通信库都是采用这办法，如Twitter框架的TWRequest对象。</li>\n</ul>\n<h4 id=\"第41条-多用派发队列，少用同步锁\"><a href=\"#第41条-多用派发队列，少用同步锁\" class=\"headerlink\" title=\"第41条 多用派发队列，少用同步锁\"></a>第41条 多用派发队列，少用同步锁</h4><ul>\n<li>同步块@synchronized(obj)会根据给定对象自动创建一个锁，锁在代码块执行完成释放。由于给定对象相同，那么意味着它们使用的同一个锁，代码块需按顺序执行。如果在两个或多个没有逻辑关联的代码块给同一个对象加锁，会影响执行效率。</li>\n<li>滥用@synchronized(self)很危险，因为所有同步块都会彼此抢夺同一个锁。示例：使用@synchronized实现属性的原子性（atomic）：</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)someString &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> _someString;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSomeString:(<span class=\"built_in\">NSString</span> *)someString &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">\t\t_someString = someString;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有很多属性都是类似写法，那么每个属性的同步块都要等其他同步块执行完成才能执行。理想情况应该是属性各自独立地同步。</p>\n<ul>\n<li>使用GCD实现属性原子性：</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_syncQueue = dispatch_queue_create(<span class=\"string\">\"com.effectiveobjectivec.syncQueue\"</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">//同步队列+同步派发</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)someString &#123;</span><br><span class=\"line\">\t__block <span class=\"built_in\">NSString</span> *localSomeString;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;</span><br><span class=\"line\">\t\tlocalSomeString = _someString;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> localSomeString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//同步队列+同步派发</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSomeString:(<span class=\"built_in\">NSString</span> *)someString &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;  </span><br><span class=\"line\">\t\t_someString = someString;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD版本优化：设置方法不需要返回值，所以并不一定非得同步；获取方法可以并发执行，且设置方法与获取方法之间不能并执行。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">//异步队列+同步派发</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)someString &#123;</span><br><span class=\"line\">\t__block <span class=\"built_in\">NSString</span> *localSomeString;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;</span><br><span class=\"line\">\t\tlocalSomeString = _someString;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> localSomeString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//异步队列+异步派发（同步派发可能效率更高，原因在于异步派发需要拷贝块，如果拷贝时间超过代码执行时间，则得不偿失。异步派发适合较为复杂的任务）+栅栏块</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setSomeString:(<span class=\"built_in\">NSString</span> *)someString &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//栅栏块会单独执行，执行前会等待当前所有并发块执行完成，避免出现读写竞赛</span></span><br><span class=\"line\">\tdispatch_barrier_async(_syncQueue, ^&#123;  </span><br><span class=\"line\">\t\t_someString = someString;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第42条-多用GCD，少用performSelector系列方法\"><a href=\"#第42条-多用GCD，少用performSelector系列方法\" class=\"headerlink\" title=\"第42条 多用GCD，少用performSelector系列方法\"></a>第42条 多用GCD，少用performSelector系列方法</h4><ul>\n<li>performSelector系列方法在内存管理方面容易有疏忽，由于无法确认将要执行的选择子是什么，因而ARC编译器无法插入适当的内存管理方法。</li>\n<li>performSelector系列方法所能处理的选择子有局限性，选择子的参数个数与类型以及返回类型都受到限制。</li>\n</ul>\n<h4 id=\"第43条-掌握GCD及操作队列的使用时机\"><a href=\"#第43条-掌握GCD及操作队列的使用时机\" class=\"headerlink\" title=\"第43条 掌握GCD及操作队列的使用时机\"></a>第43条 掌握GCD及操作队列的使用时机</h4><ul>\n<li>对于只需要执行一次的代码来说，GCD的dispatch_once是首选，但是执行后台任务则可以考虑NSOperationQueue。</li>\n<li>在iOS4与Mac OSX 10.6开始，操作队列在底层是用GCD来实现的。</li>\n<li>GCD是纯C的API，任务使用轻量级数据结构块来表示；操作队列则是Objective-C的对象，采用更为重量级的NSOperation对象执行任务。</li>\n<li>使用操作队列的优势：<ul>\n<li>可取消还未启动的任务</li>\n<li>可指定操作间的依赖关系</li>\n<li>可通过键值观测机制监控NSOperation对象的属性</li>\n<li>可指定操作的优先级，而GCD只能指定队列的优先级</li>\n<li>可重用NSOperation对象</li>\n</ul>\n</li>\n<li>是否使用底层实现方案还是高层API，可通过实际性能测试来确定。</li>\n</ul>\n<h4 id=\"第44条-通过Dispatch-Group机制，根据系统资源状况来执行任务\"><a href=\"#第44条-通过Dispatch-Group机制，根据系统资源状况来执行任务\" class=\"headerlink\" title=\"第44条 通过Dispatch Group机制，根据系统资源状况来执行任务\"></a>第44条 通过Dispatch Group机制，根据系统资源状况来执行任务</h4><ul>\n<li>一系列的任务可归入一个dispatch group中，开发者可以在所有任务完成后获得通知</li>\n<li>利用dispatch group并发地执行多项任务。</li>\n<li>dispatch_apply是持续阻塞的，直到所有任务都执行完成。</li>\n</ul>\n<h4 id=\"第45条-使用dispatch-once来执行只需要运行一次的线程安全代码\"><a href=\"#第45条-使用dispatch-once来执行只需要运行一次的线程安全代码\" class=\"headerlink\" title=\"第45条 使用dispatch_once来执行只需要运行一次的线程安全代码\"></a>第45条 使用dispatch_once来执行只需要运行一次的线程安全代码</h4><ul>\n<li>dispatch_once采用“原子访问”来判断块中的代码是否已经执行过，而非使用重量级的同步机制，相比于@sychronized更为高效，如果想了解@synchronized的实现机制可以看看<a href=\"http://icebergcwp.com/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html\">这篇博客</a>。</li>\n<li>标记dispatch_once_t应该声明为static，确保每次调用都复用同一个变量。</li>\n</ul>\n<h4 id=\"第46条-不要使用dispatch-get-current-queue\"><a href=\"#第46条-不要使用dispatch-get-current-queue\" class=\"headerlink\" title=\"第46条 不要使用dispatch_get_current_queue\"></a>第46条 不要使用dispatch_get_current_queue</h4><ul>\n<li>dispatch_get_current_queue已被废弃，只应做调试使用</li>\n<li>派发队列是按层级来组织的，子队列是包含于父队列的，所以无法单用某个队列对象来描述“当前队列”这一概念</li>\n<li>dispatch_get_current_queue用于解决由不可重入代码所引发的死锁，可以使用“队列特定数据”来解决：dispatch_queue_set_specific(dispatch_queue_t queue,const void *key, void *context, dispatch_function_t destructor);</li>\n</ul>\n<h3 id=\"第7章-系统框架\"><a href=\"#第7章-系统框架\" class=\"headerlink\" title=\"第7章 系统框架\"></a>第7章 系统框架</h3><ul>\n<li>标准根类NSObject属于Foundation框架，而非语言本身。如果不适应Foundation框架，则需要自己实现根类</li>\n</ul>\n<h4 id=\"第47条-熟悉系统框架\"><a href=\"#第47条-熟悉系统框架\" class=\"headerlink\" title=\"第47条 熟悉系统框架\"></a>第47条 熟悉系统框架</h4><ul>\n<li>在众多框架中，Foundation和CoreFoundation这两个框架最为重要，提供了许多核心功能</li>\n<li>Objective-C编程经常会使用纯C实现的框架，比如CoreFoundation，里面用到底层C语言级API，这样可以绕过运行时系统，提升速度，但是需要手动管理内存。</li>\n</ul>\n<h4 id=\"第48条-多用块枚举，少用for循环\"><a href=\"#第48条-多用块枚举，少用for循环\" class=\"headerlink\" title=\"第48条 多用块枚举，少用for循环\"></a>第48条 多用块枚举，少用for循环</h4><ul>\n<li>遍历collection有四种方式。最基础的是for循环，其次是NSEnumerator遍历和NSFastEnumeration协议下的快速遍历，最快、最先进的方式是“块枚举发”</li>\n<li>“块枚举法”本身能够通过GCD来并发执行遍历，无须另行代码，其他遍历方式则不能做到这一点</li>\n<li>如果提前知道遍历collection中的对象，应修改块签名，指出对象的具体对象。</li>\n</ul>\n<h4 id=\"第49条-对自定义其内存管理语义的collection使用无缝桥接\"><a href=\"#第49条-对自定义其内存管理语义的collection使用无缝桥接\" class=\"headerlink\" title=\"第49条 对自定义其内存管理语义的collection使用无缝桥接\"></a>第49条 对自定义其内存管理语义的collection使用无缝桥接</h4><ul>\n<li>Foundation框架中的collection类都有与之对应的CoreFoundation框架版的C语言API</li>\n<li>桥接符号<strong>bridge表示ARC保留对Objective对象的所有权，而</strong>bridge__retain则刚好相反，需要使用CFRelease释放内存。</li>\n<li>使用CoreFoundation框架可以创建出Foundation框架所不具备的功能，比如NSDictionary的键值内存管理语义是“copy”，即键值必须支持Copying协议，使用CoreFoundaition创建一个键值内存管理语义为“Retain”的CFDictionary。</li>\n</ul>\n<h4 id=\"第50条-构建缓存时选用NSCache而非NSDictionary\"><a href=\"#第50条-构建缓存时选用NSCache而非NSDictionary\" class=\"headerlink\" title=\"第50条 构建缓存时选用NSCache而非NSDictionary\"></a>第50条 构建缓存时选用NSCache而非NSDictionary</h4><ul>\n<li>实现缓存时应选NSCache而非NSDictionary对象。NSCache提供了优雅的自动删减功能，而且线程安全。此外，它与字典不同，不会拷贝键值，而是retain一次。</li>\n<li>可以给Cache对象设置上限：缓存对象总个数和缓存总大小，这些设置定义了缓存删减其中对象的时机。但是这些设置仅对Cache起指导作用，并非一定在系统资源紧张时删减Cache中的某个对象，因此不能通过设置上限来迫使Cache优先删减某个对象。</li>\n<li>将NSPurgeableData与NSCache搭配使用，可实现自动清除数据功能，也就是说当NSPurgeableData对象所占内存被系统丢弃时，对象也会从缓存中移除。</li>\n<li>缓存的设计初衷是为了提高响应速度，只有那些“重新计算起来费劲”的数据才值得放入缓存，比如网络获取或者磁盘读取的数据。     </li>\n</ul>\n<h4 id=\"第51条-精简-initialize与-load的实现代码\"><a href=\"#第51条-精简-initialize与-load的实现代码\" class=\"headerlink\" title=\"第51条 精简+initialize与+load的实现代码\"></a>第51条 精简+initialize与+load的实现代码</h4><ul>\n<li>在加载过程中，如果类实现了+load方法，那么系统会通过函数指针调用+load。调用顺序是父类-&gt;子类-&gt;分类。因为程序加载时是使用函数指针调用而非消息机制，所以分类中的+load不会覆盖子类中的+load方法。         </li>\n<li>程序启动时，运行期处于“脆弱状态（fragile state）”，如果+load方法中使用了其他非系统库（系统库的类在这之前已经加载好了）的类，那么这些类的+load方法也在此时被调用。如果子类没有实现+load方法，那么各级超类是否实现此方法都不被系统调用。</li>\n<li>+load方法务必实现的精简一些，因为整个程序在+load方法时都会阻塞。其真正的用途在于调试程序。</li>\n<li>+initialize方法会在程序首次调用该类之前调用，只调用一次，如果某个类未被使用，那么其+initialize方法一直不会被调用。</li>\n<li>+initialize方法被调用时，运行期系统已经处于正常状态，理论上可以在其中调用任何类的任意公开方法，且是线程安全的。</li>\n<li>+initialize方法与其他消息一样，如果子类未实现它而其超类实现了，那么会子类也会调用一次超类的实现方法。 </li>\n<li>无法再编译器设定的全局变量，可以放在+initilize方法中初始化。  </li>\n</ul>\n<h4 id=\"第52条-别忘了NSTimer会保留其目标对象\"><a href=\"#第52条-别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"第52条 别忘了NSTimer会保留其目标对象\"></a>第52条 别忘了NSTimer会保留其目标对象</h4><ul>\n<li>NSTimer对象会保留其目标，知道计时器调用invalidate方法后失效为止。另外，一次性的计数器在触发任务后就会立即失效。</li>\n<li>反复执行任务的计时器，很容易引入保留环，可通过扩充NSTimer功能，用块来打破保留环。代码如下：</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">ECOBlocksSupport</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)eoc_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimerInterval</span>)interval  block:(<span class=\"keyword\">void</span>(^)())block repeats:(<span class=\"built_in\">BOOL</span>)repeats;</span><br><span class=\"line\">+ </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">ECOBlocksSupport</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)eoc_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimerInterval</span>)interval  block:(<span class=\"keyword\">void</span>(^)())block repeats:(<span class=\"built_in\">BOOL</span>)repeats &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> scheduledTimerWithTimerInterval:interval target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(eoc_blockInvoke:) userInfo:[block <span class=\"keyword\">copy</span>] repeats:repeats];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)eco_blockInvoke:(<span class=\"built_in\">NSTimer</span> *)timer &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>(^block)() = timer.userInfo;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (block) &#123;</span><br><span class=\"line\">\t\tblock();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\">```                    </span><br><span class=\"line\">这个方法仍然存在保留环，计时器现在的target是<span class=\"built_in\">NSTimer</span>类对象，但是因为类对象无需回收，所以不用担心。</span><br><span class=\"line\"></span><br><span class=\"line\">* 上述方法本身不能解决问题，但是提供了解决问题的工具。使用分类中的eoc_scheduledTimerWithTimeInterval来创建计时器：</span><br><span class=\"line\"></span><br><span class=\"line\">```objc</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startPolling &#123;</span><br><span class=\"line\">\t__<span class=\"keyword\">weak</span> type(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">\t_pollTimer = [<span class=\"built_in\">NSTimer</span> eoc_scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> block:^&#123; </span><br><span class=\"line\">\tEOCClass *strongSelf = weakSelf;</span><br><span class=\"line\">\t[strongSelf p_doPoll]; </span><br><span class=\"line\">\t&#125; repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["专业"],"tags":["Objective-C","读书笔记"]},{"title":"人类简史第一部分认知革命读书笔记","url":"http://icebergcwp.com/人类简史第一部分读书笔记.html","content":"<h4 id=\"人类：只是一种普通的动物\"><a href=\"#人类：只是一种普通的动物\" class=\"headerlink\" title=\"人类：只是一种普通的动物\"></a>人类：只是一种普通的动物</h4><p>一直以来，我和很多人一样以为地球同一时期只有一种人类且是独特于其他的物种之外的特殊物种，不然怎么会站在了食物链的顶端。现在我才知道这种想法是错误的，其实我们现代人即智人（human sepiens）只是人属的一种，就像豹属包括狮子，豹子等。人属也包括多个物种，只是现存的人种只有智人，就容易让人造成智人是唯一人种的假象。</p>\n<p>早在250万年前人类开始由猿属中的南方古猿开始演化，人类的足迹在200万年前开始从东非欧亚大陆扩散，结合当地的环境各自演化出不同的人种，有匠人、鲁道夫人、尼安德特人、直立人、梭罗人等等。这些人分别先后出现，并在某一段时间同时存在地球的不同地方。其中，直立人出现时间是200万年前到5万年前，存活了将近200万年，是目前所知存续时间最长的人类物种，目前地球上唯一的人种智人已知的是大约15万年前在非洲出现，具体何时、有何种早期人类演化而来无从得知，就目前的发展来看是很难打破直立人存续的记录了。此外，这些人种的演化并不是呈线性发展的，这些人种在大约200万年前到大约一万年前之间同时存在世界各地，各种进化或灭亡，直到一万年前左右，仅剩下智人一种人类。</p>\n<p>人类比其他物种有一个共同特征就是脑容量大。然而庞大的大脑也是庞大的负担，大脑不仅结构脆弱且消耗能量巨大，占身体体重约2%~3%却消耗能量占25%。时至今日，大脑发达带来的好处显而易见，但是远古人类为此付出一定的代价，主要包括两种：一是人类需要更多的食物满足热量需求，其次就是为了保证大脑能量供需导致肌肉退化萎缩。至于为什么人类大脑会在200万年间不断演化，无从得知。</p>\n<p>人类另外一个共同特征就是直立行走，直立行走将手从移动的功能中分离出来，着重神经发展，进一步演化成可以处理精细任务。与此同时，直立行走也有不利之处。直立行走意味着脊椎需要支撑一个超大的头盖骨，为此需要面对背痛与颈椎脖子疾病。特别对妇女造成的负担更大，直立行走需要让臀部变窄，然而根据人类演化趋势，婴儿的头越来越大，从而导致分娩风险增高。于是，根据自然选择的原理，在婴儿还尚未完全发育之前分娩，这时候头部毕竟小且柔软，风险也会降低很多。所以，相对于其他物种，人类都是早产儿，许多重要的器官都未发育完善，出生之后需要母亲的悉心呵护与培养。这也是导致人类发展出突出的社交技巧的原因之一。正因为小孩出生后需要长时间的抚养，作为母亲必须依赖于家族部落的协助才能获得足够的食物，为此需要一种能够形成强大的社会关系的能力。此外，人类出生后的发育不完善也意味着更好的可塑性，需要外界的教育，这也依托于强大的社会化的背景。正因如此，人类的性格、信仰和价值观等观念才会各种各异，才有基督徒或佛教徒，自由主义者或民族主义者，好战派或和平派。</p>\n<p>尽管人类拥有超强的大脑，但是在过去的200万年前，人类一直都是一种弱小、边缘化的物种。直到10万年前，智人这一人类物种崛起，一跃而居于食物链的顶端才结束弱者的命运。然而，这次仓促的跳跃对整个生物链造成了巨大的影响。在此之前其他处于食物链顶端的物种都是经过好几百万年的进化才站上了顶峰，因此生态系统有足够的时间协调各物种之间的平衡。相比之下，智人在很短的时间内一步青云，让生态系统猝不及防，人类本身也不知所措，为此付出的代价就是人类史上众多的灾难。</p>\n<p>在人类踏上食物链顶端的路上，火的使用功不可没。早在80万年前部分人类偶然的机会学会使用火，到了30万年前直立人、尼安德特人以及智人的祖先已经能够熟练的使用火。火之于人类有两大主要好处：一是烹饪食物，烹饪食物不仅扩大了食物来源，使原本不可直接使用的食物，比如小麦、马铃薯等食物再烹饪供人类使用。此外烹饪让食物发生化学反应，同时对食物进行高温消毒，大大地减少了人类咀嚼与消化食物的时间。这样不仅让人类的牙齿缩小，肠道缩短，还能提供更多的热量供大脑发育。第二个好处是火可以成为御敌的工具，不同于其他动物经过数百万年进化而来的利爪或翅膀，这些功能都无法突破先天的身体限制，而火是一种可操作且力量无穷的工具，为人类更好的存续提供了保障。</p>\n<p>在200万年前~1万年前，地球上的还存在多个人类物种，但是随着智人的出现以及扩散，其他物种先后走上了灭绝的道路。每当智人到达某个地方，当地原本的人种就在不久之后消失了。究其原因，有两种大相径庭的理论。一是“混种繁衍理论”，即智人与其他人种混种繁衍，最终形成了现代的人类。另外一种则是“替代理论”，即不同物种之间处于争夺资源与排外的情绪，互相厮杀，最终智人取得了胜利，替代了原有人类。最近数十年，替代理论一直是大致共识，不仅因为有考古证据支持，政治上也更为正确。如果非洲人、欧洲人和亚洲人是智人与不同人类物种的混种后代，那么基因上的差异也会很大，那么在政治、民族等多个方面的理解也会存在差异，从而导致种族间的大冲突，然而现实情况并非如此。然而，混种繁衍理论也并非没有可能。最近的一些研究发现中东和欧洲人有%1~%4尼安德特人的基因，澳大利亚原住民和现代美拉尼西亚人有6%的丹尼索瓦人的基因。如果这些发现属实，则说明混种繁衍理论至少是部分正确，有可能在某个时间点，不同人种还属于同一人种的不同族群，即使族群差异到了一定程度，但是仍然可以交配产下后代，再经过进一步演化才彻底切断彼此连接，形成两种不同的物种，也就不能再混种繁衍了。也许在物种分化的某个灰色地带，尼安德特人与智人在即将演化成两个不同的物种之前发生了混种繁衍，并产生了新的人类，导致智人的基因中残存着尼安德特人的DNA。</p>\n<p>按照自然选择的规律来说，尼安德特人比智人进化的更完善，有更大的大脑和更发达的肌肉。但是结果却是智人存活了下来，而尼安德特人在地球消失了。智人最终成为最后的人类，战胜了其他人类物种的真实原因不得而知，但是有一个很有说服力的解答，那就是：智人有独特的语言。</p>\n<h4 id=\"知善恶树\"><a href=\"#知善恶树\" class=\"headerlink\" title=\"知善恶树\"></a>知善恶树</h4><p>在距今7万~3万年前，智人发生了认知革命，具体原因不得而知，普遍认为是某次基因突变，改变智人大脑内部连接方式，从而改变了智人的思维方式与沟通语言能力。智人的语言并不是世界上第一种语言，每种动物都有其交流的语言，并且有其精密复杂的结构。然而，智人的语言较于其他动物的语言，它更为灵活，通过有限的词汇排列组合，可以产生无限多的句子和含义，从而大幅度提高了交流的效率。另外智人的语言有“八卦”和“虚构”的功能。</p>\n<p>智人可以通过“八卦”功能让部落规模变得更大。在一般的动物族群里，成员数量一般在20~50左右。族群的团结依赖于首领的管理与威望。一旦族群扩大，族群内部就会发生动摇，最后造成分列。即便如此，八卦维系的规模也是有限制。社会研究学家指出，借由八卦维持的最大“自然”团体一般是150人。原因在于超过这个数之后，团体之间就不能深入了解和八卦彼此的生活情况。然而，事实是智人突破了这个界限，创造出了城市、国家等这些有成千上万成员的团体。其原因很可能在于智人的语言的“虚构”功能，能够虚构一些现实中不存在的事物，“虚构”这一功能不仅可以让智人拥有想象，更重要的意义在于可以让大家一起想象，共同相信某个虚构的事物，从而可以共同合作。现实生活中，很多的概念都是虚构的，包括国家，民族，宗教，金钱，法律，人权，正义等等。只是我们现代人从出生就接触这些概念，根本没怀疑它们的真实性，更不会发觉它们只是存在我们共同的想象之中。</p>\n<p>在没有发生认知革命之前，智人和其他具有社会行为的动物一样，行为有相当的程度是有基因决定的。因此，一旦出现社会结构改变、发明新科技或者移居都是因为基因突变或者环境改变导致的。正因如此，远古人类没有什么革命性的改变。然而，智人出现认知革命之后，可以基于某个虚构的故事让大批互不相识的人有效的进行合作，而且只要改变虚构故事的内容，合作的方式也随之改变。这意味着智人找到了一条绕开基于组的快车道，可以迅速改变社会结构和发展速度。</p>\n<p>认知革命通过虚构故事创造了很多想象现实，也发展处许多的行为模式，这成为我们所谓的“文化”的主要成分。文化出现之后，无法停止地继续改变和发展，就成了我们所谓的“历史”。认知革命正是历史从生物学中脱离而独立存在的起点。在此之前，所有人类的行为属于生物学的范畴，因为都是有基因主导的。换言之，智人生存在一个双重现实的社会中，一方面是客观存在的现实，即生物的范畴，另外一方面的虚构的现实，即历史和文化的范畴。生物学与历史的关系可以简化为三点：<br>1、基本上，生物学为智人的行为和能力设下了基本限制，设定了一个活动范围，所有的历史都在这个范围之内发生。</p>\n<p>2、然而，这个范围非常大，能让智人有各种惊人的发挥空间，让虚构故事的能力和虚构的故事不断发展精进。</p>\n<p>3、想了解智人的行为，就必须描述人类行为的历史演化，而不能只考虑人类在生物上的限制。</p>\n<p>智人通过认知革命发展出独特的语言，无异于获得了《圣经》里面那个知善恶树的果实，从此改变了智人的命运，智人摇身一变成为了亚丹和夏娃。</p>\n<h4 id=\"亚丹和夏娃一天\"><a href=\"#亚丹和夏娃一天\" class=\"headerlink\" title=\"亚丹和夏娃一天\"></a>亚丹和夏娃一天</h4><p>在智人的历史上，绝大多数时间都是靠采集为生。相比于几万年时长的采集生活，智人已知或者现存的生活方式不足以改变人类的思维方式。换言之，现代人类早在农业时代之前的采集时代就开始塑形，我们的大脑和内心的思维方式仍停留在以狩猎和采集的时代。农业革命之后，人类大脑的进化速度远不及周围生活环境的发展速度，造成了一种物质世界与内心世界脱轨的普遍现象。</p>\n<p>这种现象影响这现代人生活的方方面面，狩猎采集时代的思维方式深植于我们的潜意识中。其中包括是已经得到广泛接受的“贪吃基因”理论和颇具争议的“一夫一妻制”。远古人类在那个甜食匮乏的时代为了获得更多的热量会偏爱高热量的甜食，导致物质丰富的现代人不知觉地喜爱甜食，造成肥胖等疾病。</p>\n<p>因此，想要更好地了解我们自己、我们的社会和政治，就需要更了解我们祖先的生活条件。然而，我们对于采集者祖先的生活几乎没有可以确定的事实。目前普遍的研究方法有两种，一是考古学研究，通过远古社会遗存的文物进行推断。然而远古的狩猎采集生活用具保存下来的大都是骨骼化石和石器，其他容易腐烂的材料都无从考证，另外远古人类没有固定的生活居住地，而是不断的迁移，所以很少使用人造物品。因此，通过现存文物来还原远古人类的生活必定会有偏差；另外一种研究方式是人类学观察，通过研究现存的采集社会来推测远古采集社会的样貌。首先，现存采集社会多少已经受到周围的农业或者工业社会影响，不可同日而语。其次，现存的采集社会之所以能够存活到现在，是因为它们都位于气候恶劣或者地形险峻的地区，从而逃避了农业与工业社会的侵蚀，这与远古富饶地区的采集社会不论在人口规模和生活方式上都存在差异。再者，狩猎采集社会最显著的特点就是它们彼此之间的差异很大，各有特色。因此，通过人类学方式观察现存的采集社会只能帮助我们了解部分远古采集社会的可能性，而非全貌。</p>\n<p>根据现有的证据，我们对远古采集社会虽然只有管中窥豹的认识，但是也能获得一些可靠的推断。首先，他们大部分人都是生活在小部落里面，且所以成员都是人类，而不同于农工社会中，存在家禽家畜的数量超过人类的社会群体。远古采集社会没有家禽家畜，但是有狗的存在，狗是第一种由智人驯化的动物，狗与人类的感情远超过人类与其他动物之间的感情。此外，同属一个部落的成员彼此熟悉，终其一生都生活在一起，没有孤单和隐私。不同的智人部落之间偶尔会有交流与交换物品，大多数时间都是互相独立，各行其是。大多数智人部落都是处于不断迁移的状态，只有很少的部落在食物富饶的地区会选择永久定居。远古智人部落与农业革命以后的人类的生活方式的差异主要有以下几点：<br>1、远古智人有着多样化的饮食结构，不依赖单一的某种食物，饮食结构更灵活，相比之下我们的饮食显得单一固定，容易受自然灾害影响；<br>2、整体而言，现代人类的知识范围远超远古人类，但是个人层面，远古智人是有史以来具备最多知识与生存技能的人类；<br>3、狩猎采集的生活方式更为轻松与舒适，不像现代人那样忙碌；<br>4、远古智人没有像现代人那样饱受传染病的困扰，原因在于多数传染病都是来自家禽家畜，采集社会只有狗是唯一会和人类近距离接触的动物。另外，采集社会人口密度小且分散，疾病不易传播流行。</p>\n<p>正因为远古采集者有着比现代人更健康和多样的饮食结构，更短的工作时间，更少的传染病困扰。因此被定义为“最初的富裕社会”。但是这并不表示远古采集社会是理想与美好的，它们同样存在着残酷的一面，存在物资匮乏、族群相杀、时节难过以及儿童死亡率高等问题。有时候，他们会杀害儿童、病人和老人，但是他们的想法其实和现在许多人赞同堕胎和安乐死没有区别。远古的狩猎采集者和我们一样，都是人类。</p>\n<p>除了生活方式与环境上的差别，远古采集者的心理和精神世界又是如何？多数学者都同意，远古采集者普遍信奉泛神论的信仰（animism，源自拉丁文anima，意为灵魂或精神）。泛神论相信，几乎任何一个地点、任何一只动物或植物、任何一种自然现象，都有其意识和情感，并且与人类之间没有障碍，可以直接通过语言、歌曲、舞蹈和仪式沟通。泛神论的一个特点在于所有的灵都只限于当场当地，某个具体的事物，而非万能的神。泛神论不是特定的宗教，而是数千种不同宗教、邪教或信仰的统称，这些宗教对于世界的看法、对于人类的定位都大同小异。然而，远古采集者是否一定都是泛神论我们无从得知。此外，采集社会是否存在政治，这一点也无法确定。尽管有考古发现一些具有“阶级”意味的表象，虽然具体原因不得而知，但是仍能说明3万年前的智人已经发明了一些社会政治规范，不仅超出了DNA的设定，也超越了其他人类和动物的行为模式。</p>\n<p>最后，“战争”在远古采集社会扮演什么样的角色？有学者认为战争是出现在农业革命之后，伴随着私有财产而生。而另外一种主张则认为采集社会已经有各种残忍的暴力事件。然而不管是通过考古学研究还是人类观察学推测，都是无法还原远古采集社会的真实面貌，所以不能一概而论。采集社会可能有许多不同的宗教和社会结构，不同的地区和不同时段的生活情况也大相径庭，或存在暴力或平静祥和。</p>\n<p>由于证据的缺乏，远古采集社会的很多事情都无法确定，我们也就无法重建出一副当时的宏观景象，更不用说重塑特定的事件。关于远古采集社会的很多问题，我们都只能沉默以对。这幅沉默的帷幕笼罩了几万年的人类历史，也许会一直尘封，也许未来出现新的研究工具可以揭开这幅厚重的帷幕。我也不能因为对远古采集社会知之甚少便否定远古智人对人类历史的贡献，不能对于7万年人类历史中的六年视而不见。他们做了很多重要的事情，特别是形塑了我们现有的世界，程度之大出乎意料，他们的足迹早已遍布全世界。整个动物界从古至今，最重要也是最具破坏性的力量，就是这群四处游荡、讲着故事的智人。</p>\n<h4 id=\"毁天灭地的人类洪水\"><a href=\"#毁天灭地的人类洪水\" class=\"headerlink\" title=\"毁天灭地的人类洪水\"></a>毁天灭地的人类洪水</h4><p>在认知革命前，所有的人类物种都只住在亚非大陆。那时候地球不同的洲都有自己独特的生态系统和物种，但是随着智人在认知革命之后掌握了航海技术，智人的足迹开始遍布全球各地，对当地的生态与物种来说是致命的灾难，很多物种遭受灭绝，智人就如同毁天灭地的洪水一般“征服”全球。其中，澳洲大陆与美洲大陆都是血淋淋的例子。</p>\n<p>大约在45000年前，智人首次抵达与亚非大陆相遇深远且隔海相望的澳洲大陆绝对是一件跨时代的大事，重要性不亚于哥伦布发现美洲大陆或是人类首次登月。这意味着海洋这个阻挡智人扩张最大的障碍也被征服了。随着智人来到澳洲大陆的那一刻起，曾经在这块土地生活了数万年甚至上百万年的物种都消失殆尽。其中澳大利亚当时24中50公斤以上的动物有23中都惨遭灭绝，许多比较小的物种也从此消失，整个澳大利亚的生态系统食物链重新洗牌，这也是澳大利亚生态系统数百万年来最重大的一次转型。</p>\n<p>有些学者试着以气候变迁为借口为人类脱罪，然而有三大证据显示智人难辞其咎。</p>\n<p>证据一：虽然澳大利亚气候确实在45000年前有一场改变，但是规模幅度不大。更何况在此之前，地球早就经历过许多次更为严重的冷却和暖化循环，在过去百万年间，平均每10万年就有一场冰河时期。换句话说，澳大利亚上的物种在45000年前早就经历过多次气候变迁，并且大多数都存活下来了。然后，45000年以后，全澳大利亚超过90%的巨型动物都从历史消失。如果说智人所有的巨型动物都恰巧死于严寒之后来到澳大利亚，实在很难令人信服。</p>\n<p>证据二：如果是气候变迁导致物种灭绝，那么海洋生物受到的冲击通常不亚于陆地生物。然而，我们没有找到任何证据显示在45000年前海洋生物有显著的灭绝情形。如果假设智人的罪魁祸首，那么也很容易解释这波灭绝浪潮只席卷了陆地生物，而放过了附近的海洋生物。因为那时候智人虽然航海技术有大幅度提升，但是人类毕竟还是主要生活在陆地。</p>\n<p>证据三：类似澳大利亚这种物质大面积灭绝的案例在接下来的几千年在不同的地点不断上演，而时间点都是在人类首次抵达的时候。</p>\n<p>通过上面列出的三个证据，智人对与类似澳大利亚这样物种大灭绝的惨案的频繁上演难辞其咎。当时智人的生活与狩猎工具还是以石器为主，那么他们是如何主导这次生态浩劫的？以下有三种解释：</p>\n<p>第一种解释：一般来说大型动物繁殖缓慢，孕期长，胎数少，怀孕周期长。因此就算智人猎杀不频繁，也可能会导致某个物种的死亡率高于出生率，最后导致这个物种的灭绝。</p>\n<p>第二种解释：认为智人抵达澳大利亚的时候已经掌握了火耕技术。面对陌生而危险的环境，他们会刻意地烧毁难以跨越的森林，将地貌变成开阔的草原以适合人类的需求。他们在短短的几千年就彻底改变了澳大利亚大部分地区的生态系统。这种说法有植物化石记录为佐证。在45000年前，桉属植物在澳大利亚只是少数，智人的到来开创了桉属植物的黄金时代，因为桉属植物特别耐火。</p>\n<p>第三种解释：这种解释不排除智人狩猎与火耕有显著影响，但是强调不能忽视气候因素。45000年前的气候变迁让澳大利亚的整个生态系统失衡，变得特别脆弱。正常情况下，系统会慢慢调整并适应恢复。智人在这个时候到来，将已经脆弱的生态系统推进了无底深渊。</p>\n<p>与澳大利亚类似的还有美洲大陆，大约在14000年前，智人通过当时西伯利亚与阿拉斯加相连的陆地抵达美洲大陆。在此之前，美洲大陆的物种远比今天丰富，各种在亚非大陆未曾得见的物种都在此繁衍茁壮。然而在人类抵达后的两千年内，大多数独特物种都惨遭毒手。</p>\n<p>回归智人历史，第一波物种灭绝浪潮是由于智人的扩张，第二波物种浪潮是因为农业革命，现在我们正面临第三波物种灭绝的浪潮：由工业革命所造成的物种灭绝。有些环保人士声称我们的祖先智人总是和自然和谐相处，殊不知智人就是造成最多动植物灭绝的元凶。也许，这场人类洪水的唯一幸存者可能只剩下人类自己，其他登上诺亚方舟的也只可能是作为人类盘中佳肴的家禽家畜罢了。</p>\n<p><div align=\"center\"><br><a href=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/ABriefHistoryOfHumankind-OnePart.png\" target=\"_blank\" rel=\"noopener\">思维导图</a></div></p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/ABriefHistoryOfHumankind-OnePart.png\" alt=\"思维导图\"></p>\n","categories":["读书笔记"],"tags":["人类简史"]},{"title":"剖析@synchronizd底层实现原理","url":"http://icebergcwp.com/剖析@synchronized底层实现.html","content":"<p>@synchronizd是Objective-C中的一个语法糖，用于给某个对象加锁，因为使用起来简单方便，所以使用频率很高。然而，滥用@synchronizd很容易导致代码效率低下。本篇博客旨在结合@synchronizd底层实现源码并剖析其实现原理，这样可以更好的让我们在适合的情景使用@synchronizd。</p>\n<p>@synchronizd本质上是一个编译器标识符，在Objective-C层面看不其任何信息。因此可以通过clang -rewrite-objc指令来获得@synchronizd的C++实现代码。示例代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *obj = <span class=\"string\">@\"Iceberg\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">@synchronized</span>(obj) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Hello,world! =&gt; %@\"</span> , obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *obj = (NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id _rethrow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        id _sync_obj = (id)obj;</span><br><span class=\"line\">        objc_sync_enter(_sync_obj);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t            <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">SYNC_EXIT</span> &#123;</span></span><br><span class=\"line\">\t                _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125;</span><br><span class=\"line\">\t                ~_SYNC_EXIT() &#123;</span><br><span class=\"line\">\t                    objc_sync_exit(sync_exit);</span><br><span class=\"line\">\t                &#125;</span><br><span class=\"line\">\t                id sync_exit;</span><br><span class=\"line\">\t            &#125; _sync_exit(_sync_obj);</span><br><span class=\"line\"></span><br><span class=\"line\">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_1 , obj);</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (id e) &#123;</span><br><span class=\"line\">                _rethrow = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">FIN</span> &#123;</span></span><br><span class=\"line\">                _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class=\"line\">                ~_FIN() &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (rethrow)</span><br><span class=\"line\">                        objc_exception_throw(rethrow);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                id rethrow;</span><br><span class=\"line\">            &#125; _fin_force_rethow(_rethrow);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过分析C++代码可以看到@sychronized的实现主要依赖于两个函数：objc_sync_enter和objc_sync_exit。此外还有try{}catch{}语句用于捕捉@sychronized{}语法块中代码执行过程中出现的异常。</p>\n<p>我们发现objc_sync_enter函数是在try语句之前调用，参数为需要加锁的对象。因为C++中没有try{}catch{}finally{}语句，所以不能在finally{}调用objc_sync_exit函数。因此objc_sync_exit是在_SYNC_EXIT结构体中的析构函数中调用，参数同样是当前加锁的对象。这个设计很巧妙，原因在_SYNC_EXIT结构体类型的_sync_exit是一个局部变量，生命周期为try{}语句块，其中包含了@sychronized{}代码需要执行的代码，在代码完成后，_sync_exit局部变量出栈释放，随即调用其析构函数，进而调用objc_sync_exit函数。即使try{}语句块中的代码执行过程中出现异常，跳转到catch{}语句，局部变量_sync_exit同样会被释放，完美的模拟了finally的功能。</p>\n<p>接下来，在<a href=\"https://github.com/opensource-apple/objc4/blob/master/runtime/objc-sync.mm\" target=\"_blank\" rel=\"noopener\">苹果公开的源代码文件objc-sync.mm</a>中找到objc_sync_enter和objc_sync_exit这两个函数的实现，一窥其中的奥秘。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SyncData</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SyncData</span>* <span class=\"title\">nextData</span>;</span></span><br><span class=\"line\">    DisguisedPtr&lt;objc_object&gt; object; <span class=\"comment\">//当前加锁的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> threadCount;  <span class=\"comment\">//使用对object加锁的线程个数</span></span><br><span class=\"line\">    <span class=\"keyword\">recursive_mutex_t</span> mutex; <span class=\"comment\">//递归互斥锁</span></span><br><span class=\"line\">&#125; SyncData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    SyncData *data;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> lockCount;  <span class=\"comment\">//表示当前线程对object对象加锁次数</span></span><br><span class=\"line\">&#125; SyncCacheItem;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SyncCache</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> allocated;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> used;</span><br><span class=\"line\">    SyncCacheItem <span class=\"built_in\">list</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125; SyncCache;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  Fast cache: two fixed pthread keys store a single SyncCacheItem. </span></span><br><span class=\"line\"><span class=\"comment\">  This avoids malloc of the SyncCache for threads that only synchronize </span></span><br><span class=\"line\"><span class=\"comment\">  a single object at a time.</span></span><br><span class=\"line\"><span class=\"comment\">  SYNC_DATA_DIRECT_KEY  == SyncCacheItem.data</span></span><br><span class=\"line\"><span class=\"comment\">  SYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SyncList</span> &#123;</span></span><br><span class=\"line\">    SyncData *data;</span><br><span class=\"line\">    <span class=\"keyword\">spinlock_t</span> lock;</span><br><span class=\"line\"></span><br><span class=\"line\">    SyncList() : data(nil) &#123; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></table></figure>\n<p>上述代码是一些相关的数据结构，下面分别进行介绍：</p>\n<p>SyncData结构体中有四个成员变量，其中object指针变量指向当前加锁对象，threadCount表示对object加锁的线程个数，mutex是一个递归互斥锁，意味着可以对object进行多次加锁，其具体作用后面会提到。</p>\n<p>SyncCacheItem结构体中有两个成员变量，其中data是SyncData结构体类型的指针，lockCount表示当前线程对当前结构体对象加锁次数，其实就是对加锁对象object的加锁次数。我们可以看到SyncCacheItem与SyncData是一对一关系，SyncCacheItem只是对SyncData进行了再次封装以便于缓存，具体使用见后文。</p>\n<p>SyncCache结构体中有三个成员变量，其中维护了一个SyncCacheItem类型的数组，allocated和used则分别表示当前分配的SyncCacheItem数组中的总个数和已经使用的个数。这个结构体与线程是一对一的关系，用于存储当前线程已加锁对象对应的SyncCacheItem结构体，因为一个线程可以对同一个对象多次加锁，所以通过引入缓存SyncCache可以提高效率，具体使用见后文。</p>\n<p>SyncList结构体中有两个成员变量和一个构造函数，其中data是SyncData结构体类型的指针，lock是一个自旋锁。</p>\n<p>sDataLists是一个全局StripedMap哈希列表，其中value为SyncList对象，key为加锁对象object指针进行hash后的值。StripedMap是一个C++模板类，其实现代码如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StripedMap</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123; CacheLineSize = <span class=\"number\">64</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_OS_EMBEDDED</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123; StripeCount = <span class=\"number\">8</span> &#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123; StripeCount = <span class=\"number\">64</span> &#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PaddedT</span> &#123;</span></span><br><span class=\"line\">        <span class=\"function\">T value <span class=\"title\">alignas</span><span class=\"params\">(CacheLineSize)</span></span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    PaddedT <span class=\"built_in\">array</span>[StripeCount];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">indexForPointer</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">uintptr_t</span> addr = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">uintptr_t</span>&gt;(p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((addr &gt;&gt; <span class=\"number\">4</span>) ^ (addr &gt;&gt; <span class=\"number\">9</span>)) % StripeCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>[] (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *p) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">array</span>[indexForPointer(p)].value; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> T&amp; <span class=\"keyword\">operator</span>[] (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *p) <span class=\"keyword\">const</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class=\"keyword\">this</span>)[p]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> DEBUG</span></span><br><span class=\"line\">    StripedMap() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Verify alignment expectations.</span></span><br><span class=\"line\">        <span class=\"keyword\">uintptr_t</span> base = (<span class=\"keyword\">uintptr_t</span>)&amp;<span class=\"built_in\">array</span>[<span class=\"number\">0</span>].value;</span><br><span class=\"line\">        <span class=\"keyword\">uintptr_t</span> delta = (<span class=\"keyword\">uintptr_t</span>)&amp;<span class=\"built_in\">array</span>[<span class=\"number\">1</span>].value - base;</span><br><span class=\"line\">        assert(delta % CacheLineSize == <span class=\"number\">0</span>);</span><br><span class=\"line\">        assert(base % CacheLineSize == <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，由于自己对C++模板类不熟悉，所以只能看个大概。其中有两个值得注意的地方，其中StripeCount表示哈希数组的长度，如果是嵌入式系统值为8，否则值为64，也就意味着哈希数组最大长度为64；函数indexForPointer为散列函数，算法不难，但是很巧妙，值得学习。</p>\n<p>下面开始分析相关的函数实现，首先找到@sychronized直接调用的两个函数：objc_sync_enter和objc_sync_exit，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Begin synchronizing on 'obj'. </span></span><br><span class=\"line\"><span class=\"comment\">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class=\"line\"><span class=\"comment\">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">objc_sync_enter</span><span class=\"params\">(id obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class=\"line\">        assert(data);</span><br><span class=\"line\">        data-&gt;mutex.lock();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// @synchronized(nil) does nothing</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DebugNilSync) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        objc_sync_nil();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// End synchronizing on 'obj'. </span></span><br><span class=\"line\"><span class=\"comment\">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">objc_sync_exit</span><span class=\"params\">(id obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        SyncData* data = id2data(obj, RELEASE); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!okay) &#123;</span><br><span class=\"line\">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// @synchronized(nil) does nothing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不难发现，上述代码都调用了id2data函数来获取一个与obj对应的SyncData对象，然后使用该对象中的递归互斥锁分别进行加锁与解锁。至此@sychronized的大致实现过程已经很清晰了，本质上是为一个对象分配一把递归互斥锁，可以也是为什么可以反复使用@sychronized对同一个对象进行加锁的原因。那么@sychronized是如果管理这把互斥锁，以及是如何处理多个线程对同一个对象进行多次加锁的情况？很明显，一切奥秘都藏在id2data函数中，其代码如下所示：</p>\n<ul>\n<li>注：为了描述方便，下面将id2data函数的形参object描述为同步对象obejct。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> SyncData* <span class=\"title\">id2data</span><span class=\"params\">(id object, <span class=\"keyword\">enum</span> usage why)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从全局哈希表sDataLists中获取object对应的SyncList对象</span></span><br><span class=\"line\">\t<span class=\"comment\">//lockp指针指向SyncList对象中自旋锁</span></span><br><span class=\"line\">\t<span class=\"comment\">//listp指向一条SyncData链表，因为C++ STL中的哈希表处理地址冲突的方法是链地址法</span></span><br><span class=\"line\">    <span class=\"keyword\">spinlock_t</span> *lockp = &amp;LOCK_FOR_OBJ(object);</span><br><span class=\"line\">    SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br><span class=\"line\">    SyncData* result = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//对于同一个线程来说，有两种缓存方式：</span></span><br><span class=\"line\">\t<span class=\"comment\">//第一种：快速缓存（fastCache），适用于一个线程一次只对一个对象加锁的情况，用宏SUPPORT_DIRECT_THREAD_KEYS来标识</span></span><br><span class=\"line\">\t<span class=\"comment\">//这种情况意味着同一时间内，线程缓存中只有一个SyncCacheItem对象，键值SYNC_DATA_DIRECT_KEY和SYNC_COUNT_DIRECT_KEY分别对应SyncCacheItem结构体中的SyncData对象和lockCount.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class=\"line\">    <span class=\"comment\">// Check per-thread single-entry fast cache for matching object</span></span><br><span class=\"line\">    <span class=\"comment\">//用于标识当前线程的是否已使用fastCache</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> fastCacheOccupied = NO;</span><br><span class=\"line\">    <span class=\"comment\">//直接调用tls_get_direct函数获取SyncData对象</span></span><br><span class=\"line\">    SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">    \t <span class=\"comment\">//标识fastCache已被使用</span></span><br><span class=\"line\">        fastCacheOccupied = YES;</span><br><span class=\"line\">\t\t <span class=\"comment\">//比较fastCache中的SyncData对象中的object与当前同步对象object是否为同一个对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data-&gt;object == object) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Found a match in fast cache.</span></span><br><span class=\"line\">   \t\t\t  <span class=\"comment\">//fastCache中的对象恰好是当前同步对象object，则后续处理直接使用fastCache中SyncData对象</span></span><br><span class=\"line\">            <span class=\"keyword\">uintptr_t</span> lockCount;</span><br><span class=\"line\"></span><br><span class=\"line\">            result = data;</span><br><span class=\"line\">            <span class=\"comment\">//获取当前线程对应当前SyncData对象已经加锁的次数</span></span><br><span class=\"line\">            lockCount = (<span class=\"keyword\">uintptr_t</span>)tls_get_direct(SYNC_COUNT_DIRECT_KEY);</span><br><span class=\"line\">            <span class=\"comment\">//无效的SyncData对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result-&gt;threadCount &lt;= <span class=\"number\">0</span>  ||  lockCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                _objc_fatal(<span class=\"string\">\"id2data fastcache is buggy\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\t  <span class=\"comment\">//判断当前操作的加锁还是解锁</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(why) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> ACQUIRE: &#123;</span><br><span class=\"line\">                <span class=\"comment\">//加锁一次</span></span><br><span class=\"line\">                lockCount++;</span><br><span class=\"line\">                <span class=\"comment\">//更新已加锁次数</span></span><br><span class=\"line\">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class=\"keyword\">void</span>*)lockCount);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//解锁</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> RELEASE:</span><br><span class=\"line\">                <span class=\"comment\">//解锁一次</span></span><br><span class=\"line\">                lockCount--;</span><br><span class=\"line\">                <span class=\"comment\">//更新已加锁次数</span></span><br><span class=\"line\">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class=\"keyword\">void</span>*)lockCount);</span><br><span class=\"line\">                <span class=\"comment\">//已加锁次数为0，表示当前线程对当前同步对象object达到锁平衡，因此不需要再持有当前同步对象。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lockCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// remove from fast cache</span></span><br><span class=\"line\">                    <span class=\"comment\">//将对应的SyncData对象从线程缓存中移除</span></span><br><span class=\"line\">                    tls_set_direct(SYNC_DATA_DIRECT_KEY, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class=\"line\">                    <span class=\"comment\">//此函数为原子操作函数，用于对32位的threadCount整形变量执行减一操作，且确保线程安全。因为可能存在同一时间多个线程对一个threadCount进行加减操作，避免出现多线程竞争。不同于lockCount，threadCount是多个线程共享的一个变量，用于记录对一个对象加锁的线程个数，threadCount对应的SyncData对象除了线程缓存中持有之外，还存在于全局哈希表sDataLists中，sDataLists哈希表是多个线程共享的数据结构，因此存在多线程访问的可能。而lockCount则与线程一一对应且存储在线程的缓存区中，不存在多线性读写问题，因此不需要加锁。</span></span><br><span class=\"line\">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> CHECK:</span><br><span class=\"line\">                <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class=\"line\">    <span class=\"comment\">//这是第二章缓存方式：使用SyncCache结构体来维护一个SyncCacheItem数组，这样一个线程就可以处理对多个同步对象。值得注意的是SyncCache与线程也是一对一的关系。</span></span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程缓存区中的SyncCache对象</span></span><br><span class=\"line\">    SyncCache *cache = fetch_cache(NO);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"comment\">//遍历SyncCache对象中的SyncCacheItem数组，匹配当前同步对象object</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; cache-&gt;used; i++) &#123;</span><br><span class=\"line\">            SyncCacheItem *item = &amp;cache-&gt;<span class=\"built_in\">list</span>[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (item-&gt;data-&gt;object != object) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Found a match.</span></span><br><span class=\"line\">            <span class=\"comment\">//当前同步对象object已存在的SyncCache中</span></span><br><span class=\"line\">            <span class=\"comment\">//获取对应的SyncData对象</span></span><br><span class=\"line\">            result = item-&gt;data;</span><br><span class=\"line\">            <span class=\"comment\">//无效的SyncData对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result-&gt;threadCount &lt;= <span class=\"number\">0</span>  ||  item-&gt;lockCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                _objc_fatal(<span class=\"string\">\"id2data cache is buggy\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//后续操作同fastCache一样，参考fastCache的注释</span></span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(why) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> ACQUIRE:</span><br><span class=\"line\">                item-&gt;lockCount++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> RELEASE:</span><br><span class=\"line\">                item-&gt;lockCount--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (item-&gt;lockCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// remove from per-thread cache</span></span><br><span class=\"line\">                    cache-&gt;<span class=\"built_in\">list</span>[i] = cache-&gt;<span class=\"built_in\">list</span>[--cache-&gt;used];</span><br><span class=\"line\">                    <span class=\"comment\">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class=\"line\">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> CHECK:</span><br><span class=\"line\">                <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\t  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Thread cache didn't find anything.</span></span><br><span class=\"line\">    <span class=\"comment\">// Walk in-use list looking for matching object</span></span><br><span class=\"line\">    <span class=\"comment\">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class=\"line\">    <span class=\"comment\">// locks for the same new object.</span></span><br><span class=\"line\">    <span class=\"comment\">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class=\"line\">    <span class=\"comment\">// more than 20 or so distinct locks active, but we don't do that now.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果当前线程中的缓存中没有找到当前同步对象对应的SyncData对象，则在全局哈希表中查找</span></span><br><span class=\"line\">    <span class=\"comment\">//因为全局哈希表是多个线程共享的数据结构，因此需要进行加锁处理</span></span><br><span class=\"line\">    lockp-&gt;lock();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SyncData* p;</span><br><span class=\"line\">        SyncData* firstUnused = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">//遍历当前同步对象obejct在全局哈希表中的SyncData链表。这里之所以使用链表，是因为哈希表的hash算法不能确保hash的唯一性，存在多个对象对应一个hash值的情况。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (p = *listp; p != <span class=\"literal\">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class=\"line\">        \t  <span class=\"comment\">//哈希表中存在对应的SyncData对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( p-&gt;object == object ) &#123;</span><br><span class=\"line\">                result = p;</span><br><span class=\"line\">                <span class=\"comment\">// atomic because may collide with concurrent RELEASE</span></span><br><span class=\"line\">                <span class=\"comment\">//此函数为原子操作函数，确保线程安全，用于对32位的threadCount整形变量执行加一操作，表示占用当前同步对象的线程数加1。</span></span><br><span class=\"line\">                OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//用于标记一个空闲的SyncData对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( (firstUnused == <span class=\"literal\">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class=\"number\">0</span>) )</span><br><span class=\"line\">                firstUnused = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// no SyncData currently associated with object</span></span><br><span class=\"line\">        <span class=\"comment\">//由于此时同步对象object没有对应的SyncData对象，因此RELEASE与CHECK都属于无效操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// an unused one was found, use it</span></span><br><span class=\"line\">        <span class=\"comment\">//如果没有找到匹配的SyncData对象且存在空闲的SyncData对象，则直接使用，不需要创建新的SyncData，以提高效率。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( firstUnused != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">            result = firstUnused;</span><br><span class=\"line\">            <span class=\"comment\">//关联当前同步对象</span></span><br><span class=\"line\">            result-&gt;object = (objc_object *)object;</span><br><span class=\"line\">            <span class=\"comment\">//重置占用线程为1</span></span><br><span class=\"line\">            result-&gt;threadCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// malloc a new SyncData and add to list.</span></span><br><span class=\"line\">    <span class=\"comment\">// XXX calling malloc with a global lock held is bad practice,</span></span><br><span class=\"line\">    <span class=\"comment\">// might be worth releasing the lock, mallocing, and searching again.</span></span><br><span class=\"line\">    <span class=\"comment\">// But since we never free these guys we won't be stuck in malloc very often.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//到这一步说明需要新建一个SyncData对象</span></span><br><span class=\"line\">    result = (SyncData*)<span class=\"built_in\">calloc</span>(<span class=\"keyword\">sizeof</span>(SyncData), <span class=\"number\">1</span>);</span><br><span class=\"line\">    result-&gt;object = (objc_object *)object;</span><br><span class=\"line\">    result-&gt;threadCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建递归互斥锁</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> (&amp;result-&gt;mutex) <span class=\"keyword\">recursive_mutex_t</span>();</span><br><span class=\"line\">    <span class=\"comment\">//以“入栈”的方式加入当前同步对象object对应的SyncData链表</span></span><br><span class=\"line\">    result-&gt;nextData = *listp;</span><br><span class=\"line\">    *listp = result;</span><br><span class=\"line\">    </span><br><span class=\"line\"> done:</span><br><span class=\"line\"> \t <span class=\"comment\">//对全局哈希表的操作结束，解锁</span></span><br><span class=\"line\">    lockp-&gt;unlock();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Only new ACQUIRE should get here.</span></span><br><span class=\"line\">        <span class=\"comment\">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class=\"line\">        <span class=\"comment\">// handled by the per-thread caches above.</span></span><br><span class=\"line\">        <span class=\"comment\">//只有ACQUIRE才需要新建SyncData对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (why == RELEASE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Probably some thread is incorrectly exiting </span></span><br><span class=\"line\">            <span class=\"comment\">// while the object is held by another thread.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (why != ACQUIRE) _objc_fatal(<span class=\"string\">\"id2data is buggy\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result-&gt;object != object) _objc_fatal(<span class=\"string\">\"id2data is buggy\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t <span class=\"comment\">//fastCache缓存模式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fastCacheOccupied) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Save in fast thread cache</span></span><br><span class=\"line\">            <span class=\"comment\">//直接缓存新建的SyncData对象</span></span><br><span class=\"line\">            tls_set_direct(SYNC_DATA_DIRECT_KEY, result);</span><br><span class=\"line\">            <span class=\"comment\">//设置加锁次数为1</span></span><br><span class=\"line\">            tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class=\"keyword\">void</span>*)<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> </span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t\t <span class=\"comment\">//SyncCache缓存模式，则直接加入SyncCacheItem数组中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Save in thread cache</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cache) cache = fetch_cache(YES);</span><br><span class=\"line\">            cache-&gt;<span class=\"built_in\">list</span>[cache-&gt;used].data = result;</span><br><span class=\"line\">            cache-&gt;<span class=\"built_in\">list</span>[cache-&gt;used].lockCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">            cache-&gt;used++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述代码的注释，id2data函数的功能已经大致清晰。id2data函数主要是用于管理同步对象object与线程之间的关联。不论是ACQUIRE、RELEASE还是CHECK操作，都会先从当前线程的缓存中去获取对应的SyncData对象。如果当前线程的缓存区中不存在，那么再从全局的哈希数组中查找，查看其它线程是否已经占用过当前同步对象object。如果还是没有，那么就新建一个与之对应的SyncData对象，分别加入全局哈希表和当前线程缓存中。</p>\n<p>至此，@synchronized的实现原理已经剖析结束，其有一个最大的特点是：不论是多个线性同一时间内对一个对象进行多次同步还是一个线程对同一个对象同步多次，一个对象只分配一把递归互斥锁。也就意味着对同一个对象而言，当执行某一次同步操作时，其他线程或同一线程的其他同步操作都会被阻塞，不言而喻，这种加锁方式的效率是很低的。</p>\n<p>下面代码展示了@synchronized经典的使用案例之一：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setInstanceMemberObjecObject1:(<span class=\"keyword\">id</span>)value &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">self</span>.instanceMember1 = value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setInstanceMemberObjecObject2:(<span class=\"keyword\">id</span>)value &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">self</span>.instanceMember2 = value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setInstanceMemberObjecObject3:(<span class=\"keyword\">id</span>)value &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">self</span>.instanceMember3 = value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码，调用其中一个设置函数时，另外两个成员变量的设置函数在同一时间被调用都会被阻塞。这里@synchronized同步的代码很简单，所以不会效率差别不大。如果是同步的代码需要执行较长的时间，且被多个线程并发调用，那么效率变得很低。如果不清楚@synchronized的实现原理，可能很难排查出来导致效率低下的问题所在。我建议使用GCD取代@synchronized实现同步功能，GCD不仅是线程安全，且其由底层实现，效率会好很多。我们发生@synchronized的底层实现有捕获异常的功能，因此适合在需要确保发生错误时代码不会死锁，而是抛出异常时使用。</p>\n","categories":["专业"],"tags":["Objective-C"]},{"title":"JavaScript的this关键字","url":"http://icebergcwp.com/JavaScript的this关键字.html","content":"<p>这是一篇翻译文章，原文地址<em><a href=\"http://davidshariff.com/blog/javascript-this-keyword/#first-article\" target=\"_blank\" rel=\"noopener\">点击这里</a></em>。</p>\n<p>JavaScript中一个常用的语法特征就是this关键字，同时这也是JavaScript最容易被误解和造成困惑的特征。this关键字的含义是什么且决定其含义的依据是什么？</p>\n<p>这篇文章试着解开这个的疑惑并给出一个简单清晰的解释。</p>\n<p>对于有其他语言编程经验的人来说应该也使用过this关键字，且多数情况下this指向的是一个通过构造函数创建的新对象。举例来说，假设有一个Boat类，里面包含一个成员方法moveBoat()，我们可以在moveBoat()方法中通过this关键字访问当前的对象实例。</p>\n<p>在JavaSctript中，当使用new关键字创建一个新对象后，在构造函数中可以通过this关键字访问当前对象。然而，JavaScript中的this关键字指向的对象是随着函数调用的上下文变化而变化的。如果你不是很了解关于JavaScript执行上下文的知识，我推荐你看看我的另外一篇关于这个话题的<a href=\"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/#first-article\" target=\"_blank\" rel=\"noopener\">文章</a>。好了，讲得够多了，让我们看几个代码实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Global scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\">alert(foo); <span class=\"comment\">//abc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.foo = <span class=\"string\">'def'</span>;</span><br><span class=\"line\">alert(foo); <span class=\"comment\">//def</span></span><br></pre></td></tr></table></figure>\n<p>无论何时，只要是在全局上下文而非函数体内使用this关键字，那么this总是指向全局对象的（JavaSctript中的全局对象一般是Windows，NodeJS中是global）。接下来看看在函数中使用this关键字的情景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> boat = &#123;</span><br><span class=\"line\">    size: <span class=\"string\">'normal'</span>,</span><br><span class=\"line\">    boatInfo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span> === boat);</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">boat.boatInfo(); <span class=\"comment\">// true, 'normal'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bigBoat = &#123;</span><br><span class=\"line\">    size: <span class=\"string\">'big'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">bigBoat.boatInfo = boat.boatInfo;</span><br><span class=\"line\">bigBoat.boatInfo(); <span class=\"comment\">// false, 'big'</span></span><br></pre></td></tr></table></figure>\n<p>上述代码中的this关键字指向是如何判断的？上述代码中有一个boat对象，包含了一个size属性和boatInfo方法。在boatInfo方法中有两条输出语句，分别是判断this关键字是否指向boat对象和输出this关键字指向的对象的size属性。因此，当执行代码boat.boatInfo()时，输出结果分别是true和normal。</p>\n<p>随后我们创建了另外一个对象bigBoat，里面同样有一个值为big的size属性。然而，bigBoat对象没有boatInfo方法，因此通过语句bigBoat.boatInfo = boat.boatInfo拷贝一个boatInfo方法。现在，当我们执行语句bigBoat.boatInfo()时，输出的结果分别是false和big。为什么会输出false? boatInfo方法中的this指向的对象是如何发生变化的？</p>\n<p>首先你得明白任何函数中的this关键字指向的值都不是定值，它根据你每次调用函数前的上下文来决定，这个上下文就是函数被调用时所作的生命周期。更为重要的是函数具体的调用语句。</p>\n<p>当一个函数被调用时，如果函数是被某个对象调用时，那么函数中this关键字指向的是调用该函数的对象，否则指向的全局对象。下面举例说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// global - because the method bar() belongs to the global object when invoked</span></span><br><span class=\"line\"><span class=\"comment\">//this指向全局对象</span></span><br><span class=\"line\">bar(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    baz: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo - because the method baz() belongs to the object foo when invoked</span></span><br><span class=\"line\"><span class=\"comment\">//this指向foo对象</span></span><br><span class=\"line\">foo.baz();</span><br></pre></td></tr></table></figure>\n<p>如果事情有这么简单，那么上述代码显然解决了我们的疑惑。但是还有更为复杂的情况，看似同一个的函数，调用的语句不同也会导致this关键字的指向不同。如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    baz: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo - because baz belongs to the foo object when invoked</span></span><br><span class=\"line\"><span class=\"comment\">//this指向foo对象</span></span><br><span class=\"line\">foo.baz(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherBaz = foo.baz;</span><br><span class=\"line\"><span class=\"comment\">// global - because the method anotherBaz() belongs to the global object when invoked, NOT foo</span></span><br><span class=\"line\"><span class=\"comment\">//this指向全局对象，即使anotherBaz是由foo.baz赋值而来，但是this的指向最终还是由调用的方式决定。</span></span><br><span class=\"line\">anotherBaz();</span><br></pre></td></tr></table></figure>\n<p>通过上述代码我们看到由于调用语句的不同，baz方法中的this关键字指向的对象也不一样。现在我们来看看this关键字处于内嵌时的指向是如何的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    anum: <span class=\"number\">10</span>,</span><br><span class=\"line\">    baz: &#123;</span><br><span class=\"line\">        anum: <span class=\"number\">20</span>,</span><br><span class=\"line\">        bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.anum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 20 - because left side of () is bar, which belongs to baz object when invoked</span></span><br><span class=\"line\"><span class=\"comment\">//输出的值是20，因为bar方法是通过baz对象调用的</span></span><br><span class=\"line\">foo.baz.bar(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hello = foo.baz.bar;</span><br><span class=\"line\"><span class=\"comment\">// 0 - because left side of () is hello, which belongs to global object when invoked</span></span><br><span class=\"line\"><span class=\"comment\">//输出的是0，因为hello函数没有显示的调用对象，缺省调用对象为全局对象global</span></span><br><span class=\"line\">hello();</span><br></pre></td></tr></table></figure>\n<p>另外一个被常问到的问题是：如何判断事件监听函数中的this关键字指向？答案是处于事件监听函数中的this关键字通常指向触发该事件的DOM元素。下面举例说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=\"test\"&gt;I am an element with id #test&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAlert</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.innerHTML); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//指向全局对象，但是因为全局对象没有相应的属性，因此输出undefined</span></span><br><span class=\"line\">doAlert(); <span class=\"comment\">// undefined </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myElem = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>); </span><br><span class=\"line\">myElem.onclick = doAlert; </span><br><span class=\"line\"></span><br><span class=\"line\">alert(myElem.onclick === doAlert); <span class=\"comment\">// true </span></span><br><span class=\"line\"><span class=\"comment\">//this指向myElem对象</span></span><br><span class=\"line\">myElem.onclick(); <span class=\"comment\">// I am an element</span></span><br></pre></td></tr></table></figure>\n<p>上述代码中，第一次调用doAlert函数，输出的是undefined，因此此时this指向的是全局对象global。当我们将doAlert函数设置为myElem元素对象的click消息监听函数时，意味着每次触发click消息时，doAlert等价于被myElem对象直接调用，因此this关键字指向的就是myElem对象。</p>\n<p>最后，我想提醒大家的是this关键字的指向是可以通过call()和apply()函数手动修改的，这将导致我们上面讨论的内容都不再适用。另外一点是，在某个对象的构造函数中的this关键字默认是指向当前新建的对象，因为构造函数是使用new关键字调用的，系统会将构造函数中的this关键字指向即将创建的对象。</p>\n<p><strong>总结</strong></p>\n<p>希望今天的博客能够清除你对this关键字的疑惑，并且以后都能正确地判断this关键字的指向。现在我们知道了this关键字的指向的动态变化的且具体的值取决于this所在函数的调用方式。</p>\n","categories":["专业","翻译"],"tags":["JavaSctript"]},{"title":"Cocoa程序退出前发送HttpRequest请求","url":"http://icebergcwp.com/cocoa程序退出前发送Request请求.html","content":"<p>最近在视频投送项目中遇到一个奇葩问题，花费了一整天时间才得以解决。这个问题比较隐晦，值得记录一下。</p>\n<p>根据功能需要，需要在cocoa程序退出前，发送一个关闭设备的指令，本质上就是post一个Http请求，用于中止当前出于投送状态的设备。</p>\n<p>具体代码如下：</p>\n<p>在回调函数- (void)applicationWillTerminate:中调用停止投送API</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t- (<span class=\"keyword\">void</span>)applicationWillTerminate:(<span class=\"built_in\">NSNotification</span> *)aNotification &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// Insert code here to tear down your application</span></span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \t[[CastHelper sharedInstance] stopCast];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>将stop指令集成到URL里面，加入投送队列castOperationQueue中，然后通过HttpRequest发送出去。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t\t- (<span class=\"keyword\">void</span>)stopCast</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dispatch_async</span>(castOperationQueue, ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t       \t\t <span class=\"keyword\">for</span> (ZDCastDevice * device <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.connectedDeviceInfo.allValues )</span><br><span class=\"line\">\t        \t&#123;</span><br><span class=\"line\">\t            \t<span class=\"comment\">//发送stop请求</span></span><br><span class=\"line\">\t\t\t\t\t[<span class=\"keyword\">self</span> sendRequestURL:<span class=\"string\">@\"192.168.1.1/xxx/stop\"</span> HTTPMethod:<span class=\"string\">@\"POST\"</span> completionHandler:completionHandler];</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t        \t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    \t\t&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//异步请求</span></span><br><span class=\"line\">\t\t- (<span class=\"keyword\">void</span>)sendRequestURL:(<span class=\"built_in\">NSURL</span> *)url HTTPMethod:(<span class=\"built_in\">NSString</span> *)httpMethod</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    <span class=\"built_in\">NSMutableURLRequest</span> *request = [[<span class=\"built_in\">NSMutableURLRequest</span> alloc] init];</span><br><span class=\"line\">\t    [request setURL:url];</span><br><span class=\"line\">\t    [request setHTTPMethod:httpMethod];</span><br><span class=\"line\">\t    [request setValue:<span class=\"string\">@\"application/json;charset=UTF-8\"</span> forHTTPHeaderField:<span class=\"string\">@\"Content-Type\"</span>];</span><br><span class=\"line\">\t    [request setHTTPBody:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t    [[[<span class=\"built_in\">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t        <span class=\"comment\">//Error</span></span><br><span class=\"line\">\t        <span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t        &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            <span class=\"built_in\">NSInteger</span> statusCode = [(<span class=\"built_in\">NSHTTPURLResponse</span> *)response statusCode];</span><br><span class=\"line\">\t         </span><br><span class=\"line\">\t            <span class=\"comment\">//successed</span></span><br><span class=\"line\">\t            <span class=\"keyword\">if</span> ( statusCode == <span class=\"number\">200</span>)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                </span><br><span class=\"line\">\t            <span class=\"comment\">//failed</span></span><br><span class=\"line\">\t            &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                </span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t    &#125;] resume];</span><br><span class=\"line\">\t </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在程序正常运行期间，使用上述代码能够正常的执行stop指令，并接受相应的响应。但是，如果在applicationWillTerminate这一函数中调用，通过断点调试发现Request并未成功发送出去，程序就退出了。</p>\n<p>一开始以为是异步发送请求的原因，于是使用dispatch_semaphore_t信号量进行同步，执行结果一样，未解锁之前程序就退出了。代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//异步请求</span></span><br><span class=\"line\">\t\t- (<span class=\"keyword\">void</span>)sendRequestURL:(<span class=\"built_in\">NSURL</span> *)url HTTPMethod:(<span class=\"built_in\">NSString</span> *)httpMethod</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    <span class=\"built_in\">NSMutableURLRequest</span> *request = [[<span class=\"built_in\">NSMutableURLRequest</span> alloc] init];</span><br><span class=\"line\">\t    [request setURL:url];</span><br><span class=\"line\">\t    [request setHTTPMethod:httpMethod];</span><br><span class=\"line\">\t    [request setValue:<span class=\"string\">@\"application/json;charset=UTF-8\"</span> forHTTPHeaderField:<span class=\"string\">@\"Content-Type\"</span>];</span><br><span class=\"line\">\t    [request setHTTPBody:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    <span class=\"comment\">//创建信号量</span></span><br><span class=\"line\">\t    dispatch_semaphore_t semp = dispatch_semaphore_create(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    [[[<span class=\"built_in\">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class=\"built_in\">NSData</span> * _Nullable data, <span class=\"built_in\">NSURLResponse</span> * _Nullable response, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t        <span class=\"comment\">//Error</span></span><br><span class=\"line\">\t        <span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t        &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            <span class=\"built_in\">NSInteger</span> statusCode = [(<span class=\"built_in\">NSHTTPURLResponse</span> *)response statusCode];</span><br><span class=\"line\">\t         </span><br><span class=\"line\">\t            <span class=\"comment\">//successed</span></span><br><span class=\"line\">\t            <span class=\"keyword\">if</span> ( statusCode == <span class=\"number\">200</span>)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                </span><br><span class=\"line\">\t            <span class=\"comment\">//failed</span></span><br><span class=\"line\">\t            &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                </span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t        dispatch_semaphore_signal(semp);</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t    &#125;] resume];</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    <span class=\"comment\">//等待接受到请求响应才执行后续代码</span></span><br><span class=\"line\">\t    dispatch_semaphore_wait(semp, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同步请求方式的方式也试过，结果同样达不到预期效果。代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSURLResponse</span>* response = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> * error = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"built_in\">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        HTTPLogInfo(<span class=\"string\">@\"%s:%d - Error: %@\"</span> , __func__ , __LINE__ , [error localizedDescription]);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        HTTPLogInfo(<span class=\"string\">@\"%s:%d - response: %@\"</span> , __func__ , __LINE__ , [response description]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>思来想去，觉得可能是程序退出去前，只有主线程有效，其他线程均被释放了。于是，把调用stop指令的代码放入主线程队列：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stopCast</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//加入主线程队列</span></span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      \t\t <span class=\"keyword\">for</span> (ZDCastDevice * device <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.connectedDeviceInfo.allValues )</span><br><span class=\"line\">       \t&#123;</span><br><span class=\"line\">           \t<span class=\"comment\">//发送stop请求</span></span><br><span class=\"line\">\t\t\t[<span class=\"keyword\">self</span> sendRequestURL:<span class=\"string\">@\"192.168.1.1/xxx/stop\"</span> HTTPMethod:<span class=\"string\">@\"POST\"</span> completionHandler:completionHandler];</span><br><span class=\"line\">           </span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">  \t\t&#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果还是同之前一样。最后，仔细回想了一下RunLoop的执行过程，很可能是RunLoop在执行了applicationWillTerminate函数所在的任务之后就直接退出了，也就不会执行主线程队列后续的任务了。</p>\n<p>于是，直接把调用stop指令的函数放在与applicationWillTerminate同一个任务中，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stopCast</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//发送stop请求</span></span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> sendRequestURL:<span class=\"string\">@\"192.168.1.1/xxx/stop\"</span> HTTPMethod:<span class=\"string\">@\"POST\"</span> completionHandler:completionHandler];</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>果然不出所料，Request执行成功，并获得相应的Response。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>上述言论都是基于我的猜测，我暂时没有去验证。这个问题比较隐晦，有点违背习惯性的思维。改天抽空结合Apple源代码进行分析验证，此处留坑。</p>\n","categories":["专业"],"tags":["cocoa"]},{"title":"关于读书无用论的一些想法","url":"http://icebergcwp.com/关于阅读的一点想法.html","content":"<p>关于最近流行的“读书无用论”观点的一些个人看法</p>\n<p>通过反复揣摩你说的话，大概可以总结为以下五点（如有歧义，欢迎指正）：</p>\n<p>一、在需要的时候，读技能书学习相应的技能即可<br>二、选择什么样的生活，取决于性格，而非读书能够左右<br>三、读书不能弥补先天的差距</p>\n<p>我觉得，所谓的读书无用，其中“读书”是指阅读，而非指代“寒窗苦读十余载，金榜题名望今朝”这样功利性的读书，另外“无用”是指阅读不会对一个人的生活带来太大的改变。所以，后面用“阅读”来取代“读书”。</p>\n<p>首先，我表明自己的立场：“阅读很有用，不仅完善人格，还能深化思想，甚至可以改变一个人的命运。”书有好书和差书之分，一本好书是作者耗费了大量精力，基于自身知识底蕴，结合个人思想，经过岁月打磨出来的。从某个角度来说，读者只需要几十块钱就能获得作者几十年甚至一生的心血，实在是再廉价不过了。当然，读者能否完全理解作者的思想那就另当别论。阅读一本好书，读过就会留下印象，并且受其影响，只是深浅之分罢了。至于差书，确实没有阅读的必要，不仅无用，浪费时间不说，可能还会造成负面影响。</p>\n<p>下面，我就结合上面几点分别说说自己的想法。</p>\n<p>一、在需要的时候，读技能书学习相应的技能即可。</p>\n<p>作为一个理科生，读技能类的书差不多是每天的日常。书分很多种，技能书则属于自然科学类。特点就是其内容是依据人类目前已经公认或者证实的客观事实提炼或者推导出来的。同一个主题，不同的作者可能表述方式不一样，但是阐述的观点或者得出结论总是一样的。这样的书，讲究实用性，尊重客观事实，不会随着个人意志改变，主要功能在于传授一种技能，对人的三观（人生观，价值观，世界观）不会有太大的影响。</p>\n<p>我想你认可读技能书就是因为它的实用性，能解决实际问题。这也是你认为阅读还算有价值的地方。这一点我同意你的观点。对于不是专业的技能，需要的时候，能解决问题就行。</p>\n<p>二、选择什么样的生活，取决于性格，而非读书能够左右</p>\n<p>首先，现实生活中，大多数人都没有选择自己想要的生活的资本，而是迫于生计和负担，过着不如意的生活。所以，选择什么样的生活与物质条件也有关系。所以，应该是选择什么样的生活态度更为准确。</p>\n<p>都说“内心是怎样的，你看到的世界就是怎样的。”我们看到的或者听到的，都不一定是真实客观的，而是经过大脑过滤，在主观思想的作用下，变成我们愿意相信的“事实”。至少，我们大多数时候都会信以为真。</p>\n<p>那么你的思考问题的角度是否足够全面，思维方式是否是辩证的，以及你大脑的知识储量是否足够充实，就确定了过滤后的结果与真相偏离度的大小。能够影响上述三个方面的因素大致两个，一是外界环境影响，包括家庭环境，成长环境，教育环境。在我们还没有独立学习能力之前，我们对世界的认知都是被动地接受外界影响，最终构成了性格的一部分，这属于先天条件差异造成的个体差异，即所谓的天赋。另外一个因素就是主动学习，这也是人类特有的能力。而最有效也是最廉价的途径莫非就是阅读。一个人成年之后并非不可以改变自己的性格，只是会比较难，这一点已经有科学依据。阅读，既然能改变你的主观思想，也就会影响你对于这个世界的认知，对人生的理解，对自身价值的认可。阅读也许不能改变一个人的物质生活，但是改变一个人看待生活的方式。因此，阅读至少可以改善我们的精神生活。</p>\n<p>因为性格是先天性的，所以会在最开始影响我们的生活方式。但是阅读可以改变一个人看待生活的态度，进而去追求自己想要的生活。</p>\n<p>三、阅读不能弥补先天的差距</p>\n<p>你说有人毕生的追求也许就是别人与生俱来的。没错，确实普遍存在这样的情况。就拿阅读这个习惯来说吧，有些“书香门第”出身的孩子，从小就养成了阅读的习惯，而且从小就阅读很多的书籍，从而比一般的同龄人有更渊博的知识和更出色的思维方式。这些天赋在他们看来都是自然而然的事情，先天的优势不言而喻。对比出身贫穷的孩子，很多人都没有阅读的习惯，思考问题也很浅显和片面。而且，一旦成年，即便有条件和时间来重新塑造自己，也需要付出很大代价，需要将推翻原有的思维方式和改正不良的习惯。</p>\n<p>从这个角度来说，阅读确实很难弥补先天的差距。人生本就是不公平的，坦然接受这个事实是树立正确地人生观的前提。另外，即便如此也不能因为这个原因就否定阅读的作用。</p>\n<p>每个人都有自己的局限性。而人生的意义就在于突破自己的局限性，给自己的生活带来更多可能性，这是每一个精彩人生的主旋律。而阅读无非就是这样的一把利刃。</p>\n<p>最后，我上面叽里呱啦说这些并不是想改变你对阅读的看法。而是，我想和你交流一下我对阅读的看法。我从小在农村长大，身边的人几乎没有看书的习惯，除了干活就是看电视聊家常，童年的记忆根本没有书的影子。我们村很多同龄人都是初中毕业就去广东打工。我是整个村子为数不多的大学生。即便如此，我直到上大学都没有真正明白为什么要读书，意义是什么？难道就是为了找一份谋生的工作？阅读的习惯是我大二之后开始培养的，因为我意识到了自己的局限性以及和别人的先天性差距。从那时候起，我就开始培养自己的阅读习惯，一开始确实很难，因为应试教育的原因很排斥读书。后面反反复复折腾，慢慢对阅读有了一点感觉，也尝到了阅读带来的一点甜头。就我个人经历来说，阅读给我生活带来的改变还是挺大的，不管是精神上还是物质上都有改变，让我更好地把握机遇，更好的去对待生活中的困境。</p>\n","categories":["日常"],"tags":["读书"]},{"title":"原生JS代码模拟鼠标点击消息","url":"http://icebergcwp.com/JS-模拟鼠标点击消息.html","content":"<p>近两天都忙于更新之前做的一个关于国外某知名音乐网站项目，因为自己一直做iOS开发并没有系统的学习过JS，所以属于半吊子水平。</p>\n<p>由于该音乐网站对网页进行了全新的改版，导致之前注入的JS代码全部失效，且原网站中使用的第三方JQuery库也被去掉了。意味着只能使用原生JS重写注入代码。</p>\n<p>期间遇到了一个“棘手”的问题：使用原生JS代码模拟鼠标点击消息来改变音量，不同于普通的鼠标点击的是消息里面需要附带鼠标坐标。在各种尝试之后，耗费了大半天时间才得以解决，个人觉得有点价值，记录下解决思路以供参考。</p>\n<p>以下是解决思路流程：</p>\n<p>ps：以下调试和代码均在Chrome浏览器的控制台执行。</p>\n<h4 id=\"分析DOM元素结构\"><a href=\"#分析DOM元素结构\" class=\"headerlink\" title=\"分析DOM元素结构\"></a>分析DOM元素结构</h4><p>页面样式</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-1.png\" alt=\"页面样式\"></p>\n<p>DOM结构</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-2.png\" alt=\"DOM结构\"></p>\n<p>由上图可知，DIV元素VolumeSlider作为父元素，其下有四个子元素，分,包括显示音量的slider和控制音量的handle元素。</p>\n<p>对音量相关的DOM结构有一个大致了解，便于后面消息派发时选择触发的目标元素。如果说网站将响应鼠标消息的js绑定在父元素，那么选择任意一个子元素或者父元素本身作为触发对象都可以，因为消息会自动传递，最终会作用于父元素VolumeSlider。但是如果响应鼠标消息的js是绑定在四个子元素中的其中一个，则需要一一尝试。这个例子中只有4个子元素，所以很快就能有结果，但是如果需要测试的元素很多，那就效率太低下了。文章后面会介绍一种方法，快速定位响应鼠标消息的元素。</p>\n<h4 id=\"模拟鼠标点击消息\"><a href=\"#模拟鼠标点击消息\" class=\"headerlink\" title=\"模拟鼠标点击消息\"></a>模拟鼠标点击消息</h4><p>该音乐网站改版之前，因为支持jQuery，借助于jQuery库提供的API很方便获取元素坐标和模拟鼠标点击消息。而新的版本只能用原生js编写相关代码。</p>\n<p>第一步：获取元素的坐标位置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//递归获取元素的纵坐标</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTop</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> offset=e.offsetTop;</span><br><span class=\"line\">    ／／累加父元素的坐标值</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e.offsetParent!=<span class=\"literal\">null</span>) </span><br><span class=\"line\">    \t／／递归</span><br><span class=\"line\">    \toffset+=getTop(e.offsetParent);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> offset;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//递归获取元素的横坐标</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getLeft</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> offset=e.offsetLeft;</span><br><span class=\"line\">    ／／累加父元素的坐标值</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e.offsetParent!=<span class=\"literal\">null</span>) </span><br><span class=\"line\">    \t／／递归</span><br><span class=\"line\">    \toffset+=getLeft(e.offsetParent);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> offset; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二步：模拟鼠标消息</p>\n<p>原生js的Event对象有很多属性，但是创建Event的时并不是每一个属性都需要赋值。在网上找到了一篇博客<a href=\"http://marcgrabanski.com/simulating-mouse-click-events-in-javascript/\" target=\"_blank\" rel=\"noopener\">Simulating Mouse Events in JavaScript</a>讲的比较详细。以下是我使用的示例代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">／／offset是通过音量值转换过来的：音量level（<span class=\"number\">0</span><span class=\"number\">-1</span>）* targetElement的长度</span><br><span class=\"line\"><span class=\"keyword\">var</span> clientX = getLeft(targetElement) + offset;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"keyword\">var</span> clientY = getTop(targetElement);</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> MouseEvent(<span class=\"string\">'click'</span>, &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"string\">'view'</span>: <span class=\"built_in\">window</span>,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"string\">'bubbles'</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"string\">'cancelable'</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"string\">'clientX'</span>:clientX,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"string\">'clientY'</span>:clientY</span><br><span class=\"line\">                                       &#125;);</span><br><span class=\"line\">            </span><br><span class=\"line\">targetElement.dispatchEvent(event);</span><br></pre></td></tr></table></figure>\n<p>第三步：获取响应鼠标消息的元素</p>\n<p>如果是普通的鼠标消息，比如点击按钮消息或者不带坐标值的消息，一般很容易触发成功。但是如果是带来坐标位置的鼠标消息则很可能触发成功之后但是达不到预期效果。在这个问题上我困惑了蛮久，明明代码执行之后，返回触发消息成功，但是音量值并没有改变。</p>\n<p>我在想有没有办法将真实的鼠标点击消息内容输出到终端，这样通过对比真实的鼠标消息就能找到模拟的鼠标消息的差异所在。</p>\n<p>于是，在控制台输入了以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> windowClickEvent = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ev</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> oEvent = ev||event;</span><br><span class=\"line\">\t／／获取当前鼠标消息对象</span><br><span class=\"line\">\twindowClickEvent = oEvent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码能获得当前鼠标消息对象。使用鼠标点击音量条，在控制台获得如下结果：</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-3.png\" alt=\"DOM结构\"></p>\n<p>对比真实的鼠标消息，确定模拟的鼠标消息中的坐标值是吻合的。但是二者的target元素不同，这也正是原因所在。修改了target元素之后，代码执行结果达到了预期的结果。通过这个方法可以快速定位响应鼠标消息的目标元素。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>在刚开始要使用原生js模拟鼠标消息的时候，感觉一片茫然。在网上查了很多资料，没有找到满足需求的代码。最后只能硬着头皮自己写，期间各种不确定性都需要一一测试，折腾了大半天，好在最终达到预期的结果。与此同时，对模拟鼠标消息也有了新的体会，至少以后能够比较轻松的完成类似的功能。</p>\n","categories":["专业"],"tags":["JS"]},{"title":"解除NSTimer潜在的“保留环”问题","url":"http://icebergcwp.com/解除NSTimer潜在的“保留环”问题.html","content":"<p>NSTimer是Foundation框架中的一个使用频率很高的类，然而其调用过程中很容易引入潜在的“保留环“问题。可能是因为NSTimer的提供的API足够便利与顺手，以至于这个问题不容易被察觉到。这篇博客旨在阐述这个问题并提供解决方法。</p>\n<p>以下的NSTimer提供的三个常用的创建或者初始化的API：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)ti target:(<span class=\"keyword\">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)userInfo repeats:(<span class=\"built_in\">BOOL</span>)yesOrNo;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)ti target:(<span class=\"keyword\">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)userInfo repeats:(<span class=\"built_in\">BOOL</span>)yesOrNo;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFireDate:(<span class=\"built_in\">NSDate</span> *)date interval:(<span class=\"built_in\">NSTimeInterval</span>)ti target:(<span class=\"keyword\">id</span>)t selector:(SEL)s userInfo:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)ui repeats:(<span class=\"built_in\">BOOL</span>)rep <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure>\n<p>这三个API有一个共同的点，即都需要提供一个target参数。这个target参数会被创建的NSTimer实例对象强引用一次，直到NSTimer实例对象调用invalidate方法后失效才释放。API文档原文如下：</p>\n<blockquote>\n<p>target: The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated. </p>\n</blockquote>\n<p>多数情况，我们都会将创建后NSTimer实例对象保存为当前类的实例变量，然后NSTimer的target参数设置为self指针。我写代码的习惯就是这样的。实例代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyObject</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *mTimer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">//此处参数repeats = YES;</span></span><br><span class=\"line\">        mTimer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timerFiredFun) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">        [mTimer setFireDate:[<span class=\"built_in\">NSDate</span> distantPast]];</span><br><span class=\"line\">     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    [mTimer invalidate];</span><br><span class=\"line\">    mTimer = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)timerFiredFun&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span> , __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main (<span class=\"keyword\">int</span> argc , <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    MyObject *myObjcet = [MyObject new];</span><br><span class=\"line\">    <span class=\"comment\">//self只是一个空消息，避免编译器发出myObjcet未使用的警告</span></span><br><span class=\"line\">    [myObjcet <span class=\"keyword\">self</span>];</span><br><span class=\"line\">  \t<span class=\"comment\">//NSTimer依赖于RunLoop而存活，手动激活RunLoop</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runMode:<span class=\"built_in\">NSDefaultRunLoopMode</span> beforeDate:[<span class=\"built_in\">NSDate</span> distantFuture]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码就是典型的计时器使用情景之一。如果计时器只是一次执行而非反复触发，那么计时器会在执行后自动失效，也就不会有“保留环”的问题。但是如果是设置反复触发的计时器类型，那么NSTimer对象会强引用MyObject对象，而当前类也一直持有NSTimer对象，因此，如果NSTimer不调用invalidate设置无效，MyObject对象不会背释放，其dealloc函数也一直被调用，然而NSTimer的invalidate恰好是MyObject对象的dealloc函数中调用。这样两个对象都不会释放。</p>\n<p>出现“保留环”的根本原因在于NSTimer对象在创建的API隐性地强引用一次target，因此，解除“保留环”的关键在于避开NSTimer对象对self指针的强引用。以下是提供的一种解决方案：</p>\n<p><strong>NSTimer+BlockSupported分类</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^ICETimerScheduleBlock)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">BlockSupported</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ice_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)ti</span><br><span class=\"line\">                                         block:(ICETimerScheduleBlock)block</span><br><span class=\"line\">                                       repeats:(<span class=\"built_in\">BOOL</span>)yesOrNo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSTimer+BlockSupported.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSTimer</span> (<span class=\"title\">BlockSupported</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)ice_scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)ti</span><br><span class=\"line\">                                         block:(ICETimerScheduleBlock)block</span><br><span class=\"line\">                                       repeats:(<span class=\"built_in\">BOOL</span>)yesOrNo &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Timer会对target强引用，但是此处target变成Timer类对象。因为类对象生命周期与应用程序一置的，不受引用计数限制，所以没关系。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:ti target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(ice_timerFiredFun:) userInfo:block repeats:yesOrNo];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)ice_timerFiredFun:(<span class=\"built_in\">NSTimer</span> *)timer &#123;</span><br><span class=\"line\">    ICETimerScheduleBlock block = timer.userInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block) &#123;</span><br><span class=\"line\">        block();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用方式</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">mTimer = [<span class=\"built_in\">NSTimer</span> zd_scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span>f block:^&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加一次局部强引用，确保即使在block执行过程中外部的self被释放了也能顺利完成。局部变量strongSelf的生命周期只限于当前block，不会一直持有self，所以不影响外部self对象的引用计数平衡。</span></span><br><span class=\"line\">    <span class=\"comment\">//如果局部强引用，weakSelf可能会在block执行过程中因为外部self释放而被设置为nil。</span></span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"keyword\">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">    [strongSelf timerFiredFun];</span><br><span class=\"line\">&#125; repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>上述解决方案使用了NSTimer+BlockSupported分类对NSTimer原生函数进行了二次封装，将调用方需要的执行的函数转移到block中执行，再结合__weak指针解除NSTimer对self的强引用。NSTimer原生API调用照样会对target强引用，但是此时的target变成Timer类对象。因为类对象生命周期与应用程序一置的，不受引用计数限制，所以没关系。</p>\n<p>这种类型的“保留环”问题很隐蔽，因此很有分析与记录价值，与君共享。</p>\n<p><a href=\"https://github.com/icebergcwp1990/ICBTimerWithoutRetainCycle\" target=\"_blank\" rel=\"noopener\">GitHub Demo</a></p>\n<p><em>注：这个解决方案参考了Effective Objective-C 2.0一书中第52条，有兴趣的同学可以自行查阅。</em></p>\n","categories":["专业"],"tags":["Objective-C"]},{"title":"承认自己无能是有多难？","url":"http://icebergcwp.com/承认自己无能是有多难.html","content":"<blockquote>\n<p>人的一切痛苦,本质上都是对自己的无能的愤怒。— 王小波</p>\n</blockquote>\n<p>承认自己无能是有多难？</p>\n<p>换做以前，我会直接避开与其直接交锋，因为我所面对的是客观事实，客观存在的事物是不会随着个人意愿转移的。我不敢承认是很大程度上是因为自尊心和虚荣心，即使是一个人独处的时候也是如此。有时候，我能找到一些借口，以此为自己开脱，暂时麻痹自我；但是有时候，实在是绕不过自己心里的坎：一方面是心里明明知道自己现在存在很多缺陷，与自己的目标相去甚远；另一方面却没有勇气去面对，具体地说是没有信心去战胜自我。于是内心的愤怒油然而生，最终痛苦的也是自己。</p>\n<p>现在，我已经能以一种相对坦然的心态看待自己的无能。因为我渐渐意识到目前的无能是暂时的，且属于过去的自己。人是有主观能动性，是可以改变的，每每想到这一点，我内心会感到一丝欣慰，因为我是一个愿意改变，愿意反省，且能够付诸于行动的人。</p>\n<p>然而，我还是继续为自己的无能而感到痛苦。</p>\n<p>我发现“改变”这件事是长周期低回报的，需要长周期且持续的努力，才可能得到些许改变。如何维持这个长周期且持续的努力，这本身就是一种能力。我不得不承认，我的这种能力很弱，我的原定计划很容易因为外界的干扰而搁置或中断。</p>\n<p>面对外界的诱惑，我试图与之对抗，有时候也会取胜，但是大多数都是惨败。我深知推迟满足感对于锻炼成熟心智的重要性，却仍然抵抗不了及时行乐的诱惑。为什么会频频败下阵来？这是一个急需要解决的困惑。</p>\n<p>问题是要辩证地看待和分析的，内因一般来说是主因但也不能忽略外在因素的影响。记得很久之前看到一句话，现在深以为然：“决定你目标是否成功实现的关键因素不是坚持，而是科学的计划”。初次看到这句话的时候，并没有太多体会和感想。现在却如同看到救命稻草一般，想紧紧抓住。</p>\n<p>自从有意锻炼心智以来，也成功完成过一些计划，包括100天跑步计划，一年跑步计划，每天健身计划，美语学习计划，每天早上一杯水，每天睡前看半个小书，早餐两个鸡蛋一杯五谷燕麦粉。这些计划都有一个共同点就是执行时间不长，通常利用碎片时间就能完成。然而，我在最近的每周一篇博客计划上却显得步履维艰，究其原因之一就是写一篇博客通常需要整块连续的时间，少则两三小时，多则七八个小时。由于执行时间长，所以过程中很容易被外界干扰。除了上述的客观原因之外，剩下的就是自身的自控力不够，短时间内难以做出对长远目标有益的决定，容易因为贪图眼前的享乐而中止原计划。很典型的例子就是每到周末的时候，本计划利用一天的时间好好梳理知识，写一篇博客。如果这时候，好朋友电话过来约我打篮球，这种诱惑简直就是致命的。与朋友一起打篮球和聚餐本就是我内心渴望做的事情，是我一周高强度工作之后的一丝安慰，而写博客是我应该做的事情，但欲望一定是没有前者那么强烈。可想而知，我几乎每次遇到这两件事情的抉择时，都会选择前者，然后怀着愧疚又欣喜的心情踏上去篮球场的公交车。很多时候，我们都想实现双赢，但是现实却总是给单选题，鱼和熊掌不可兼得，选择做利于长期目标的事情还是及时行乐，对现阶段的我来说是一个很大的挑战，有时候即便是我强迫自己选择不去打篮球，留下了写博客，但是我的内心却很难平静下来，导致效率低下，得不偿失。</p>\n<p>王小波说过：“一个人活在世上就是为了忍受一切摧残，想通了这点，任何事情都能泰然处之。” 可惜现阶段我还没达到这个层次，因此每当自己的心智受到摧残的时候，我都会多少有点茫然失措，甚至怨恨自己。目前来说，改善这种困境的根本方法在于加强自我的心智和自控力，以及长远目标的思维方式。不过在此之前，我首先需要坦然地接受现在这个“无能”的自己，这样才能先做减法再做加法。</p>\n","categories":["日常"],"tags":["心理"]},{"title":"关于爱的一点想法","url":"http://icebergcwp.com/什么是爱.html","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前不久又翻读了《少有人走得路》这本书，并将其置于枕边，每天晚上睡觉之前或是蹲马桶的时候看上几个章节，那种感觉妙不可言。这本书从来没有让我失望过，每看一次都收获不少，确实是一本值得读一辈子的好书。</p>\n<h3 id=\"爱的定义\"><a href=\"#爱的定义\" class=\"headerlink\" title=\"爱的定义\"></a>爱的定义</h3><p>这次的阅读有一个论点让我深以为然，就是关于爱的定义。作者斯科特·派克是这样定义的：“爱，是为了促进自我和他人心智成熟，而具有的一种自我完善的意愿。“ 爱，是一种神秘的现象，我个人觉得很难言明爱是什么，如何定义。如果有人问我：”你觉得爱是什么？“ 我很可能回答：”它是一个很奇妙的东西。“ 然而，当我在书中看到作者给出的定义时，觉得他完整的表达了我对于爱的理解。</p>\n<p>爱是长期的和渐进的过程。爱是自我完善，意味着心智不断成熟。当我在付出爱的努力，不仅能让他人的心智成熟，自己也同样获益。真正意义上的爱，既是爱自己，也是爱他人。我始终坚信一个不爱自己的人是不可能爱别人的。一个缺乏自律的父母，不可能让孩子懂得什么是自我完善；一个自私的伴侣，不可能察觉另一半情绪细微变化和顾忌另一半的心理感受。显然，自私和缺乏自律就是一种心智不成熟的表现，换言之就是不自爱的结果。这也许和大多数人理解的爱不太一样，以为爱就只是给予和付出。殊不知，真正的爱是自我完善，也是帮助他人完善。它意味着持续地努力，超越自我界限。</p>\n<p>对于爱最大的误解，莫过于将男女恋爱理解为爱。我以前也是这样理解，其实我错了。</p>\n<h3 id=\"坠入情网\"><a href=\"#坠入情网\" class=\"headerlink\" title=\"坠入情网\"></a>坠入情网</h3><p>提及爱这个字眼，相信很多人都会想到男女恋爱，尤其是把坠入情网当成爱。坠入情网的人，时常会把”我爱你“这样的句子挂在嘴边，以此表达爱意。然而，这只是一种主观愿望罢了。要了解坠入情网的本质，首先理解心理学上的”自我界限“。</p>\n<p>何为”自我界限“？在新生婴儿的眼里，一切移动或静止的事物之间，他和周围的人之间，在单个个体和整个世界之间，没有任何界限和区别。随之年龄和认识的增长，他会发现他和世界不是一回事。他感觉饥饿，母亲不见得立刻出现；他想玩耍的时候，母亲未必能及时配合。他渐渐地意识到自己的意愿和母亲的行为完全是截然不同的两回事，这也就是自我意识的形成。通常，婴儿的自我意识能否健康发展，取决于同母亲的关系是否融洽。当婴儿意识到自己是一厢情愿的，不能主宰其他人的意愿，于是开始在自己和周围世界之间做出区分。慢慢地我们能区分出自己和外在世界更多的不同，认识到自己的局限性。这样的认知就是”自我界限“。</p>\n<p>永远活在”自我界限“中，只会给人带来孤寂。对他们而已，世界充满险恶，自我界限是保护伞，孤独和寂寞反而能带来安全感。但是大部分人还是渴望摆脱寂寞，冲出自我界限的牢笼。坠入情网，就是表现之一，暂时性地摆脱寂寞。坠入情网意味着”自我界限“的某部分崩溃，使我们的自我与他人的自我合二为一。情感就像决堤的洪流，声势浩大地涌向所爱的人，于是寂寞消失了，取而代之的是难以言喻的狂喜。</p>\n<p>显然，坠入情网是情感和心灵退化现象。与心爱的人在一起，跟童年时和父母相伴的记忆彼此呼应，让我们体会到幼年时无所不能的快感，似乎没有什么能够阻止我们实现愿望。然而，残酷的现实会像击溃两岁小孩的幻想一样击溃我们的爱情之梦。日常琐事和难题，容易让双方产生矛盾和冲突，对这种”爱“造成威胁甚至击溃。我们必须面对现实，学会真正的相知和相爱，以此来避免上述这种虚幻的爱。</p>\n<p>坠入情网是自我界限暂时性崩溃的现象，只要客观条件允许，就会发生。而真正的爱是需要彼此付出努力的，是一种主观意愿。坠入情网的经历终结，自我界限会恢复原样。而真正的爱是对自我界限的扩充，而不是使其恢复原状。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>真正的爱不是过度依赖，也不是自我牺牲，更不是一种感觉，而是实际行动，是心智上地成长。在爱一个人之前，首先成为一个自爱的人，一个有趣的人，再和另外一半一起有趣下去。</p>\n<p>如何成为一个有趣的人？还在努力中…</p>\n","categories":["日常"],"tags":["爱"]},{"title":"一颗雕琢的心","url":"http://icebergcwp.com/2016-12-14-小记.html","content":"<blockquote>\n<p>故天将降大任于是(斯)人也,必先苦其心志,劳其筋骨,饿其体肤,空乏其身,行拂乱其所为,所以动心忍性,曾益其所不能。</p>\n</blockquote>\n<p>进入十月份以来，公司进入新的一批产品线开发周期，需要在短期的几个月开发出一项包括前端+服务器+音频+投送的综合产品线，且这些都是我不曾涉及的领域。因此这个项目的难度和广度对我而言是前所未有的，充满挑战与未知。</p>\n<p>尽管如此，主观上，我很乐意接受挑战。</p>\n<p>现在这个项目进入关键阶段，之前预研阶段已经让我有点身心疲惫，最近几天也是频频失眠。与此同时，我发觉自己最近变得有点浮躁，急于求成的心态时不时的穿插在工作过程中，在我不觉察间主宰了我的意识形态，而不自知。我算不上完美主义者，但是如果项目的某个部分没有达到预期结果，我会感到情绪低落，甚至影响我对于整个项目的感觉。这种思维和心态太可怕，简直就是目光短浅与内心浮夸的完美体现，这不是我想要的。</p>\n<p>遇到问题就需要解决，我意识到自己现在最大的矛盾就是：“工作上日益增加的强度和压力与个人内心不断被消磨的耐心和理智之间矛盾。” </p>\n<p>急于求成，终将得不偿失。在追求项目整体尽量完美的前提下，学习匠人心态，多一份耐心与理智，坦然接受前期的简陋与粗糙，先把整个项目搭建起来，然后再悉心打磨细节，日趋完善它，以一种全局和长远的目光看待事物，不局限部分与短期效果。</p>\n<p>这个道理不难领悟，但是要付诸于实践，并将其养成一种行事风格却非易事，难！加上以往与之相对的思维模式与行为习惯会不时地阻挠，更是难上加难。因此在未来的生活与工作中需要时时自我监督与反省，不断的自我提醒，这也是这篇小记的目的所在。</p>\n<p>保持一颗雕琢的心，雕琢产品，也雕琢内心。</p>\n<p>— 2016-12-14</p>\n","categories":["日常"],"tags":["心理"]},{"title":"Belief in a Just World","url":"http://icebergcwp.com/世界公正信念.html","content":"<p><div align=\"center\"><br><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/embrace-01.jpg\" alt=\"Embrace the world\"></div></p>\n<p>前几天微信朋友圈被一篇名为《罗一笑：你给我站住》刷屏，文章讲述了一个身患白血病的女孩子，名为罗一笑，文章的封面就是她，一个脸上挂着天真可爱的笑容的女孩。其父罗某为了给女儿筹集医药费，在网上发布了一篇饱含父爱的文章。文章的内容就不赘述了，毕竟这已经不是我这篇博客论述的重点所在，何况在网上随便搜索这个有点新意的文章名就能轻易找到原文或者转载的文章。</p>\n<p>我是在微信朋友圈看到这篇文章的，对于这类带有“乞讨性质”的文章，我一般都是持怀疑态度并习惯性忽略。但是这次我却被这个文章名以及封面上小女孩的笑容所吸引，卸下来了防备，看完全文并转发了朋友圈，以此表达自己的爱心与祝福。</p>\n<p>然后，今天在微信朋友圈看到了另外一篇文章，这篇文章戳穿了“罗一笑事件”的骗局，揭露其中的内幕。我这才意识到这可能又是一场网络营销的经典案例，而且估计自己和很多富有同情心的民众一样已经成为炮灰。</p>\n<p>讲真，世上最让人感到愤怒的情况可能莫过于三种：一是被利用；二是被欺骗；三是被迫承认自己的愚蠢。当着三种情况同时在一件事情发生，我相信内心的那种怒火的不言而喻的。伤害最深的就是那些满怀善意转发朋友圈的人。</p>\n<p>截止目前，这件事的后续报道仍是接二连三，一度占领着各种媒体的头条。报道的内容也是各执一词，标题也是博人眼球，这个很China。只是，我觉得事情是真是假已经不很重要的，重要的是它对社会造成的伤害已经成事实。聊聊群众为什么会一次又一次的被欺骗似乎更有意义点。</p>\n<p>不过，我仅从个人的角度来分析。毕竟我没有做广泛的群众调查，也就无法知晓广大群众的真实想法。但是，我自己作为一个普通群众中的一员且同样是炮灰之一，说说自己的想法，也许能找到与我产生共鸣的人？</p>\n<p>言归正传，撇开个人主观方面的差异，我觉得有两个客观的原因是此次我“沦陷”的主要推手。下面具体说说我的个人的理论依据。</p>\n<p><strong> 公正世界信念 </strong></p>\n<p>第一个是公正世界信念，我一直相信这个理论是真实存在的。这个理论是在1965年，由美国心理学家Lerner首次提出的“公正世界信念(Belief in a Just World，BJW )”的概念：个体有一种需要：相信他们生活在一个公正的世界里，在这个世界里人们得其所应得，所得即应得。</p>\n<p>美国心理学家Lerner及其同事研究了美国五六十年代的种种社会现象，比如说人们在没有细究事情的原委之前，就会贸然地认为高空作业摔伤的工人一定是因为工作马虎不认真、严重车祸的受害者一定是因为不遵守交通规则或飙车、流浪汉流落街头就是因为他们好吃懒做不愿意去工作等等。基于此，Lerner提出了著名的公正世界信念的概念：“个体有这样一种需要：相信他们生活在一个公正的世界里。在这样一个世界里，人们得其所应得。这种世界是公正的信念，可使个体相信他们所处的物理和社会环境是稳定有序的，从而有利于个体适应这些环境。如果这种信念缺失，个体就很难使自己致力于长远目标的追求，难以遵循社会规范行事。由于公正世界信念在个体适应方面具有重要的功能，所以人们极不情愿放弃这种信念，并且一旦遇到例证表明世界是不公正的、无秩序的，他就会陷入忧虑烦恼之中。”</p>\n<p>反观“罗一笑事件”，这个事件里面有几个关键因素，分别是小女孩，白血病，父爱。一个天真可爱的小女孩遭遇命运的不公平，承受白血病这种不可控的天灾带来的痛苦。更何况主角是一个小女孩，一个无辜的孩子，还没来得及理解死亡的意义就要面对死亡威胁。这显然不是我们愿意看到的，我们希望自己生活在一个有爱的世界里，同时也希望未来某个时刻如果自己的孩子在遇到困境的时候能得到社会援助。因此，我们会很容易同情心泛滥，献出自己的爱心，为筑建一个心中期望的世界添砖加瓦。也许如果主角不是儿童或未成年人，而是一个成年人，我想也许会有一部分将他/她的不幸遭遇归责于其个人不良的生活习惯，认为一定是他/她不注意个人卫生或是缺乏自控力才染上重病，比如吸烟、酗酒等。因此，我们心里很可能不会去同情他/她，甚至觉得他/她罪有应得。大多数人相信一个自控力强且生活习惯好的人得到的应该更好的生活，不愿意接受病魔不期而至的事实。此外，这个事件还要一个不能忽视的因素：父爱。正所谓父爱如山，母爱似海。这两种世间最伟大也是最无私的爱，它们无疑是这个社会的道德基石。除去有童年阴影的少数人，大多数人都是在父爱和母爱的沐浴下长大的。因此，我们几乎丝毫不会怀疑它们的真实性，内心也期望它们是普遍存在的。这也是为什么我的心理防线会被攻破的原因所在。然而，当事件的内幕被曝光之后，大家发现自己的善意被愚弄了，纷纷开始将矛头指向罗父还有相关的媒体人，网上瞬间谴责声一片，此时已经没多少人再将注意力放在罗一笑的病情上了，而是急于发泄心中的怒火。这也正是公正世界信念的体现，大家都倾向于相信自己所处的物理和社会环境是稳定有序的，因为这样才有助于我们长期目标的发展。</p>\n<p>再次声明，我仅仅是结合“罗一笑事件”分析这种心理现象，我个人为罗一笑小盆友的遭遇感到同情，也不怀疑罗父爱女心切的心情。我要批判的不是他们父女，而是怒斥那些利用群众心理软肋进行网络营销，谋求个人利益的媒体人。</p>\n<p><strong> 心理阈值效应 </strong></p>\n<p>第二个是心理阈值效应。阈值效应是一个普遍存在于社会各个领域的现象，包括经济、心理、学习等。在经济学中经常提及一个概念，叫做“边际递减效应”。何为“边际递减效应”？我记得一个文革时期的经济学家给出的解释最为恰当和接地气，故事大概内容是：在大跃进之后和文革之前的这段时间，国内经济不景气，生产力低下，粮食产量低。于是，村委会鼓励群众去收割完的稻田里捡稻穗，减少粮食的浪费。刚开始大家都在距离家近的稻田里捡稻穗，并且每天都能满载而归。过了一段时间，附近稻田的稻穗都被捡完了，人们不得不去离家更远的稻田捡稻穗，捡满一箩筐之后再背回家。随着时间的推移，人们离家的距离越来越远，稻穗也越捡越少，渐渐地人们每天在捡稻穗的过程中消耗的能量等于或大于捡到的稻穗的能提供的能量，常常饿着肚子都捡不满一筐，这时候如果继续捡稻穗则得不偿失。这就是边际递减效应，而这个节点就是阈值点。小于这个阈值时则收获大于消耗，超过这个值则收获小于消耗，且二者的比值呈递减趋势。</p>\n<p>心理阈值效应也是类似。当某件事情触发了心理的阈值，则会适得其反。当年轰动一时的“郭美美炫富事件”爆出红十字会的腐败内幕，让整个社会的信任基础遭受重创，此后多数人都不再愿意捐钱给红十字会。然而，这个阈值是动态的。经过一段时间的冷却或者其他事件转移注意力，加上期间被一些正能量的事迹所影响，愿意再次相信社会是和谐美好的，因此人们的心理情绪也会慢慢回归阈值以下，但是也许再也回不到之前的水平了，也就意味人们比之前更容易达到阈值点。假设社会上频繁的出现一些破坏社会信任的负面事件，会导致人们越来越冷漠，最终对所处的社会彻底失去信任。</p>\n<p>我想“罗一笑事件”背后的策划者毋容置疑地再次挑战了人们的阈值限度，造成了不可逆的伤害。Double Kill! Nice!</p>\n<p><strong> 小结 </strong></p>\n<p>罗曼·罗兰说过，世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它。虽然说我所处的社会一次又一次的面临信任危机，但是我还是选择去拥抱它，因为我看到了很多和我一样被欺骗的群众，让我知道身边的大多数人都是心存善意的。不过，我可能需要换一种更为理智的拥抱姿势罢了。</p>\n","categories":["日常"],"tags":["信念"]},{"title":"StartFucks Coffee - 操蛋的咖啡","url":"http://icebergcwp.com/StartFucks Coffee - 操蛋的咖啡.html","content":"<blockquote>\n<p>写了一天的代码，看着桌上冒着热气的白开水，想到第一次去星巴克的情景：傻傻地在柜台面子，看着各种咖啡名词，踌躇许久，最终点了一份中杯柠檬茶。那位服务员小胖妞无语中掺杂点鄙视的眼神，至今记忆犹新…</p>\n</blockquote>\n<p>身边的朋友喝咖啡的不少，咖啡这个词汇也经常萦绕耳旁：美剧中，喝咖啡已是日常；朋友聚会，问及他（她）们最爱的饮料，也是拿铁和卡布奇诺居多；特别的大学期间的坐我对面的师姐，感觉她对于喝咖啡跟喝水已经没多大区别，每一次浓浓的咖啡香从她的书桌散发出来，很难说我没有一丝要来一杯的冲动，不过，最终还是忍住了。</p>\n<p>究其原因，一是我个人对咖啡的印象并不好，普遍观点认为长期喝咖啡对于身体健康和健身有不良影响，这种观点是否属实尚不能下定论。在此之前，我选择敬而远之。二是我狭隘的以为咖啡只有一种：苦咖啡，殊不知咖啡也是大有学问。其实我早该想到西方的咖啡应该和东方的茶一样，种类繁多，口味各异。只是先入为主的观念让我对咖啡已经失去了进一步了解的兴趣。</p>\n<p>如今，终究是因为自尊心受到了伤害，决定整理一下关于咖啡的基本知识。更何况即便是不喝咖啡，也至少对它有一个基本的认识，这样才算得上公平。</p>\n<p>网上已经有很多接受咖啡种类的文章，我只是顺手牵羊，秉着拿来主义，自己总结一下，加深印象。</p>\n<p>咖啡大体上可以分为12种，其中浓缩咖啡（Espresso）最为根本，其他11种都是在Espresso的基础上添加其他的配料演变而成的花式咖啡。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-0.jpg\" alt=\"12种咖啡的恩怨情仇\"></p>\n<p>通过上图，可以比较直观地感受这12种咖啡直接的关联。以下分别介绍：</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-1.jpg\" alt=\"浓缩咖啡-玛奇朵-美式咖啡\"></p>\n<h3 id=\"浓缩咖啡（Espresso）\"><a href=\"#浓缩咖啡（Espresso）\" class=\"headerlink\" title=\"浓缩咖啡（Espresso）\"></a>浓缩咖啡（Espresso）</h3><p>浓缩咖啡，英文名为Espresso，Espresso是一个意大利单词，所以也叫意式浓缩咖啡，指的是一种用咖啡机在短时间内急速萃取的浓烈咖啡，几乎称得上是所有花式咖啡的基础，也是全世界咖啡馆的必备。Espresso很小杯，通常只有30毫升左右，味道很苦，表面浮着一层厚厚的油脂，会与一杯清水同上，可以选择加糖。这款是真正的咖啡爱好者和急需提神者的首选。</p>\n<h3 id=\"玛奇朵（Espresso-Macchiato）\"><a href=\"#玛奇朵（Espresso-Macchiato）\" class=\"headerlink\" title=\"玛奇朵（Espresso Macchiato）\"></a>玛奇朵（Espresso Macchiato）</h3><p>Macchiato原文为意大利语，代表“印记、烙印”的意思，发音为“玛奇雅朵”，习惯称呼为玛奇朵。玛奇朵是在浓咖啡上加上薄薄一层热奶泡以保持咖啡温度，细腻香甜的奶泡能缓冲浓缩咖啡带来的苦涩冲击，想喝咖啡但又无法舍弃甜味的你，可以选择玛奇朵。经常会听到“焦糖玛奇朵”，据说这是星巴克的独创，其做法是在牛奶中加入香草糖浆，与Espresso咖啡混合，再于奶泡上覆盖一层焦糖，口味层次很丰富。</p>\n<h3 id=\"美式咖啡（Americano）\"><a href=\"#美式咖啡（Americano）\" class=\"headerlink\" title=\"美式咖啡（Americano）\"></a>美式咖啡（Americano）</h3><p>很多咖啡馆的“当日咖啡”其实就是美式咖啡，这通常也是咖啡馆菜单上最便宜的一种。美式咖啡说白了，就是小半杯Esprssso兑上大半杯白开水，也有咖啡馆会使用滴滤式咖啡壶冲泡。美式咖啡味道淡、颜色浅，微酸微苦，但因为萃取时间长，所以咖啡因含量高。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-2.jpg\" alt=\"拿铁-白咖啡-康宝蓝\"></p>\n<h3 id=\"拿铁（Caffe-Latte）\"><a href=\"#拿铁（Caffe-Latte）\" class=\"headerlink\" title=\"拿铁（Caffè Latte）\"></a>拿铁（Caffè Latte）</h3><p>拿铁是Espresso与牛奶的经典混合，杯底先倒入少量Espresso，然后加入大量牛奶，顶端是浓密的一层泡沫，可以在奶泡上拉出各种各样的图案。经典的拿铁是70%牛奶+20%奶沫+10%咖啡，受法国人喜爱的欧蕾咖啡，是将牛奶和咖啡同时倒入杯中，两者在第一时间碰撞、混合，上加两勺打成泡沫的奶油，这在法国人的早餐中十分常见，几乎是国民饮料。</p>\n<h3 id=\"白咖啡（Flat-White）\"><a href=\"#白咖啡（Flat-White）\" class=\"headerlink\" title=\"白咖啡（Flat White）\"></a>白咖啡（Flat White）</h3><p>关于白咖啡网上有两种说法：</p>\n<ol>\n<li><p>白咖啡并不是马来西亚的那个特产，而是没有奶泡的拿铁。</p>\n</li>\n<li><p>马来西亚土特产，约有100多年的历史。白咖啡并不是指咖啡的颜色是白色的，而是采用特等咖啡豆及特级脱脂奶精原料，经特殊工艺加工后得到的咖啡，甘醇芳香不伤肠胃，保留了咖啡原有的色泽和香味，颜色比普通咖啡更清淡柔和，故得名为白咖啡。</p>\n</li>\n</ol>\n<h3 id=\"康宝蓝（Espresso-Con-Panna）\"><a href=\"#康宝蓝（Espresso-Con-Panna）\" class=\"headerlink\" title=\"康宝蓝（Espresso Con Panna）\"></a>康宝蓝（Espresso Con Panna）</h3><p>意大利语中，Con是搅拌，Panna是生奶油，康宝蓝即意式浓缩咖啡加上鲜奶油。有一种说法是，正宗的康宝蓝要配一颗巧克力或太妃糖，先将巧克力或太妃糖含在嘴里，再喝咖啡，让美味一起在口中绽放。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-3.jpg\" alt=\"布雷维-卡布奇诺-摩卡\"></p>\n<h3 id=\"布雷维-半拿铁（Cafe-Breve）\"><a href=\"#布雷维-半拿铁（Cafe-Breve）\" class=\"headerlink\" title=\"布雷维/半拿铁（Cafe Breve）\"></a>布雷维/半拿铁（Cafe Breve）</h3><p>很像拿铁，不同是加入了的不是牛奶，而是半牛奶、半奶油的混合物，有时会再加少许奶泡。公认的配方是：1份浓缩咖啡+0.75份热牛奶+0.75份鲜奶油+0.5份奶泡。</p>\n<h3 id=\"卡布奇诺（Cappuccino）\"><a href=\"#卡布奇诺（Cappuccino）\" class=\"headerlink\" title=\"卡布奇诺（Cappuccino）\"></a>卡布奇诺（Cappuccino）</h3><p>卡布奇诺和拿铁咖啡的成分一样，都是Espresso+牛奶+奶泡，不同之处仅在于卡布奇诺奶泡比牛奶多，拿铁则是牛奶比奶泡多。传统的卡布奇诺咖啡是三分之一浓缩咖啡，三分之一蒸汽牛奶和三分之一泡沫牛奶。同等价位的卡布奇诺，通常比拿铁要小杯，但咖啡味更浓郁。<br>卡布奇诺是意大利咖啡与牛奶的经典之作，咖啡的颜色就像卡布奇诺教会修士深褐色外衣上覆的头巾一样，咖啡因此得名。可根据自己口味调整牛奶与咖啡的比例，牛奶味重称为湿卡布奇诺，咖啡味重称为干卡布奇诺。</p>\n<h3 id=\"摩卡（Caffe-Mocha）\"><a href=\"#摩卡（Caffe-Mocha）\" class=\"headerlink\" title=\"摩卡（Caffè Mocha）\"></a>摩卡（Caffè Mocha）</h3><p>一种最古老的咖啡，得名于著名的摩卡港。摩卡的配方成分就相对比较复杂，在Espresso和牛奶的基础上，还有巧克力酱，顶端不是奶泡，而是打发的鲜奶油，还往往会挤上巧克力酱，或者撒上可可粉、肉桂粉，别有一番风味。由于“内容丰富”，通常售价较高，也比较大杯。巧克力和奶油都有甜味，因此摩卡咖啡是苦甜结合的典范。</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-4.jpg\" alt=\"焦糖玛奇朵-爱尔兰咖啡-维也纳咖啡\"></p>\n<h3 id=\"焦糖玛奇朵（Caramel-Macchiato）\"><a href=\"#焦糖玛奇朵（Caramel-Macchiato）\" class=\"headerlink\" title=\"焦糖玛奇朵（Caramel Macchiato）\"></a>焦糖玛奇朵（Caramel Macchiato）</h3><p>即加了焦糖的玛奇朵，是在香浓热牛奶上加入浓缩咖啡、香草，最后淋上纯正焦糖而制成的饮品，特点是在一杯饮品里可以喝到三种不同的口味。</p>\n<h3 id=\"爱尔兰咖啡（Irish-Coffee）\"><a href=\"#爱尔兰咖啡（Irish-Coffee）\" class=\"headerlink\" title=\"爱尔兰咖啡（Irish Coffee）\"></a>爱尔兰咖啡（Irish Coffee）</h3><p>爱尔兰咖啡（Irish Coffee）是一款鸡尾酒，是以爱尔兰威士忌为基酒，配以咖啡为辅料，调制而成的一款鸡尾酒。据说爱尔兰咖啡背后还有一段浪漫的爱情故事，不过我觉得就像卡农背后的爱情故事一样，不必较真。</p>\n<h3 id=\"维也纳咖啡（Viennese-Coffee）\"><a href=\"#维也纳咖啡（Viennese-Coffee）\" class=\"headerlink\" title=\"维也纳咖啡（Viennese Coffee）\"></a>维也纳咖啡（Viennese Coffee）</h3><p>奥地利最著名的咖啡，是一个名叫爱因·舒伯纳的马车夫发明的，也许是由于这个原因，今天，人们偶尔也会称维也纳咖啡为“单头马车”。在温热的咖啡杯底部撒上薄薄一层砂糖或细冰糖，接着向杯中倒入滚烫而且偏浓的黑咖啡，最后在咖啡表面装饰两勺冷的新鲜奶油，一杯维也纳咖啡就做好了。</p>\n<p>综上，发现除了浓缩咖啡和美式咖啡之外，其他咖啡的含糖量都不低。公司附近就有一家星巴克，实践是检验真理的唯一标准。一个星期上一种咖啡，也够我玩三个月了。</p>\n","categories":["日常"],"tags":["Coffee"]},{"title":"Objective-C中布尔类型","url":"http://icebergcwp.com/Objective-C的布尔类型.html","content":"<p> Objective-C中的BOOL类型在iWatch和64位iOS上的原始类型为bool，而在其它情况下是signed char。</p>\n<p>用@encode去看看BOOL的类型串：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@encode</span>(<span class=\"built_in\">BOOL</span>) <span class=\"comment\">// 64位iOS系统：\"B\"</span></span><br><span class=\"line\"><span class=\"keyword\">@encode</span>(<span class=\"built_in\">BOOL</span>) <span class=\"comment\">// 32位iOS系统，32/64位OS X：\"c\"</span></span><br></pre></td></tr></table></figure>\n<p>众所周知，在C\\C++语言中bool类型中的两个常量false为0，true为1，且非0值都被认为true。Objective-C是建立在C++基础的面相对象的语言，因此bool的定义应该也是如此。</p>\n<p>下面对两种情况分别讨论：</p>\n<p><strong>typeof BOOL bool</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> a = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>( a == <span class=\"literal\">YES</span> )</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">\"This is YES.\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">\"This is NO.\"</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：This is YES。说明变量被赋值为1，而非数字7。</p>\n<p><strong>typeof BOOL signed char</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> a = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>( a == <span class=\"literal\">YES</span> )</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">\"This is YES.\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">\"This is NO.\"</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：This is NO。说明变量被赋值为数字7。</p>\n<p>综上所述，在Objective-C中进行布尔比较时，不建议直接将布尔变量和YES或者true做比较，即：if( a == YES )。但是可以和NO或者false做比较，即：if( a != NO )，也可以写成if( a )或者if( !a )的形式。</p>\n","categories":["专业"],"tags":["Objective-C"]},{"title":"使用PlistBuddy命令动态修改APP名称","url":"http://icebergcwp.com/使用PlistBuddy动态修改APP名称.html","content":"<p>当一个工程里面包含多个target且每个target都有本地化的名称，一般做法是为每个target配备一个InfoList.strings文件。随着target数量和支持的语种增多，InfoList.strings文件数量也增加，更改和管理target名称也会变得复杂。</p>\n<p>我们可以在工程里面只保留一个InfoList.strings文件用于显示当前编译的target本地化名称，并且将所有target的本地化名称用一个plist文件统一管理，然后使用shell脚本和PlistBuddy命令在编译阶段动态修改target名称。以下是具体实现：</p>\n<p>假设工程中有4个target，本地化需求为英语（en）和西班牙语言（es）。</p>\n<p>1、在Xcode中创建一个名为ProductName.plist文件，并保存至工程根目录。注意：这个文件不需要和任何target关联。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plist</span> <span class=\"attr\">version</span>=<span class=\"string\">\"1.0\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>ProductId_1<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>en<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>ProductId_1_EnglistName<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>es<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>ProductId_1_SpanishName<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>ProductId_2<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>en<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>ProductId_2_EnglistName<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>es<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>ProductId_2_SpanishName<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>ProductId_3<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>en<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>ProductId_3_EnglistName<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>es<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>ProductId_3_SpanishName<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>ProductId_4<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>en<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>ProductId_4_EnglistName<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>es<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>ProductId_4_SpanishName<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2、Info.plist中有个叫CFBundleDisplayName的key决定APP的名称，创建一个InfoList.string文件并关联所有的target。在InfoList.string文件修改CFBundleDisplayName即可更改APP名称,格式如下所示：</p>\n<p>CFBundleDisplayName=”xxxxxxxxxx”;</p>\n<p>3、在project的“Build Settings”中新建一个“Use_Defined Setting”命名为MY_PRODUCTID，然后为每一个target设置对应的ID。此处分别为四个target命名为：ProductId_1、ProductId_2、ProductId_3、ProductId_4。</p>\n<p>4、在工程的“build Phases”界面中新建一个脚本块，脚本内容如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#PRODUCT_NAEMS_FILE_PATH的路径</span></span><br><span class=\"line\">PRODUCT_NAEMS_FILE_PATH=<span class=\"string\">\"<span class=\"variable\">$&#123;SRCROOT&#125;</span>/PRODUCT_NAEMS_FILE_PATH\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#获取对应ProductId的plist</span></span><br><span class=\"line\">/usr/libexec/PlistBuddy -c <span class=\"string\">\"print <span class=\"variable\">$&#123;MY_PRODUCTID&#125;</span>\"</span> -x <span class=\"string\">\"<span class=\"variable\">$&#123;PRODUCT_NAEMS_FILE_PATH&#125;</span>\"</span> &gt; <span class=\"string\">\"/var/tmp/<span class=\"variable\">$&#123;MY_PRODUCTID&#125;</span>.plist\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#获取ProductId.plist对应的本地化名称</span></span><br><span class=\"line\">EN_NAME=$(/usr/libexec/PlistBuddy -c <span class=\"string\">\"print en\"</span> <span class=\"string\">\"/var/tmp/<span class=\"variable\">$&#123;MY_PRODUCTID&#125;</span>.plist\"</span> )</span><br><span class=\"line\">ES_NAME=$(/usr/libexec/PlistBuddy -c <span class=\"string\">\"print es\"</span> <span class=\"string\">\"/var/tmp/<span class=\"variable\">$&#123;MY_PRODUCTID&#125;</span>.plist\"</span> )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#设置InfoPlist.strings对应的本地化文件中的CFBundleDisplayName字段值</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"CFBundleDisplayName=\\\"<span class=\"variable\">$&#123;EN_NAME&#125;</span>\\\";\"</span> &gt; <span class=\"string\">\"<span class=\"variable\">$&#123;SRCROOT&#125;</span>/en.lproj/InfoPlist.strings\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"CFBundleDisplayName=\\\"<span class=\"variable\">$&#123;ES_NAME&#125;</span>\\\";\"</span> &gt; <span class=\"string\">\"<span class=\"variable\">$&#123;SRCROOT&#125;</span>/es.lproj/InfoPlist.strings\"</span></span><br></pre></td></tr></table></figure>\n<p>5、编译target，即可在InfoPlist.strings看到对应的本地化名称。</p>\n","categories":["专业"],"tags":["PlistBuddy"]},{"title":"副词能否修辞名词？","url":"http://icebergcwp.com/副词能否修辞名词.html","content":"<blockquote>\n<p>之前知乎上看到一提问，大意是：The Lamb Astray中的Astray是形容词还是副词？副词是否能修辞名词？最近恰好在旋元佑先生的《文法俱乐部》一书中找到了合理的解释，借此机会梳理一下这个知识点。</p>\n</blockquote>\n<p>结合上述问题：The Lamb Astray中的Astray是形容词还是副词？副词是否能修辞名词？，可以从两个方面进行解答：</p>\n<ol>\n<li><p>The Lamb Astray中的Astray是形容词词性，属于形容词后置的情况</p>\n</li>\n<li><p>副词可以修辞名词</p>\n</li>\n</ol>\n<h3 id=\"形容词后置\"><a href=\"#形容词后置\" class=\"headerlink\" title=\"形容词后置\"></a>形容词后置</h3><p>形容词常见的所处位置包括名词片语、表语、主【宾】语补语，此外还有一个位置：名词后面，属于形容词后置的情况。</p>\n<p>在以下三种情况，形容词需要后置：</p>\n<ol>\n<li><p>复合名词后面：</p>\n<p> 类似someone这样的符合名词，因为限定词 some 和 名词 one 组合成一个词，原本名词片语中在限定词和名词之间存放形容的位置被挤压掉了，因此只能把形容词置于名词之后。</p>\n<p> 比如：</p>\n<ul>\n<li>someone else //其他人</li>\n<li>someone important //某些重要的人</li>\n</ul>\n</li>\n<li><p>一部分a-开头的形容词：</p>\n<p> 有一部分a-开头的形容词通常放在补语或者表语的位置，也可以放在名词片语后面。</p>\n<p> 比如：</p>\n<ul>\n<li>Jane and her mother alike are teather. //珍和她妈妈一样是老师</li>\n<li>Tom alone is coming. //只有汤姆要来</li>\n<li>wood adrift //漂流的木头</li>\n</ul>\n</li>\n<li><p>外来词或者惯用法：</p>\n<p> 英语中习惯把形容词放在名词前面，但是有些语言中例如法文，形容词是放在名词后面的。因此一些外来语或者惯用语，都要把形容词放在名词后面。</p>\n<p> 比如：</p>\n<ul>\n<li>Secretary General //秘书长</li>\n<li>Poet Laureate //桂冠诗人</li>\n<li>Aisa Minor //小亚细亚</li>\n<li>heir apparent //合法继承人</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"副词修辞名词\"><a href=\"#副词修辞名词\" class=\"headerlink\" title=\"副词修辞名词\"></a>副词修辞名词</h3><p>正如一般文法书上所说，一般情况下形容词修辞名词而副词则用于修辞除了名词以外的其他词类，包括形容词、动词和副词。这种说法基本上成立，但是也有特殊情况。</p>\n<p>存在一类表示强调功能的副词，可以修辞名词、动词、形容词和副词，修辞范围很广。也正因为如此，所以这类副词只能放在修饰词前面，确保修辞对象在其后面，以免出现歧义。</p>\n<p>这一类副词又可以细分为三种：</p>\n<ol>\n<li><p>强调范围的副词</p>\n<p> 典型代表：only, merely, also, especially, particularly, even等</p>\n<p> 以Only举例：</p>\n<ul>\n<li>I heard about the accident yesterday.  //我昨天听说了这件意外</li>\n<li>Only I heard about the accident yesterday. //只有我听说了…</li>\n<li>I only herad about the accident yesterday. //只是听说，并没有看到</li>\n<li>I heard about only the accident yesterday. //昨天全在听人在谈论这件意外</li>\n<li><p>I heard about the accident only yesterday. //直到昨天才听说</p>\n<p>这几个句子里only分别修饰了代名词I、动词heard、名词the accident和时间副词yesterday，都是当副词使用。</p>\n</li>\n</ul>\n</li>\n<li><p>强调语气的副词</p>\n<p> 这是最典型的副词，同样也可以修饰名词在内的四种主要词类。</p>\n<p> 举例如下：</p>\n<ul>\n<li>He is very much his father’s son.  //他和他爸爸一个调调</li>\n<li>You’re utterly insane! //你是完完全全疯了</li>\n<li>I badly need a drink.  //我急需来一杯</li>\n</ul>\n</li>\n<li><p>程度副词</p>\n<p> 这一类副词和加强语气的副词很像，但是程度副词是用来做有几成的表示，而非加强语气。所以，如果把加强语气的副词，只是语气变弱，意思不会变。但是如果拿掉程度副词，意思就可能发生改变。</p>\n<p> 举例：</p>\n<ul>\n<li>The project is almost finished. //项目已经完成的差不多了。<br>ps:上面的句子如果去掉almost，这句话的意思完全变了</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>旋元佑先生的《文法俱乐部》是一本不可多得的文法书，它区别于传统文法书的教条式+填鸭式的讲解方式，而是追本溯源，从理解本质和语言使用的角度为读者拨开文法的迷雾。    </p>\n","categories":["英语"],"tags":["英语"]},{"title":"揭秘dispatch_once的内部实现","url":"http://icebergcwp.com/揭秘dispatch_once.html","content":"<p>这是一篇译文，原文<a href=\"https://www.mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html\" target=\"_blank\" rel=\"noopener\">Secrets of dispatch</a>的作者是Mike Ash大神。在拜读这篇文章之后，颇有收获，不得不感叹Mike Ash专业知识的深度与广度。因此，我想试着进行翻译以加深理解。</p>\n<p><strong>以下是原文</strong></p>\n<p>一位名为Paul Kim的读者向我推荐了Micheal Tsai的一篇关于“让dispatch_once执行更快”的博客。虽然dispatch_once源代码中的注释精彩且详实，但是它并没有深入剖析那些让人着迷的细节。因为这是我最喜欢研究的方面之一，所以今天的文章我将进行深入地探究dispatch_once内部逻辑和实现原理。</p>\n<p>####API介绍####<br>dispatch_once函数顾名思义，它只执行一次且唯一的一次。函数接收两个参数，第一个参数是一个predicate，用于跟踪和保证函数的“一次性”；第二个参数是一个block，在函数第一次被调用时执行。调用方式如下所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> predicate;</span><br><span class=\"line\"><span class=\"built_in\">dispatch_once</span>(&amp;predicate , ^&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//执行一次性的任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个函数很适用于共享状态的“懒初始化”，适用范围包括全局字典、单例实体、缓存或者其他任何需要在第一次执行时进行配置的地方。</p>\n<p>在只有单线程的环境中，这种调用方式显得有些繁琐，用一个简单的if语句就能取而代之。然而，我们现在面临的都是多线程的运行环境，且diaspatch_once是线程安全的。这就保证了即使多个线程同时调用dispatch_once函数，函数也只执行一个block，并且所有线程直到block中的任务执行结束且dispatch_once退出之前都会处于阻塞状态。尽管你自己实现一个类似的函数不是很难，但是dispatch_once函数执行速度相当之快，并且实现的难度很大。</p>\n<p>####单线程版本####<br>让我们先看一个这个函数精简后的单线程版本。虽然这个版本没有实用性，但是让我们对这个函数有一个具体的视觉感官。注意到dispatch_once_t只是一个long整型，且初始化为0，根据实现被赋予不同的含义。以下是实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> SimpleOnce(<span class=\"built_in\">dispatch_once_t</span> *predicate, dispatch_block_t block) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!*predicate)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tblock();</span><br><span class=\"line\">\t\t*predicate = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现很简单：如果predicate是0，执行block且更新predicate的值为1。后续的函数调用会发现predicate未非0值便不会重复执行block。如果不是因为在多线程环境是不安全的，这完全就是我们想要的结果。糟糕的是，如果两个线程可能同时访问if语句，会导致block被调用两次。很不幸，这种情况时有发生，因此，让这份代码变成线程安全意味着一次实质性的成功。</p>\n<p>####性能####</p>\n<p>当谈及dispatch_once的性能时，主要有以下三种不同的情景：</p>\n<p>1、第一次调用dispatch_once时，指定一个predicate，并执行block.<br>2、在第一次调用dispatch_once之后且block未执行完之前，后续调用线程必须等待直到block执行完成。<br>3、在第一次调用dispatch_once且执行完成之后，后续调用不需要等待而是立即执行。</p>\n<p>情景1基本上不影响性能，毕竟只执行一次，只要block执行速度不是太慢。</p>\n<p>情景2同样不太影响性能。这个情况可能潜在地发生好几次，但是只有在block未执行完才会发生。大多数情况，这种情况几乎不会发生。如果发生了也可能是仅仅出现一次。甚至在极端测试下：很多线程同时调用dispatch_once并且block执行时间很长，后续处于等待的调用也局限在几千个以内。这些后续调用线程全都必须等待block执行完成，所以即使这些线程在等待过程中耗费了一些不必要的CPU时间也是无关紧要的。</p>\n<p>情景3则是性能高低的关键所在。这种性质的调用可能在程序中潜在发生成千上万次。我们想通过dispatch_once来保护那些一次性运算，运算结果被作为调用的返回值。理想情况下，dispatch_once的性能应该可以与直接读取一个提前初始化好的全局变量的性能媲美。换言之，一旦你面临情景3，我们想让下面两个代码块执行的效率是一样的。</p>\n<p>代码段1：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> gObject;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Compute(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tgObject = ....;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">id</span> Fetch(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码段2：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> DispatchFetch(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">id</span> object;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> predicate;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_once</span>(&amp;predicate, ^&#123;</span><br><span class=\"line\">            object = ...;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在被编译器内联处理和优化之后，SimpleOnce函数的执行效率接近DispatchFetch函数。在我电脑上测试，DispatchFetch函数执行时间为0.5纳秒。这无疑是线程安全版本中的黄金标准。</p>\n<p>如何自己实现一个的dispatch_once版本，关键在于确保线程安全，以下列出几种方式：</p>\n<p>####使用线程锁####</p>\n<p>常规的线程安全的做法是在共享数据访问前后添加锁。因为是示例代码，我决定只用一个单一的全局锁变量来做。代码中使用一个静态线程锁变量pthread_mutex_t来保护predicate的线程安全。在实际的项目中，随着函数被多个不同的类调用，伴随着很多不同的predicate变量，这将会是一个糟糕的设计。因为每一个互不关联的predicate变量必须一直等待当前被保护的predicate解锁才能获得执行机会。作为一个快速测试，这里我仅仅只测试一个predicate的情况。这份代码除了加了锁之外与前面的SimpleOnce函数没有区别：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> LockedOnce(<span class=\"built_in\">dispatch_once_t</span> *predicate, dispatch_block_t block) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!*predicate) &#123;</span><br><span class=\"line\">            block();</span><br><span class=\"line\">            *predicate = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码是线程安全的，但不幸的是执行速度太慢。在我的电脑上测试结果为每次调用需要30纳秒，相较于上述0.5纳秒的版本实在差太远。线程锁已经算很快的了，但不属于纳秒级别的。</p>\n<p>####使用自旋锁####</p>\n<p>自旋锁是一种试图将额外的开销降到最低的锁。顾名思义，自旋锁在处于需要等待的时候拥有“自旋”的功能，不断地轮询临锁的状态查看是否已经解锁。一般的锁都会配合操作系统休眠正在等待的线程，等解锁之后再唤醒所在的线程。这种锁虽然节省了CPU时间，但是这种协调休眠的机制也是有代价的。自旋锁不会休眠等待线程，因此在处于等待解锁的情况下节省了很多时间，付出的代价则是当多个线程试图获得自旋锁时效率会比较低。</p>\n<p>MacOS X提供了<a href=\"https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/spinlock.3.html\" target=\"_blank\" rel=\"noopener\">一套便利的自旋锁API</a>名为OSSpinLock.使用OSSinLock实现LockedOnce只需要在原有的基础修改几个名称：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> SpinlockOnce(<span class=\"built_in\">dispatch_once_t</span> *predicate, dispatch_block_t block) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">static</span> OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class=\"line\"></span><br><span class=\"line\">       OSSpinLockLock(&amp;lock);</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!*predicate) &#123;</span><br><span class=\"line\">           block();</span><br><span class=\"line\">           *predicate = <span class=\"number\">1</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       OSSpinLockUnlock(&amp;lock);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这次有了相当大的提升。在我电脑上测试结果为每次调用需要6.5纳秒，远好于pthread_mutex版本的每次调用30纳秒。然而于dispatch_once比起来还是太慢了。</p>\n<p>####原子操作####</p>\n<p>原子操作是底层CPU级别的操作且即使没有锁也一直都是线程安全。从技术层面来说，它们使用的硬件锁。使用锁会带来额外的开销，直接使用原子操作可以带来性能上的提升。多线程编程没有锁可能会显得很别捏，所以除非你真的需要原子操作，否则这不是明智的选择。我们现在讨论的是一个可能会被频繁使用的系统库，因此也许值得添加原子操作。</p>\n<p>原子操作创建锁的过程是“比较并交换”。这是一个类似于下面代码的简单操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> CompareAndSwap(<span class=\"keyword\">long</span> *ptr, <span class=\"keyword\">long</span> testValue, <span class=\"keyword\">long</span> newValue) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(*ptr ==  testValue) &#123;</span><br><span class=\"line\">\t\t*ptr = newValue;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总而言之，函数CompareAndSwap的功能用来测试内存的一个地址是否存储着一个特定的值，如果是则用新的值替换原有的值，返回结果表示匹配成功与否。因为“比较并交换”是一个CPU级的原子指令，所以即使有多个线程都试着对同一个内存区域进行“比较并交换”的操作都能确保其中只有一个操作能够成功。</p>\n<p>LockedOnce的这个版本的实现策略是对predicate赋予三个不同的值。0表示函数还未被调用过；1表示函数block正处于执行状态，后续调用线程则处于等待状态；2表示block执行完成且释放阻塞的等待线程并返回结果。</p>\n<p>“比较并交换”原子操作将被用于检测predicate的值是否为0，如果是则自动更新predicate为1。一旦原子操作返回的是YES，意味着当前线程是第一个调用线程，并开始唯一一次地block执行。在block执行完成后更新predicate的值为2作为标识.</p>\n<p>如果“比较并交换”原子操作执行失败意味着当前线程不是第一个调用者，然后线程进入一个循环，不断地检测predicate的值是否更新为2，直到predicate更新为2才退出循环。这将导致线程在block执行结束之前一直处于等待状态。</p>\n<p>以下是这个版本的函数的具体：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> AtomicBuiltinsOnce(<span class=\"built_in\">dispatch_once_t</span> *predicate, dispatch_block_t block) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将predicate指针转换成volatile指针，</span></span><br><span class=\"line\">\t<span class=\"comment\">//以告知编译器这个变量的值可能在函数执行过程中被其他线程更改，</span></span><br><span class=\"line\">\t<span class=\"comment\">//必须每次从内存地址取值，而非寄存器</span></span><br><span class=\"line\">\t<span class=\"keyword\">volatile</span> <span class=\"built_in\">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//调用“比较并交换”原子操作。</span></span><br><span class=\"line\">\t<span class=\"comment\">//Gcc编译器和clang编译器均提供了各种以_sync开头的内置函数以实现原子操作。</span></span><br><span class=\"line\">\t<span class=\"comment\">//下面的函数对predicate执行了“比较并交换”的原子操作，</span></span><br><span class=\"line\">\t<span class=\"comment\">//检测predicate的值是否为0，如果是则更新为1</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//执行block</span></span><br><span class=\"line\">\t\tblock();</span><br><span class=\"line\">\t\t<span class=\"comment\">//一旦block执行完成，更新predicate的值为2用以告知当前正在等待的调用线程以及未来的调用者block已经执行完成。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//然而，考虑到CPU的优化机制，我们使用内存屏障以确保volatilePredicate值的读书顺序是正确的。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//使用内置函数__sync_synchronize在此出设置内存屏障，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//确保volatilePredicate在block执行完后立即更新为2，且在此之前不可读。</span></span><br><span class=\"line\">\t\t__sync_synchronize();</span><br><span class=\"line\">\t\t<span class=\"comment\">//更新</span></span><br><span class=\"line\">\t\t*volatilePredicate = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//等待线程循环检测</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(*volatilePredicate != <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//线程返回之前设置内存屏障，匹配if语句中的内存屏障设置，保证volatilePredicate读取一致性</span></span><br><span class=\"line\">\t\t__sync_synchronize();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码满足需求且是线程安全的，但是性能一般。在我电脑上每次调用时间为20纳秒，明显高于自旋锁版本。</p>\n<p>####提前预判####</p>\n<p>这里有一个显而易见的优化可以添加到原子操作的版本中。因为通常情况下都是predicate的值已经是2，在函数最开始的地方加一个判断语句，可以在大多数情况下加快函数执行速度：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> EarlyBailoutAtomicBuiltinsOnce(<span class=\"built_in\">dispatch_once_t</span> *predicate, dispatch_block_t block) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*predicate == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            __sync_synchronize();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> <span class=\"built_in\">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            block();</span><br><span class=\"line\">            __sync_synchronize();</span><br><span class=\"line\">            *volatilePredicate = <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(*volatilePredicate != <span class=\"number\">2</span>)</span><br><span class=\"line\">                ;</span><br><span class=\"line\">            __sync_synchronize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这个版本的执行效率有相当大的提升，大约是调用一次11.5纳秒。然而，对比与dispatch_once版本还是相去甚远，甚至不如自旋锁版本。</p>\n<p>设置内存屏障有额外的开销，这也是为什么这个版本的执行速度比dispatch_once慢的原因所在。至于为什么会比自旋锁版本慢，是因为代码中设置了不同类型的内存屏障。__sync_synchronize函数会产生一个mfence的指令，这个指令是可能是最耗费资源的指令之一，然而OSSpinLock使用的是一个效率更高的指令。我们可以尝试不同的内存屏障以到达更好的效果，但是很明显代码最终的执行速度未达到我们预期结果，因为我打算弃用这种方法。</p>\n<p>####非线程安全的提前预判####</p>\n<p>这个版本与上面的版本很类似，只不过将内存屏障移除了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> UnsafeEarlyBailoutAtomicBuiltinsOnce(<span class=\"built_in\">dispatch_once_t</span> *predicate, dispatch_block_t block) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*predicate == <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> <span class=\"built_in\">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            block();</span><br><span class=\"line\">            *volatilePredicate = <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(*volatilePredicate != <span class=\"number\">2</span>)</span><br><span class=\"line\">                ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>不出意外，这个版本的执行速度与SimpleOnce一样都是0.5纳秒。因为*predicate == 2的适用于大多数情况，差不多每次调用都是检测predicate的值并返回。这个版本除了第一次执行block之外，几乎与SimpleOnce函数一样。</p>\n<p>正如函数名所示，这是一个非线程安全版本，缺少了内存屏障导致线程不安全。原因何在？</p>\n<p>####CPU流水线执行方式####</p>\n<p>我们可以将CPU想象成一个简单的机器，我们告诉它做什么，它就做什么。如此反复直到天荒地老。</p>\n<p>曾经有一段时间确实如此。老版的CPU的工作方式很简单，一眼一板。不幸的是，这种方式简单，容易且成本低，但是执行效率低。根据摩尔定律，CPU内置的晶体管成指数增长。8086CPU内置了大约29000个晶体管。一个英特尔处理器CPU集成了超过十亿的晶体管。</p>\n<p>根据市场需求决定了CPU拥有更好的效率，现在的CPU集成了越来越多的晶体管旨在让电脑运行速度更快。</p>\n<p>这里面有很多技巧让CPU执行的更快。其中一种就是流水线。执行单一的CPU指令，分成多个小步骤：</p>\n<ol>\n<li>从内存加载指令</li>\n<li>指令解码（分析指令解析包含哪些运算操作）</li>\n<li>加载输入数据</li>\n<li>结合输入执行运算</li>\n<li>保存输出数据</li>\n</ol>\n<p>在一个早期的CPU，上述流程执行步骤如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加载指令</span><br><span class=\"line\">解码</span><br><span class=\"line\">加载数据</span><br><span class=\"line\">运算</span><br><span class=\"line\">保存输出</span><br><span class=\"line\">加载下一个指令</span><br><span class=\"line\">解码</span><br><span class=\"line\">加载数据</span><br><span class=\"line\">运算</span><br><span class=\"line\">保存输出</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>在一个流水线型的CPU，执行步骤则如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加载指令  </span><br><span class=\"line\">解码\t\t\t\t加载指令\t\t</span><br><span class=\"line\">加载数据\t\t\t解码\t\t\t\t加载指令</span><br><span class=\"line\">运算\t\t\t\t加载数据\t\t\t解码</span><br><span class=\"line\">保存输出\t\t\t运算\t\t\t\t加载数据</span><br><span class=\"line\">\t\t\t\t\t保存输出\t\t\t运算</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t保存输出</span><br></pre></td></tr></table></figure>\n<p>这种方式执行速度快很多。随着CPU中的晶体管数量越来越多，CPU内部结构也越来越复杂，同步执行的指令也越来越多。<br>更有甚者，如果可以让速度更快，指令的执行顺序会被完全打乱。不同于上述简单的例子，真实情况下，指令更为复杂以及变量更多。</p>\n<p>代码执行的顺序并不以总是与代码本身的顺序一致的，比如下面的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">y = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>CPU可能会先写入Y变量的值。有些情况下编译器也会对语法重新排序，即便你屏蔽了编译器的行为，CPU仍然会乱序执行。如果是多核CPU，在其他的CPU看了写入的顺序是乱序的。即使是按代码顺序写入的，其他的CPU也会乱序读取。综合考虑，其它的线程在读取x和y的值时会发现y的值已经改变而x还是原来的值。</p>\n<p>在你需要这些值必须按照既定的顺序写入的时候，内存屏障就派上用场了。设置内存屏障以确保上述代码中x的值先被更新：</p>\n<ul>\n<li>x = 1;</li>\n<li>memory_barrier();</li>\n<li>y = 2;</li>\n</ul>\n<p>同样地，内存屏障可以确保读的顺序：</p>\n<ul>\n<li>use(x);</li>\n<li>memory_barrier();</li>\n<li>use(y);</li>\n</ul>\n<p>然而，因为内存屏障的主要功能导致CPU的执行速度，所以自然而然影响性能。</p>\n<p>对于dispatch_once来说，代码必须按照既定的顺序执行，因此必须设置内存屏障。但是，内存屏障会导致代码效率低下，所以为了避免额外的开销，我们想办法避免设置内存屏障。</p>\n<p>####CPU的分支预测和推测性执行####</p>\n<p>流水线和乱序工作模式适用于一系列线性执行的指令，但是对于添加分支语句则变得麻烦。CPU在分支语句执行完之前不知道下一步该执行什么指令，因此不得不停止运行等待前面的分支语句结束再重新运行。这就是所谓的pipeline stall，在一定程度上影响CPU性能。</p>\n<p>为了弥补pipeline stall带了的性能损失，CPU加入了推测性执行。当CPU遇到一个分支语句则会进行分支预测判断哪一个分支可能被执行。现在的CPU配置精密的分支预判硬件，准确率在90%以上。在做出预判之后，CPU开始执行假设的分支中的代码块，而不是等待分支语句的结果。如果分支预判是正确的则继续后续执行。如果预判错误则清空推测执行结果重新执行另外一个分支代码块。</p>\n<p>这种情况被用在了dispatch_once的读取端，这也是我们期望执行速度越快越好的地方。dispatch_once中有一个判断predicate的值得分支语句。CPU应该会预判并执行else分支，因为这个大多数情况下会执行的分支，即绕过block执行然后立即返回结果。在推测性执行过程中，CPU可能会从内存中加载那些后续需要但是还未被其他线程初始化的变量。如果分支预判是正确的，CPU会使用未初始化的值进行推测性执行。</p>\n<p>####非对称屏障####</p>\n<p>内存屏障一般都是需要对称的：在写的一端确保按照正确的顺序写入，在读的一端确保按照正确的顺序读取。然而，我们需要非对称屏障来满足我们的性能需求：我们可以容忍写入端的速度缓慢，但是让读的速度越快越好。</p>\n<p>这个技巧用来防范推测性执行导致的问题。当分支预判是错误的，推测性执行的结果会被弃用。如果dispatch_once可以在初始化完成之后强制确定CPU的分支预判，这个问题则可以被避免。</p>\n<p>此处有一个间隔时间，即最初的推测性执行到条件语句执行结束之间的间隔时间。间隔具体的时间因CPU而异，但是最多几十个CPU周期的时间。</p>\n<p>在英特尔CPU中，dispatch_once使用spuid指令到达上述目的。cpuid指令主要是用于获取CPU的ID和功能等信息，但是也可以强行序列化指令流并需要耗费几百个CPU周期的时间。</p>\n<p>在dispatch_once的源代码中，你会发现在读的一端没有使用内存屏障：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\"><span class=\"keyword\">void</span></span><br><span class=\"line\">_<span class=\"built_in\">dispatch_once</span>(<span class=\"built_in\">dispatch_once_t</span> *predicate, dispatch_block_t block)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DISPATCH_EXPECT(*predicate, ~<span class=\"number\">0</span>l) != ~<span class=\"number\">0</span>l) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_once</span>(predicate, block);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#define dispatch_once _dispatch_once</span></span><br></pre></td></tr></table></figure>\n<p>这段代码位于头文件中，并内联只调用者的代码块。DISPATCH_EXPECT宏告诉编译器去告知CPU：*predicate = ~0l是更有可能发生的分支。这可以提高分支预判的准确性，继而提升执行效率。基本上，这里只有一个普通的if语句，没有设置任何屏障。调用dispatch_once的执行速度接近0.5纳秒的黄金标准。</p>\n<p>在dispatch_once实现文件中可以看到写入端的实现，在block执行后立即执行了下面的宏：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_atomic_maximally_synchronizing_barrier();</span><br></pre></td></tr></table></figure>\n<p>在英特尔的CPU中，这个宏使用了cpuid指令，在其他的CPU框架中也会产生类似的指令。</p>\n<p>####结论####        </p>\n<p>多线程是最奇怪和复杂的地方，现代的CPU在背后做了很多不为认知的事情。内存屏障允许你告知硬件按照你需要的顺序执行代码，但是相应的需要在性能上做出牺牲。dispatch_once有着独一无二的需求，让CPU不走寻常路：在相关的内存写入完成之前牺牲足够多的等待时间，但是确保每一次读取都是高效安全的且不需要额外的内存屏障。            </p>\n","categories":["专业","翻译"],"tags":["GCD"]},{"title":"KVO的缺陷","url":"http://icebergcwp.com/KVO的缺陷.html","content":"<blockquote>\n<p>最近在学习和研究Cocoa库的KVO特性，期间发现大神Mike Ash的一篇关于讲述KVO缺陷的博客，觉得很有学习价值，遂想试着翻译以加深理解。</p>\n</blockquote>\n<p><a href=\"https://www.mikeash.com/pyblog/key-value-observing-done-right.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<h4 id=\"翻译\"><a href=\"#翻译\" class=\"headerlink\" title=\"翻译\"></a>翻译</h4><p>Cocoa的KVO特性强大和实用。可惜它的API真的有点糟糕，一些实现方式存在着固有的缺陷。我想探讨一下缺陷所在以及提供一套完善的方案。</p>\n<h5 id=\"缺陷何在？\"><a href=\"#缺陷何在？\" class=\"headerlink\" title=\"缺陷何在？\"></a>缺陷何在？</h5><p>KVO的API中存在三个主要的问题，全部都与类的多重继承结构注册监听器相关。这很重要，因为即便是基类NSObject（通过实现函数-bind:toObject:withKeyPath:options:）也会创建监听。</p>\n<p>1、-addObserver:forKeyPath:options:context:函数不接受一个自定义的回调函数</p>\n<p>如果你查阅过相似的APIs，比如NSNotificationCenter，你会发现在为一个指定的消息注册监听器时通常涉及到传入一个回调函数作为注册函数的参数。这样可以很容易将当前类的监听事件与父类进行区分，因为你可以直接将消息导向你自己的回调方法。然而，你使用KVO则不得不重载-observeValueForKeyPath:ofObject:change:context:函数，然后在其中处理你监听的事件或者调用父类实现。判断是否需要处理一个消息或是传递给继承链的上一层处理是个复杂的问题，事实上父类也有可能监听了同样的键值路径或者对象。</p>\n<p>2、上下文指针变成鸡肋</p>\n<p>这个是上一个问题的推论。因为你不能自定义监听的回调函数，也无法通过检测键值路径或者对象来判断父类是否也监听了某个消息。你需要采取其他途径来区分一个消息对象是否属于当前类或是其父类。上下文指针就是为此而生的。你必须创建一个唯一的指针且不会被父类使用，然后做完上下文参数传入函数-addObserver:forKeyPath:options:context:中。随后，你必须在回调函数-observeValueForKeyPath:ofObject:change:context:中检测参数context是否属于当前类。因此，你不能用上下文指针指向一个上下文，也意味着失去了其本该有的功能。</p>\n<p>3、-removeObserver:forKeyPath:接受的参数不完善</p>\n<p>这个函数不能传入上下文指针。这意味着如果当前类和父类在不同时期都监听了同样的对象或是键值路径，你没办法移除你自己的监听。调用这个函数可能注销你的监听，也可能是注销父类的，或是甚至同时注销两者。</p>\n<p>很可惜一个如此强大的工具会有这么严重的缺陷。尤其Apple开始在新的APIs中弱化NSNotification和代理回调的功能，取而代之的是KVO。一个典型的例子是NSOperation：获知一个NSOperation任务完成的唯一途径是通过使用KVO监听它的“isFinished”属性。</p>\n<h5 id=\"完善方案\"><a href=\"#完善方案\" class=\"headerlink\" title=\"完善方案\"></a>完善方案</h5><p>那么我们能为此做点什么？我不想一味地抱怨，所以我写了一个类来解决这个问题。你可以从我的<a href=\"https://github.com/mikeash/mikeash.com-svn/tree/master/\" target=\"_blank\" rel=\"noopener\">public svn repository</a>获取它，使用如下方式：</p>\n<p>svn co <a href=\"http://www.mikeash.com/svn/MAKVONotificationCenter/\" target=\"_blank\" rel=\"noopener\">http://www.mikeash.com/svn/MAKVONotificationCenter/</a></p>\n<p>你也可以点击上面的链接查看源代码。</p>\n<p>那么这个类具体实现是怎么样的？它利用了一个可以保证唯一性的指针：self指针。它不再直接使用目标对象注册某个监听通知（键值路径或者对象），取而代之的是为每个通知创建一个唯一的helper对象并且注册消息监听。随后，这个helper对象接收消息并派发给原有的监听者。因为helper对象对每一个监听者而言是唯一的，所以它可以以实例变量的方式持有关于监听者的元数据，而不需要依赖于上下文指针，至此上下文指针也完全作为函数所需的唯一指针。由于helper对象的职责就是监听KVO通知，监听者持有helper对象的生命周期，我们可以假设父类，NSObject，要么没有注册任何监听，要么监听同样持有一个helper作为监听助手。</p>\n<p>MAKVONotificationCenter避开了上述的三个缺陷：</p>\n<p>1、函数-addObserver:…中接受自定义回调函数作为参数，当被监听的键值路径发生变化时，自定义的回调函数会被调用。由于父类的回调函数是另外一个不同的函数，所以确保二者的监听不会互相干扰。</p>\n<p>2、注册监听的函数中提供一个userinfo参数。可以是一个包含监听者任意信息的对象。</p>\n<p>3、函数-removeObserver:…不再仅仅接受监听者和键值路径，还可以接受一个回调函数。这样即便子类和父类注册了同一键值路径或者同样的对象，二者都可以通过指定的回调函数注销监听，而不会影响彼此。</p>\n<p>代码中一些值得注意的特征：</p>\n<p>函数+defaultCenter中使用了<a href=\"https://www.mikeash.com/pyblog/late-night-cocoa.html\" target=\"_blank\" rel=\"noopener\">a simple lockless atomic call</a>保证了单例模式的线程安全，不需要每次访问时进行加锁处理。这是一个不错的技术，创建一个安全的单例对象，不需要在每次被访问时提前初始化或是进行加解锁处理。</p>\n<p>以NSObjct分类的方式提供一组更为轻便和更优的API。这是一个相比于直接访问MAKVONotificationCenter类的单例更好的方式。在一个极端的情况，MAKVONotificationCenter类可能会从头文件移除，留下的只有NSObject的分类实现。</p>\n<p>这份代码压根没有被测试过。我所做过的测试都在代码Tester.m中。在你使用之前不要轻易相信这份代码。150行代码并不算多，但是使用的后果自负。</p>\n<p>如果你希望在你的项目里使用它，你也许只要注明代码出处就可以了。如果发现了代码的不足欢迎提供补丁。</p>\n","categories":["专业","翻译"],"tags":["KVO"]},{"title":"两个特殊函数+load和+initialize","url":"http://icebergcwp.com/两个特殊函数+load和+initialize.html","content":"<p>记得还在上一家公司任职的时候，在研发部的探讨会会上就“+load的加载过程”这一议题有过激烈的讨论，大家各执一词，争得面红耳赤。最终是部门老大专门做了一期讲解，才平息了这场争执。但是那时候的讲解并未涉及到源代码分析，而是基于测试代码做的分析，故我并没有完全理解。</p>\n<p>在苹果开发文档中提及到：+load是在类或者分类被添加到runtime的时候被调用，而+initialize则是在类的用实例方法或者类方法第一次被调用之前调用。</p>\n<p>上面的说明只是说明了这两个函数调用时机，但是并没有涉及父类、子类和分类之间的调用顺序和相互影响，于是试着结合<a href=\"https://opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"noopener\">apple公司的开源代码</a>objc4-532.2试着分析这两个函数的加载过程，以加深理解。</p>\n<h4 id=\"load\"><a href=\"#load\" class=\"headerlink\" title=\"+load\"></a>+load</h4><p>首先在objc-os.mm文件中找到函数_objc_load_image_objc_load_image：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">OBJC_EXPORT <span class=\"keyword\">void</span> _objc_load_image(HMODULE image, header_info *hinfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    prepare_load_methods(hinfo);</span><br><span class=\"line\">    call_load_methods();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据参数判断，这个函数应该是在加载镜像文件的时候由系统直接调用，且里面就两行代码，分别是对+load函数的预处理与加载</p>\n<p>接着在objc-runtime-new.mm文件找查看prepare_load_methods的函数实现：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> prepare_load_methods(header_info *hi)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    size_t count, i;</span><br><span class=\"line\"></span><br><span class=\"line\">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class=\"line\">\t<span class=\"comment\">//获取头文件中所有的类</span></span><br><span class=\"line\">    classref_t *classlist = </span><br><span class=\"line\">        _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class=\"line\">    <span class=\"comment\">//先处理类中的+load方法</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理类与父类中的+load函数    schedule_class_load(remapClass(classlist[i]));</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t <span class=\"comment\">//再处理分类中的+load方法</span></span><br><span class=\"line\">    category_t **categorylist = _getObjc2NonlazyCategoryList(hi, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">    \t <span class=\"comment\">//初始化分类</span></span><br><span class=\"line\">        category_t *cat = categorylist[i];</span><br><span class=\"line\">        class_t *cls = remapClass(cat-&gt;cls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cls) <span class=\"keyword\">continue</span>;  <span class=\"comment\">// category for ignored weak-linked class</span></span><br><span class=\"line\">        realizeClass(cls);</span><br><span class=\"line\">        assert(isRealized(cls-&gt;isa));</span><br><span class=\"line\">        <span class=\"comment\">//将可加载的（存在+load函数）分类归类</span></span><br><span class=\"line\">        add_category_to_loadable_list((Category)cat);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> schedule_class_load(class_t *cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    assert(isRealized(cls));  <span class=\"comment\">// _read_images should realize</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Ensure superclass-first ordering</span></span><br><span class=\"line\">    <span class=\"comment\">//递归调用，优先处理父类</span></span><br><span class=\"line\">    schedule_class_load(getSuperclass(cls));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也就意味着父类中的+load方法先被加入列表</span></span><br><span class=\"line\">    add_class_to_loadable_list((Class)cls);</span><br><span class=\"line\">    changeInfo(cls, RW_LOADED, <span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由上述函数可以推断出：父类的+load方法先于子类被加入待处理列表，分类与类中的+load方法是区分对待的。</p>\n<p>接着，在objc-loadmethod.mm文件中查看call_class_loads函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> call_load_methods(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">BOOL</span> loading = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> more_categories;</span><br><span class=\"line\"></span><br><span class=\"line\">    recursive_mutex_assert_locked(&amp;loadMethodLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loading) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    loading = <span class=\"literal\">YES</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//先调用类中的+load方法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loadable_classes_used &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//先入先出处理+load函数列表</span></span><br><span class=\"line\">            call_class_loads();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">        <span class=\"comment\">// 2. Call category +loads ONCE</span></span><br><span class=\"line\">        <span class=\"comment\">//再调用分类中的+load函数</span></span><br><span class=\"line\">        more_categories = call_category_loads();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (loadable_classes_used &gt; <span class=\"number\">0</span>  ||  more_categories);</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_autoreleasePoolPop(pool);</span><br><span class=\"line\"></span><br><span class=\"line\">    loading = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> call_class_loads(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Detach current loadable list.</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> loadable_class *classes = loadable_classes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> used = loadable_classes_used;</span><br><span class=\"line\">    loadable_classes = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    loadable_classes_allocated = <span class=\"number\">0</span>;</span><br><span class=\"line\">    loadable_classes_used = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Call all +loads for the detached list.</span></span><br><span class=\"line\">    <span class=\"comment\">//先入先出的遍历顺序，调用父类函数先于子类</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; used; i++) &#123;</span><br><span class=\"line\">        Class cls = classes[i].cls;</span><br><span class=\"line\">        <span class=\"comment\">//获得+load的函数指针</span></span><br><span class=\"line\">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cls) <span class=\"keyword\">continue</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintLoading) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"LOAD: +[%s load]\\n\"</span>, _class_getName(cls));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">   \t\t  <span class=\"comment\">//注意：是通过函数指针直接调用，而非使用objc_msgSend，因此不会走runtime调用过程。</span></span><br><span class=\"line\">        (*load_method)(cls, SEL_load);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Destroy the detached list.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (classes) _free_internal(classes);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">BOOL</span> call_category_loads(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// Call all +loads for the detached list.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; used; i++) &#123;</span><br><span class=\"line\">        Category cat = cats[i].cat;</span><br><span class=\"line\">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class=\"line\">        Class cls;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cat) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        cls = _category_getClass(cat);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cls  &amp;&amp;  _class_isLoadable(cls)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (PrintLoading) &#123;</span><br><span class=\"line\">                _objc_inform(<span class=\"string\">\"LOAD: +[%s(%s) load]\\n\"</span>, </span><br><span class=\"line\">                             _class_getName(cls), </span><br><span class=\"line\">                             _category_getName(cat));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//直接通过函数指针进行调用，而非通过objc_msgSend调用</span></span><br><span class=\"line\">            (*load_method)(cls, SEL_load);</span><br><span class=\"line\">            cats[i].cat = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    .....</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_categories_added;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述函数中，先调用了类的+load函数列表，再处理分类中的+load函数，且都是直接通过函数指针调用。又因为父类的+load函数先于子类加入列表，因此+load函数的调用顺序是：父类-&gt;子类-&gt;分类</p>\n<p>在上一篇博客<a href=\"http://icebergcwp.com/2015/03/25/Objective-C%20Category%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/\">Objective-C Category 深入浅出系列之实现原理</a>中结合源代码分析了Category的实现原理。其中有一个重要的知识点就是分类Category中函数会覆盖主类中同名的函数。然而这种情况发生的前提是函数必须是通过runtime机制（使用objc_msgSend发送消息）调用，因为这样才会通过遍历类的方法列表去获得方法对应的实现。</p>\n<h4 id=\"initialize\"><a href=\"#initialize\" class=\"headerlink\" title=\"+initialize\"></a>+initialize</h4><p>既然+initialize函数是在类的实例方法或者类方法第一次被调用之前触发，而类的实例方法或者类方法正常的调用方式是通过objc_msgSend函数。那么+initialize很有可能是在objc_msgSend函数中进行判断和触发，于是，在objc-msg-x86_64.s文件找到了objc_msgSend的汇编实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/********************************************************************</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * id objc_msgSend(id self, SEL\t_cmd,...);</span><br><span class=\"line\"> *</span><br><span class=\"line\"> ********************************************************************/</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t.data</span><br><span class=\"line\">\t.align 3</span><br><span class=\"line\">\t.private_extern __objc_tagged_isa_table</span><br><span class=\"line\">__objc_tagged_isa_table:</span><br><span class=\"line\">\t.fill 16, 8, 0</span><br><span class=\"line\"></span><br><span class=\"line\">\tENTRY\t_objc_msgSend</span><br><span class=\"line\">\tDW_START _objc_msgSend</span><br><span class=\"line\"></span><br><span class=\"line\">\tNilTest\tNORMAL</span><br><span class=\"line\"></span><br><span class=\"line\">\tGetIsaFast NORMAL\t\t// r11 = self-&gt;isa</span><br><span class=\"line\">\tCacheLookup NORMAL, _objc_msgSend  // r11=method, eq set (nonstret fwd)</span><br><span class=\"line\">\tjmp\t*method_imp(%r11)\t// goto *imp</span><br><span class=\"line\"></span><br><span class=\"line\">\tNilTestSupport\tNORMAL</span><br><span class=\"line\"></span><br><span class=\"line\">\tGetIsaSupport\tNORMAL</span><br><span class=\"line\"></span><br><span class=\"line\">// cache miss: go search the method lists</span><br><span class=\"line\">LCacheMiss:</span><br><span class=\"line\">\tDW_MISS _objc_msgSend</span><br><span class=\"line\">\tGetIsa\tNORMAL\t\t\t// r11 = self-&gt;isa</span><br><span class=\"line\">\tMethodTableLookup %a1, %a2, _objc_msgSend\t// r11 = IMP</span><br><span class=\"line\">\tcmp\t%r11, %r11\t\t// set eq (nonstret) for forwarding</span><br><span class=\"line\">\tjmp\t*%r11\t\t\t// goto *imp</span><br><span class=\"line\"></span><br><span class=\"line\">\tDW_END \t\t_objc_msgSend, 1, 1</span><br><span class=\"line\">\tEND_ENTRY\t_objc_msgSend</span><br><span class=\"line\"></span><br><span class=\"line\">#if __OBJC2__</span><br><span class=\"line\">\tENTRY _objc_msgSend_fixup</span><br><span class=\"line\">\tDW_START _objc_msgSend_fixup</span><br><span class=\"line\"></span><br><span class=\"line\">\tNilTest\tNORMAL</span><br><span class=\"line\"></span><br><span class=\"line\">\tSaveRegisters _objc_msgSend_fixup</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// Dereference obj/isa/cache to crash before _objc_fixupMessageRef</span><br><span class=\"line\">\tmovq\t8(%a2), %a6\t\t// selector</span><br><span class=\"line\">\tGetIsa\tNORMAL\t\t\t// r11 = isa = *receiver</span><br><span class=\"line\">\tmovq\tcache(%r11), %a5\t// cache = *isa</span><br><span class=\"line\">\tmovq\tmask(%a5), %a4\t\t// *cache</span><br><span class=\"line\"></span><br><span class=\"line\">\t// a1 = receiver</span><br><span class=\"line\">\t// a2 = address of message ref</span><br><span class=\"line\">\tmovq\t%a2, %a3</span><br><span class=\"line\">\txorl\t%a2d, %a2d</span><br><span class=\"line\">\t// __objc_fixupMessageRef(receiver, 0, ref)</span><br><span class=\"line\">\tcall\t__objc_fixupMessageRef</span><br><span class=\"line\">\tmovq\t%rax, %r11</span><br><span class=\"line\"></span><br><span class=\"line\">\tRestoreRegisters _objc_msgSend_fixup</span><br><span class=\"line\"></span><br><span class=\"line\">\t// imp is in r11</span><br><span class=\"line\">\t// Load _cmd from the message_ref</span><br><span class=\"line\">\tmovq\t8(%a2), %a2</span><br><span class=\"line\">\tcmp\t%r11, %r11\t\t// set nonstret (eq) for forwarding</span><br><span class=\"line\">\tjmp \t*%r11</span><br><span class=\"line\"></span><br><span class=\"line\">\tNilTestSupport\tNORMAL</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tDW_END \t\t_objc_msgSend_fixup, 0, 1</span><br><span class=\"line\">\tEND_ENTRY \t_objc_msgSend_fixup</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tSTATIC_ENTRY _objc_msgSend_fixedup</span><br><span class=\"line\">\t// Load _cmd from the message_ref</span><br><span class=\"line\">\tmovq\t8(%a2), %a2</span><br><span class=\"line\">\tjmp\t_objc_msgSend</span><br><span class=\"line\">\tEND_ENTRY _objc_msgSend_fixedup</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>汇编基本就是大一水平，很有限。初略发现在调用指令_objc_msgSend之前，先调用了_objc_fixupMessageRef函数。</p>\n<p>接着在objc-runtime-new.mm文件中找到_objc_fixupMessageRef函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">OBJC_EXTERN IMP </span><br><span class=\"line\">_objc_fixupMessageRef(<span class=\"keyword\">id</span> obj, <span class=\"keyword\">struct</span> objc_super2 *supr, message_ref_t *msg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    IMP imp;</span><br><span class=\"line\">    class_t *isa;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t.....</span><br><span class=\"line\"></span><br><span class=\"line\">    msg-&gt;sel = sel_registerName((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)msg-&gt;sel);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ignoreSelector(msg-&gt;sel)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignored selector - bypass dispatcher</span></span><br><span class=\"line\">        msg-&gt;imp = (IMP)&amp;vtable_ignored;</span><br><span class=\"line\">        imp = (IMP)&amp;_objc_ignored_method;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#if SUPPORT_VTABLE</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (msg-&gt;imp == (IMP)&amp;objc_msgSend_fixup  &amp;&amp;  </span><br><span class=\"line\">        (vtableIndex = vtable_getIndex(msg-&gt;sel)) &gt;= <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// vtable dispatch</span></span><br><span class=\"line\">        msg-&gt;imp = vtableTrampolines[vtableIndex];</span><br><span class=\"line\">        imp = isa-&gt;vtable[vtableIndex];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ordinary dispatch</span></span><br><span class=\"line\">        <span class=\"comment\">//常规的消息派发，遍历类的函数列表</span></span><br><span class=\"line\">        imp = lookUpMethod((Class)isa, msg-&gt;sel, <span class=\"literal\">YES</span><span class=\"comment\">/*initialize*/</span>, <span class=\"literal\">YES</span><span class=\"comment\">/*cache*/</span>, obj);</span><br><span class=\"line\">        </span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述函数中调用了lookUpMethod函数，其中调用了prepareForMethodLookup函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">IMP prepareForMethodLookup(Class cls, SEL sel, <span class=\"built_in\">BOOL</span> init, <span class=\"keyword\">id</span> obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rwlock_assert_unlocked(&amp;runtimeLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isRealized(newcls(cls))) &#123;</span><br><span class=\"line\">        rwlock_write(&amp;runtimeLock);</span><br><span class=\"line\">        realizeClass(newcls(cls));</span><br><span class=\"line\">        rwlock_unlock_write(&amp;runtimeLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//调用_class_initialize对类进行初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (init  &amp;&amp;  !_class_isInitialized(cls)) &#123;</span><br><span class=\"line\">        _class_initialize (_class_getNonMetaClass(cls, obj));</span><br><span class=\"line\">        <span class=\"comment\">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class=\"line\">        <span class=\"comment\">// then the messenger will send +initialize again after this </span></span><br><span class=\"line\">        <span class=\"comment\">// procedure finishes. Of course, if this is not being called </span></span><br><span class=\"line\">        <span class=\"comment\">// from the messenger then it won't happen. 2778172</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在objc-initialize.mm函数中，找到_class_initialize函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _class_initialize(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    assert(!_class_isMetaClass(cls));</span><br><span class=\"line\"></span><br><span class=\"line\">    Class supercls;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> reallyInitialize = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class=\"line\">    <span class=\"comment\">// See note about deadlock above.</span></span><br><span class=\"line\">    <span class=\"comment\">//递归，保证父类先于子类初始化</span></span><br><span class=\"line\">    supercls = _class_getSuperclass(cls);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (supercls  &amp;&amp;  !_class_isInitialized(supercls)) &#123;</span><br><span class=\"line\">        _class_initialize(supercls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t.....</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reallyInitialize) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Record that we're initializing this class so we can message it.</span></span><br><span class=\"line\">        _setThisThreadIsInitializingClass(cls);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Send the +initialize message.</span></span><br><span class=\"line\">        <span class=\"comment\">// Note that +initialize is sent to the superclass (again) if </span></span><br><span class=\"line\">        <span class=\"comment\">// this class doesn't implement +initialize. 2157218</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintInitializing) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"INITIALIZE: calling +[%s initialize]\"</span>,</span><br><span class=\"line\">                         _class_getName(cls));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过objc_msgSend调用+initialize函数</span></span><br><span class=\"line\">        ((<span class=\"keyword\">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintInitializing) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"INITIALIZE: finished +[%s initialize]\"</span>,</span><br><span class=\"line\">                         _class_getName(cls));</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Done initializing. </span></span><br><span class=\"line\">        <span class=\"comment\">// If the superclass is also done initializing, then update </span></span><br><span class=\"line\">        <span class=\"comment\">//   the info bits and notify waiting threads.</span></span><br><span class=\"line\">        <span class=\"comment\">// If not, update them later. (This can happen if this +initialize </span></span><br><span class=\"line\">        <span class=\"comment\">//   was itself triggered from inside a superclass +initialize.)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        .....</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述函数可知两点：一是父类的+initialize函数先于子类调用，二是+initialize不同于+load函数的采用函数指针调用，而是通过objc_msgSend函数调用，如果分类实现了+initialize函数，那么类（包括子类和父类）的+initialize函数就会被覆盖。</p>\n<p>因此，+initialize的调用顺序是父类-&gt;子类，且分类的实现覆盖类的实现，因此分类中的+initialize可能会被多次调用。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>至此，对于+load和+initialize的调用规则和方式有了进一步的认识。在日后的编程过程中也可以根据二者的特点，更好的使用它们的功能。</p>\n","categories":["专业"],"tags":["Objective-C"]},{"title":"Objective-C Category 深入浅出系列-第1话","url":"http://icebergcwp.com/Objective-C Category的实现原理.html","content":"<p>Objective-C Category（分类）之于我而言有种神秘感，虽然自己已经在实际开发过程中已经多次使用它，且感受到了它带来的便利与高效。但是我却仅仅是停留在对它的基本使用层面，除此之外一无所知。我能感觉它的强大，心中也一直有种对它内部实现一探究竟的冲动，奈何迟迟没有行动。时间愈久，这种情绪愈发浓烈，今天终究是按耐不住了…</p>\n<h3 id=\"知其然\"><a href=\"#知其然\" class=\"headerlink\" title=\"知其然\"></a>知其然</h3><p>对于苹果应用开发者来说，开发者想要快速地了解或是回顾某个知识点，<a href=\"https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1\" target=\"_blank\" rel=\"noopener\">Apple开发者文档</a>往往是不二首选。</p>\n<p>文档上如是说：你可以使用Category为一个已经存在的类添加额外的方法，比如Cocoa库中的类，即便是这个类的源代码是不可见的-不能子类化。使用Category给类添加的方法能被其子类继承，且在Runtime下其与类原有的方法是无差别的。</p>\n<p>分类的使用场景：</p>\n<ul>\n<li>在不改变某个类源文件和不使用继承的前提下，为该类添加先的方法</li>\n<li>声明类的私有方法</li>\n<li>将一个类的实现拆分为多个独立的源文件</li>\n</ul>\n<p>很明显，Category其实就是设计模式之一的装饰者模式的具体实现。</p>\n<p> <em>注意，Category是一个类的拓展，为不是一个新类。</em></p>\n<p>借助Apple开发者文档了解到Category的“知其然”，然后就是基于<a href=\"https://opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"noopener\">Apple Opensource</a>来解决“知其所以然”的问题？</p>\n<h3 id=\"知其然所以然\"><a href=\"#知其然所以然\" class=\"headerlink\" title=\"知其然所以然\"></a>知其然所以然</h3><p> 此处使用的源码版本是objc4-532.2。与本文相关的代码都在源文件objc-runtime-new.mm中，接下来就结合关键的代码与注释进行分析。</p>\n<p> Catrgory的定义</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> category_t &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    classref_t cls;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *instanceMethods;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *classMethods;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> property_list_t *instanceProperties;</span><br><span class=\"line\">&#125; category_t;</span><br></pre></td></tr></table></figure>\n<p> 通过Category的定义可以看出，Category与Class存在很相似。不过Category没有isa指针，这也说明Category不是一个类，只能作为一个类的拓展存在。</p>\n<p> 关键Method-1: _read_images()</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">void</span> _read_images(header_info **hList, uint32_t hCount)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#define EACH_HEADER \\</span></span><br><span class=\"line\">hIndex = <span class=\"number\">0</span>;         \\</span><br><span class=\"line\">crashlog_header_name(<span class=\"literal\">NULL</span>) &amp;&amp; hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]) &amp;&amp; crashlog_header_name(hi); \\</span><br><span class=\"line\">hIndex++</span><br><span class=\"line\">   </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Discover categories.</span></span><br><span class=\"line\">    <span class=\"comment\">//遍历工程中所有的头文件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (EACH_HEADER) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Category列表</span></span><br><span class=\"line\">        category_t **catlist =</span><br><span class=\"line\">        _getObjc2CategoryList(hi, &amp;count);</span><br><span class=\"line\">        <span class=\"comment\">//遍历Category列表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            category_t *cat = catlist[i];</span><br><span class=\"line\">            <span class=\"comment\">//Category拓展的类的指针</span></span><br><span class=\"line\">            class_t *cls = remapClass(cat-&gt;cls);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cls) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Category's target class is missing (probably weak-linked).</span></span><br><span class=\"line\">                <span class=\"comment\">// Disavow any knowledge of this category.</span></span><br><span class=\"line\">                catlist[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"</span></span><br><span class=\"line\">                                 <span class=\"string\">\"missing weak-linked target class\"</span>,</span><br><span class=\"line\">                                 cat-&gt;name, cat);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// Process this category.</span></span><br><span class=\"line\">            <span class=\"comment\">// First, register the category with its target class.</span></span><br><span class=\"line\">            <span class=\"comment\">// Then, rebuild the class's method lists (etc) if</span></span><br><span class=\"line\">            <span class=\"comment\">// the class is realized.</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//检测目标类是否已实现</span></span><br><span class=\"line\">            <span class=\"built_in\">BOOL</span> classExists = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class=\"line\">                ||  cat-&gt;instanceProperties)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isRealized(cls)) &#123;</span><br><span class=\"line\">                    remethodizeClass(cls);</span><br><span class=\"line\">                    classExists = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: found category -%s(%s) %s\"</span>,</span><br><span class=\"line\">                                 getName(cls), cat-&gt;name,</span><br><span class=\"line\">                                 classExists ? <span class=\"string\">\"on existing class\"</span> : <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//Categoty存在方法列表或者协议列表</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class=\"line\">                <span class=\"comment\">/* ||  cat-&gt;classProperties */</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//关键函数块</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//添加Category到目标类</span></span><br><span class=\"line\">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//重构目标类的方法列表</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isRealized(cls-&gt;isa)) &#123;</span><br><span class=\"line\">                \t<span class=\"comment\">//关键函数！</span></span><br><span class=\"line\">                    remethodizeClass(cls-&gt;isa);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: found category +%s(%s)\"</span>,</span><br><span class=\"line\">                                 getName(cls), cat-&gt;name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Category discovery MUST BE LAST to avoid potential races</span></span><br><span class=\"line\">    <span class=\"comment\">// when other threads call the new category code before</span></span><br><span class=\"line\">    <span class=\"comment\">// this thread finishes its fixups.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// +load handled by prepare_load_methods()</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#undef EACH_HEADER</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> _read_images()是赋值读取镜像文件的函数，函数末尾就是处理Category的代码块。其中将工程中所有的Category分别与其目标类建立关联，然后调用了remethodizeClass()对目标类的进行重构。</p>\n<p> 关键Method-2: remethodizeClass()</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> remethodizeClass(class_t *cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    category_list *cats;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> isMeta;</span><br><span class=\"line\">    </span><br><span class=\"line\">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//识别目标类是否为元类</span></span><br><span class=\"line\">    isMeta = isMetaClass(cls);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Re-methodizing: check for more categories</span></span><br><span class=\"line\">    <span class=\"comment\">//重构目标类的方法列表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cats = unattachedCategoriesForClass(cls))) &#123;</span><br><span class=\"line\">        chained_property_list *newproperties;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> protocol_list_t **newprotos;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"CLASS: attaching categories to class '%s' %s\"</span>,</span><br><span class=\"line\">                         getName(cls), isMeta ? <span class=\"string\">\"(meta)\"</span> : <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Update methods, properties, protocols</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> vtableAffected = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//添加Category中的方法到目标类</span></span><br><span class=\"line\">        <span class=\"comment\">//关键函数！</span></span><br><span class=\"line\">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//将Category中的属性插入属性链表的头部，只有匿名Category才能额外添加属性</span></span><br><span class=\"line\">        newproperties = buildPropertyList(<span class=\"literal\">NULL</span>, cats, isMeta);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newproperties) &#123;</span><br><span class=\"line\">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</span><br><span class=\"line\">            cls-&gt;data()-&gt;properties = newproperties;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//将Category中的协议加入目标类</span></span><br><span class=\"line\">        <span class=\"comment\">//查看buildProtocolList函数得知，新的协议的加入目标类原有协议的尾部</span></span><br><span class=\"line\">        newprotos = buildProtocolList(cats, <span class=\"literal\">NULL</span>, cls-&gt;data()-&gt;protocols);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) &#123;</span><br><span class=\"line\">            _free_internal(cls-&gt;data()-&gt;protocols);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cls-&gt;data()-&gt;protocols = newprotos;</span><br><span class=\"line\">        </span><br><span class=\"line\">        _free_internal(cats);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Update method caches and vtables</span></span><br><span class=\"line\">        flushCaches(cls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (vtableAffected) flushVtables(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> remethodizeClass()函数的功能比较简单，进一步细化了对Category中的方法列表、协议列表和属性列表的处理。其中，属性列表的处理则是直接插入原属性链表头部，协议列表则是附加到原协议列表的尾部。接下来，重点分析处理Category方法列表的attachCategoryMethods函数。</p>\n<p>关键Method-3: attachCategoryMethods()</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class=\"line\">                      <span class=\"built_in\">BOOL</span> *inoutVtablesAffected)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> isMeta = isMetaClass(cls);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//为每个Category分配函数列表</span></span><br><span class=\"line\">    method_list_t **mlists = (method_list_t **)</span><br><span class=\"line\">    _malloc_internal(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> fromBundle = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"comment\">//汇总所有Category的拓展方法</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</span><br><span class=\"line\">            mlists[mcount++] = mlist;</span><br><span class=\"line\">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//关键函数!</span></span><br><span class=\"line\">    <span class=\"comment\">//将Category中的拓展方法加入到目标类</span></span><br><span class=\"line\">    attachMethodLists(cls, mlists, mcount, <span class=\"literal\">NO</span>, fromBundle, inoutVtablesAffected);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _free_internal(mlists);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>attachCategoryMethods()函数的功能也比较简单，对与目标类的Category中所有方法进行汇总，然后调用attachMethodLists函数进行处理。</p>\n<p>关键Method-4: attachMethodLists()</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachMethodLists(class_t *cls, method_list_t **addedLists, <span class=\"keyword\">int</span> addedCount,</span><br><span class=\"line\">                  <span class=\"built_in\">BOOL</span> baseMethods, <span class=\"built_in\">BOOL</span> methodsFromBundle,</span><br><span class=\"line\">                  <span class=\"built_in\">BOOL</span> *inoutVtablesAffected)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Method list array is NULL-terminated.</span></span><br><span class=\"line\">    <span class=\"comment\">// Some elements of lists are NULL; we must filter them out.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//方法列表以NULL作为结束符，因此需要过滤掉目标类中的NULL函数</span></span><br><span class=\"line\">    method_list_t *oldBuf[<span class=\"number\">2</span>];</span><br><span class=\"line\">    method_list_t **oldLists;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY) &#123;</span><br><span class=\"line\">        oldLists = cls-&gt;data()-&gt;method_lists;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        oldBuf[<span class=\"number\">0</span>] = cls-&gt;data()-&gt;method_list;</span><br><span class=\"line\">        oldBuf[<span class=\"number\">1</span>] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        oldLists = oldBuf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (oldLists[oldCount]) oldCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCount = oldCount;</span><br><span class=\"line\">    <span class=\"comment\">//同上，过滤掉Category方法列表中的NULL函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addedLists[i]) newCount++;  <span class=\"comment\">// only non-NULL entries get added</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建新的方法列表</span></span><br><span class=\"line\">    method_list_t *newBuf[<span class=\"number\">2</span>];</span><br><span class=\"line\">    method_list_t **newLists;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCount &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        newLists = (method_list_t **)</span><br><span class=\"line\">        _malloc_internal((<span class=\"number\">1</span> + newCount) * <span class=\"keyword\">sizeof</span>(*newLists));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newLists = newBuf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Add method lists to array.</span></span><br><span class=\"line\">    <span class=\"comment\">// Reallocate un-fixed method lists.</span></span><br><span class=\"line\">    <span class=\"comment\">// The new methods are PREPENDED to the method list array.</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    newCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//先将Category加入到新的方法列表</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class=\"line\">        method_list_t *mlist = addedLists[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mlist) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Fixup selectors if necessary</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isMethodListFixedUp(mlist)) &#123;</span><br><span class=\"line\">            mlist = fixupMethodList(mlist, methodsFromBundle, <span class=\"literal\">true</span><span class=\"comment\">/*sort*/</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Fill method list array</span></span><br><span class=\"line\">        newLists[newCount++] = mlist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Copy old methods to the method list array、</span></span><br><span class=\"line\">    <span class=\"comment\">//再将目标类原方法加入新的方法列表</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class=\"line\">        newLists[newCount++] = oldLists[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLists  &amp;&amp;  oldLists != oldBuf) free(oldLists);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// NULL-terminate</span></span><br><span class=\"line\">    newLists[newCount] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//更新目标类的方法列表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCount &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        assert(newLists != newBuf);</span><br><span class=\"line\">        cls-&gt;data()-&gt;method_lists = newLists;</span><br><span class=\"line\">        changeInfo(cls, RW_METHOD_ARRAY, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        assert(newLists == newBuf);</span><br><span class=\"line\">        cls-&gt;data()-&gt;method_list = newLists[<span class=\"number\">0</span>];</span><br><span class=\"line\">        assert(!(cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>attachMethodLists才是最关键的函数。函数中为目标类分配了一个新的函数列表，先加入Category中的方法，再加入目标类原有方法。这也就是为什么如果Category中的函数与目标类中的函数重名，那么目标类的函数会被覆盖的原因。因为Runtime在遍历方法列表时会先发现Category中的函数。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>这篇博客基于源代码对Category与目标类的组合过程进行了分析，明白了Category中的方法、协议和属性的处理流程。因此，我们可以更加高效和准确地使用Category，甚至利用其中存在的“漏洞”实现一些小魔法。</p>\n","categories":["专业"],"tags":["Category"]},{"title":"揭开ARC的神秘面纱系列-第3话","url":"http://icebergcwp.com/揭开ARC的神秘面纱系列-第3话.html","content":"<p><a href=\"http://www.galloway.me.uk/2012/02/a-look-under-arcs-hood-episode-3/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>“揭开ARC的神秘面纱系列”的这篇续集全都是关于@autoreleasepool这一新指令的。<a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html#autoreleasepool\" target=\"_blank\" rel=\"noopener\">LLVM提及到</a>autorelease pools（自动释放池）的语义已经在LLVM3.0版本中发生变化，尤其是，我觉得探究ARC模式更新之后是如何实现的会很有意思。</p>\n<p>因此，思考一下下面的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> foo() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSNumber</span> *number = [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"number = %p\"</span>, number);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然，这完全是不和谐的代码段，但是它能让我看到发生什么。在非ARC模式下，我们可能会假设：number将会在numberWithInt:函数中被分配内存，并返回的是一个自动释放的对象。因此当自动释放池随后被销毁时，number对象将会被释放。所以让我们看看是否如上所述（一如往常，使用的是ARMv7指令集）：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.globl</span>  _foo</span><br><span class=\"line\">    <span class=\"meta\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     _foo</span><br><span class=\"line\"><span class=\"symbol\">_foo</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span>, <span class=\"number\">#4</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleasePoolPush</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movs </span>   <span class=\"built_in\">r2</span>, <span class=\"number\">#0</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r4</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L__unnamed_cfstring_-(LPC0_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L__unnamed_cfstring_-(LPC0_2+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _NSLog</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r4</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleasePoolPop</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>不错，答案是肯定的。正是这样的。我们可以看到函数先将自动释放池入栈，然后调用numberWithInt:函数，然后将自动释放池出栈。正如我们所预料的。现在我们看看完全相同的代码在ARC模式编译出来是怎么样的：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.globl</span>  _foo</span><br><span class=\"line\">    <span class=\"meta\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     _foo</span><br><span class=\"line\"><span class=\"symbol\">_foo</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r5</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span>, <span class=\"number\">#8</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleasePoolPush</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movs </span>   <span class=\"built_in\">r2</span>, <span class=\"number\">#0</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r4</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"comment\">@ InlineAsm Start</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">r7</span>          <span class=\"comment\">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class=\"line\">    <span class=\"comment\">@ InlineAsm End</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_retainAutoreleasedReturnValue</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r5</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L__unnamed_cfstring_-(LPC0_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L__unnamed_cfstring_-(LPC0_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">r5</span></span><br><span class=\"line\"><span class=\"symbol\">LPC0_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _NSLog</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r5</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_release</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r4</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleasePoolPop</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r5</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>留意上述代码中objc_retainAutoreleasedReturnValue函数和objc_release的调用。ARC已经为我们做了决定，完全不必担心自动释放池，因为ARC可以直接不然自动释放池生效，通过调用objc_retainAutoreleasedReturnValue函数对number对象进行retain一次，然后在后面在调用objc_release函数释放它。这意味着自动释放池的逻辑不一定执行，让人满意的结果。</p>\n<p>注意到自动释放池一直需要入栈和出栈，是因为ARC无法知晓numberWithInt函数和NSLog函数中会发生什么，不知道在函数中是否有对象会被加入释放池。如果说ARC知道这两个函数不会自动释放任何东西则实际上可以移除自动释放池的入栈和出栈操作。也许这种逻辑在ARC未来的版本中出现，尽管我不是很确定那时候ARC的语义会如何实现。</p>\n<p>现在让我思考另外一个例子，在这个例子中我们想要在自动释放池的作用域之外使用number对象。这应该告诉我们为什么ARC是一个神奇的工具。思考下面的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> bar() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSNumber</span> *number;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        number = [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"number = %p\"</span>, number);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"number = %p\"</span>, number);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可能会认为上述这段看似很和谐的代码会出问题。问题在于number对象将在自动释放池中创建，在自动释放池初衷时被释放，但是却在释放之后继续使用。噢！让我们通过在非ARC模式下编译上述代码来看看我们的猜想是否是正确的：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.globl</span>  _bar</span><br><span class=\"line\">    <span class=\"meta\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     _bar</span><br><span class=\"line\"><span class=\"symbol\">_bar</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r5</span>, <span class=\"built_in\">r6</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span>, <span class=\"number\">#12</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleasePoolPush</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movs </span>   <span class=\"built_in\">r2</span>, <span class=\"number\">#0</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r4</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC1_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC1_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r6</span>, :lower16:(L__unnamed_cfstring_-(LPC1_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r6</span>, :upper16:(L__unnamed_cfstring_-(LPC1_2+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC1_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r6</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r5</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">r5</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r6</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _NSLog</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r4</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleasePoolPop</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r6</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">r5</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _NSLog</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r5</span>, <span class=\"built_in\">r6</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>很明显，正如我们所期望的那样没有调用retain,release或者autorelease，因为我们没有显式调用这些函数以及使用ARC。编译的结果也正如我们之前推理的那样。接下来让我们在ARC的帮助下会是什么样：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.globl</span>  _bar</span><br><span class=\"line\">    <span class=\"meta\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     _bar</span><br><span class=\"line\"><span class=\"symbol\">_bar</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r5</span>, <span class=\"built_in\">r6</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span>, <span class=\"number\">#12</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleasePoolPush</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movs </span>   <span class=\"built_in\">r2</span>, <span class=\"number\">#0</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r4</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC1_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC1_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"comment\">@ InlineAsm Start</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">r7</span>          <span class=\"comment\">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class=\"line\">    <span class=\"comment\">@ InlineAsm End</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_retainAutoreleasedReturnValue</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r6</span>, :lower16:(L__unnamed_cfstring_-(LPC1_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r6</span>, :upper16:(L__unnamed_cfstring_-(LPC1_2+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC1_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r6</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r5</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">r5</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r6</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _NSLog</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r4</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleasePoolPop</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r6</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">r5</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _NSLog</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r5</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_release</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r5</span>, <span class=\"built_in\">r6</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>此处应该有掌声！ARC识别出我们在自动释放池作用域之外使用了number对象，因此它如上一段代码一样对numberWithInt:函数的返回值进行了retain，但是这一次它将release操作放在了bar函数末尾而不是自动释放池出栈的时候。这一举措避免在一些代码中出现崩溃，我们可能会认为这些代码是正确的，但实际上却潜在着内存管理的bug。</p>\n","categories":["专业","翻译"],"tags":["ARC"]},{"title":"揭开ARC的神秘面纱系列-第2话","url":"http://icebergcwp.com/揭开ARC的神秘面纱系列-第2话.html","content":"<p><a href=\"http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-2/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>以下是正文：</p>\n<p>写完第一篇关于<a href=\"http://icebergcwp.com/2015/02/05/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC1%E8%AF%9D/\">揭开ARC神秘面纱</a>的博客，我想和大家分享另外一些有趣的片段。这一次我好奇当你通过函数返回一个存在数组中的对象时会发生什么。非ARC模式，你可能会对这个对象retain一次再返回一个自动释放的对象。ARC模式下，我们虽然可以免去这些内存管理的操作，但还是不放心，觉得别扭。因此，我决定检测一下ARC是否做到位了。</p>\n<p>考虑一下这个类：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ClassA</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableArray</span> *array;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ClassA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@synthesize</span> array;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)popObject &#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> lastObject = [array lastObject];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastObject) &#123;</span><br><span class=\"line\">        [array removeLastObject];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lastObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在非ARC模式下，调用函数removeLastObject将会释放数组对对象的持有，如果这是对象的最后一个引用则对象的内存将会被释放，意味着返回的对象是一个已经被回收的对象。所以，我们应当retain一次lastObject并在返回前添加autorelease属性（加入自动释放池）。</p>\n<p>尽管我完全明白ARC应该会完成这些工作，但是我还是担忧没有自己添加这些操作。我天真地以为ARC会一行行地解析函数中的代码。如果是这样，我觉得ARC也许没必要在我们引用lastObject对象的时候为它添加一次引用计数，此时ARC并不知道lastObject需要进行retain，所以ARC没必要非得做这些操作。</p>\n<p>这就是我错误所在。显然，ARC在我们引用lastObject对象的时候为其添加一次引用计数，并在对象立刻作用域的时候进行了一次release操作，在我们这个例子中，由于我们是通过函数返回这个对象且函数名不是已关键字new或者copy开头，因此需要将对象加入自动释放池。</p>\n<p>让我们看看上述代码编译之后的样子：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.thumb_func</span>     <span class=\"string\">\"-[ClassA popObject]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA popObject]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r5</span>, <span class=\"built_in\">r6</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r6</span>, :lower16:(_OBJC_IVAR_$_ClassA.array-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r4</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r6</span>, :upper16:(_OBJC_IVAR_$_ClassA.array-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r6</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span>, <span class=\"number\">#12</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r6</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r4</span>, <span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"comment\">@ InlineAsm Start</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">r7</span>          <span class=\"comment\">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class=\"line\">    <span class=\"comment\">@ InlineAsm End</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_retainAutoreleasedReturnValue</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r5</span>, <span class=\"built_in\">r0</span></span><br><span class=\"line\">    <span class=\"keyword\">cbz </span>    <span class=\"built_in\">r5</span>, LBB0_2</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC0_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC0_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r6</span>]</span><br><span class=\"line\"><span class=\"symbol\">LPC0_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r4</span>, <span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\"><span class=\"symbol\">LBB0_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r5</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autoreleaseReturnValue</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r4</span>, <span class=\"built_in\">r5</span>, <span class=\"built_in\">r6</span>, <span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>好吧，事实如此。ARC已经为我们考虑周全了。ARC在代码中插入了objc_retainAutoreleaseReturnValue调用，这意味着ARC已经觉察到需要给一个已经加入自动释放池的返回值增加引用计数，这个操作属于ARC的一种优化处理，它仅仅是把对象从自动释放池中移除而并非真的添加一次引用计数。接下来在函数结尾处，ARC调用了objc_autoreleaseReturnValue，这个函数将即将返回的对象加入自动释放池。</p>\n<p>这仅仅是关于揭开ARC神秘面纱系列的另外一个例子。随着使用ARC的次数增多，我愈发意识它的实用性。ARC减少代码中内存管理相关的错误，并将上述的代码片段进行最佳优化处理。</p>\n","categories":["专业","翻译"],"tags":["ARC"]},{"title":"揭开ARC的神秘面纱系列-第1话","url":"http://icebergcwp.com/揭开ARC的神秘面纱系列-第1话.html","content":"<p>这个系列一共有四篇博客，是Matt Galloway大神关于ARC的内部实现的一些探索，看完之后觉得收获不少。因此尝试着翻译出来和大家分享，一定会翻译不当之处，希望大家及时指正。<br><a href=\"http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-1/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>以下是正文：</p>\n<p>在Twitter上和<a href=\"https://twitter.com/jacobrelkin\" target=\"_blank\" rel=\"noopener\">@jacobrelkin</a>进行了一次<a href=\"https://twitter.com/mattjgalloway/status/154478264537194496\" target=\"_blank\" rel=\"noopener\">交流</a>之后，我决定写几篇博客关于ARC在神秘的面纱之下是如何运转和如何窥视其内部机制的方法。这篇博客我将解释ARC如何处理retain、release和autorelease这三个关键字对应的内部实现。</p>\n<p>我们通过定义一个类作为开始，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ClassA</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">retain</span>) <span class=\"built_in\">NSNumber</span> *foo;</span><br><span class=\"line\">\t<span class=\"keyword\">@end</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ClassA</span></span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">@synthesize</span> foo;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (<span class=\"keyword\">void</span>)changeFooDirect:(<span class=\"built_in\">NSNumber</span>*)inFoo &#123;</span><br><span class=\"line\">\t    foo = inFoo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (<span class=\"keyword\">void</span>)changeFooSetter:(<span class=\"built_in\">NSNumber</span>*)inFoo &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">self</span>.foo = inFoo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (<span class=\"built_in\">NSNumber</span>*)newNumber &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> [[<span class=\"built_in\">NSNumber</span> alloc] initWithInt:<span class=\"number\">10</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (<span class=\"built_in\">NSNumber</span>*)getNumber &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> [[<span class=\"built_in\">NSNumber</span> alloc] initWithInt:<span class=\"number\">10</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">@end</span>\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>上述代码覆盖了ARC的几个重要的方面，包括直接访问成员变量与通过setter访问这两种方式的比较，以及当不同的函数名的函数返回某个对象时ARC将会如何添加autorelease属性。</p>\n<p>让我们首先关注直接访问成员变量与通过setter访问这两种方式的比较。如果我们编译上述代码并查看其汇编代码将会洞悉其中的奥秘。我决定使用ARMv7指令集而非x86指令集是因为前者更容易理解（纯属个人见解！）。我们可以使用编译参数-fobjc-arc和-fno-objc-arc来开启或关闭ARC。在这些实例中我使用的是优化等级是第3级，也就意味着编译器将会移除多余的代码，这些代码我们既不感兴趣同时还会阻碍我们理解核心代码（读者做一个练习，在不设置优化等级的前提下编译上述代码，看看结果是怎样的）。</p>\n<p>在非ARC的模式下采用如下指令进行编译上述代码：</p>\n<pre><code>$ /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/clang -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk -arch armv7 -fno-objc-arc -O3 -S -o - test-arc.m\n</code></pre><p>然后，查看changeFooDirect:和changeFooDirect:这个两个函数的汇编码：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     <span class=\"string\">\"-[ClassA changeFooDirect:]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA changeFooDirect:]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">str </span>    <span class=\"built_in\">r2</span>, [<span class=\"built_in\">r0</span>, <span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">bx </span>     <span class=\"built_in\">lr</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     <span class=\"string\">\"-[ClassA changeFooSetter:]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA changeFooSetter:]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC1_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>继续向前，看看在ARC模式下又是怎样的一副景象。采用如下所示的指令进行编译：</p>\n<pre><code>$ /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/clang -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk -arch armv7 -fobjc-arc -O3 -S -o - test-arc.m\n</code></pre><p>同样，此刻我们只关注changeFooDirect:和changeFooDirect:这两个函数：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     <span class=\"string\">\"-[ClassA changeFooDirect:]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA changeFooDirect:]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC0_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">r1</span></span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">r2</span></span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_storeStrong</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     <span class=\"string\">\"-[ClassA changeFooSetter:]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA changeFooSetter:]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC1_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以一目了然地看到两段汇编代码的不同之处。函数changeFooSetter:完全一样，而函数changeFooDirect:已经发生了变化：调用了一次objc_storeStrong函数。有意思的地方就是这里。如果我们查阅<a href=\"http://clang.llvm.org/docs/AutomaticReferenceCounting.html#runtime.objc_storeStrong\" target=\"_blank\" rel=\"noopener\">LLVM文档中objc_storeStrong函数的说明</a>将会看到objc_storeStrong函数里完成一个典型的变量交换，释放旧变量然后持有新变量。然而在非ARC模式下，这个变量仅仅是赋值，并没有任何释放或者持有操作。这就是我们期望的结果，感谢ARC！</p>\n<p>接下来是更有趣的地方，newNumber函数对比getNumber函数。这两个函数在非ARC模式下都返回一个引用计数为1的NSNumber对象，也就是说函数调用者持有返回对象。根据Cocoa的命名约定，这个结果似乎符合函数newNumber而不符合函数getNumber。我们期望看到函数getNumber中有调用autorelease。因此，让我们查看非ARC模式下的代码是怎样的：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     <span class=\"string\">\"-[ClassA newNumber]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA newNumber]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC2_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\"><span class=\"symbol\">LPC2_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movs </span>   <span class=\"built_in\">r2</span>, <span class=\"number\">#10</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC2_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     <span class=\"string\">\"-[ClassA getNumber]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA getNumber]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC3_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\"><span class=\"symbol\">LPC3_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movs </span>   <span class=\"built_in\">r2</span>, <span class=\"number\">#10</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC3_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是ARC模式下：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     <span class=\"string\">\"-[ClassA newNumber]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA newNumber]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC2_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\"><span class=\"symbol\">LPC2_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movs </span>   <span class=\"built_in\">r2</span>, <span class=\"number\">#10</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC2_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">.align</span>  <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"meta\">.code</span>   <span class=\"number\">16</span></span><br><span class=\"line\">    <span class=\"meta\">.thumb_func</span>     <span class=\"string\">\"-[ClassA getNumber]\"</span></span><br><span class=\"line\"><span class=\"string\">\"-[ClassA getNumber]\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">push </span>   &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">lr</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">mov </span>    <span class=\"built_in\">r7</span>, <span class=\"built_in\">sp</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC3_0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\"><span class=\"symbol\">LPC3_1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r0</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r0</span>, [<span class=\"built_in\">r0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">movw </span>   <span class=\"built_in\">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class=\"number\">4</span>))</span><br><span class=\"line\">    <span class=\"keyword\">movs </span>   <span class=\"built_in\">r2</span>, <span class=\"number\">#10</span></span><br><span class=\"line\">    <span class=\"keyword\">movt </span>   <span class=\"built_in\">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"symbol\">LPC3_2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">add </span>    <span class=\"built_in\">r1</span>, <span class=\"built_in\">pc</span></span><br><span class=\"line\">    <span class=\"keyword\">ldr </span>    <span class=\"built_in\">r1</span>, [<span class=\"built_in\">r1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_msgSend</span><br><span class=\"line\">    <span class=\"keyword\">blx </span>    _objc_autorelease</span><br><span class=\"line\">    <span class=\"keyword\">pop </span>    &#123;<span class=\"built_in\">r7</span>, <span class=\"built_in\">pc</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>查看上述两段代码唯一不同点：ARC模式下getNumber:函数中调用了objc_autorelease。这也是我们所期望的，因为ARC模式能自动觉察到函数名是以关键字new还是关键字copy开头的，并为不属于这两种的情况的Get类函数的返回对象自动添加一次autorelease调用。棒极了！</p>\n<p>这里仅仅只展示了关于ARC在两种模式下如何工作的一小部分奥秘，与此同时，我希望这能激励读者能自己去探索ARC的内部实现而不是理所当然的接受现有的知识点。作为一个程序员，理解自己使用的工具的内部实现是很重要的。</p>\n","categories":["专业","翻译"],"tags":["ARC"]},{"title":"Cocoa RunLoop 系列之Configure Custom InputSource","url":"http://icebergcwp.com/Cocoa RunLoop系列之配置自定义输入源.html","content":"<p>在上一篇博客<a href=\"http://icebergcwp.com/2015/01/05/Cocoa%20RunLoop%20%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/\">Cocoa RunLoop 系列之基础知识</a>介绍了RunLoop的InpuSource有两种：一种是基于Mach端口且由内核触发的source1，另外一种就是自定义且需要手动触发的source0。</p>\n<p>其中source0包括两种自定义形式：一种是Apple实现的自定义InputSource，提供了一系列接口，直接调用即可；另外一种就是由用户根据开发需要完全自定义实现。本文要介绍的就是后者。</p>\n<p>自定义InputSource在实际开发过程的中，可用于在子线程实现周期性且长时间的任务，通过自定义InputSource控制任务的执行。</p>\n<p>然而，实际开发中，大部分需要处理的InputSource都属于source1,少数需要自定义InputSource的情况也可以借助Apple的自定义InputSource函数接口来满足需求。因此，实际开发中几乎不需要用户配置自定义InputSource。既然如此，是否还有探索配置自定义InputSource的必要？我个人的答案是肯定的。通过配置自定InputSource可以窥探RunLoop的整个Routine的具体流程，而不是只停留在理论层面，有助于更深刻地理解RunLoop运行机制。</p>\n<p>下面进入正文，结合理论和源代码阐述配置自定义InputSource的全过程。</p>\n<h3 id=\"理论概述\"><a href=\"#理论概述\" class=\"headerlink\" title=\"理论概述\"></a>理论概述</h3><p>下图是Apple开发文档中介绍自定义InputSource运行流程图：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg\" alt=\"自定义InputSource流程图\"></p>\n<p>结合上图，总结一下几点：</p>\n<ol>\n<li>在工作线程创建一个自定义InputSource并部署到RunLoop中</li>\n<li>主线程中对线程的InputSource和RunLoop进行引用，用于后续操作</li>\n<li>主线程与工作线程共享一个指令集合，以保证指令同步</li>\n<li>通过主线程向InputSource中添加指令和数据</li>\n<li>指令添加结束后，主线程发送一个通知给InputSource，随后唤醒工作线程中的RunLoop</li>\n<li>工作线程的InputSource在接受到通知后，传送指令到RunLoop中等待处理</li>\n<li>RunLoop处理完成，进入休眠，等待下一次唤醒</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>以上述理论为基础，结合Apple文档提供的代码片段，实现了一个配置自定义InputSource的Demo,完整实例可以查看<a href=\"https://github.com/icebergcwp1990/CustomRunLoopInputSourceDemo\" target=\"_blank\" rel=\"noopener\">GitHub源码</a>。</p>\n<h4 id=\"创建并配置InputSource对象\"><a href=\"#创建并配置InputSource对象\" class=\"headerlink\" title=\"创建并配置InputSource对象\"></a>创建并配置InputSource对象</h4><p>IBRunLoopInputSource类用于管理和配置CFRunLoopSourceRef对象，以及包含一个指令集合。</p>\n<p>以下是初始化函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">IBRunLoopInputSource</span> ()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//InputSource对象</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopSourceRef</span> _runLoopSource;</span><br><span class=\"line\">    <span class=\"comment\">//当前指令</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> _currCommand;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//指令集合</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span> , <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableDictionary</span> * commandInfo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">IBRunLoopInputSource</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - Init</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> <span class=\"keyword\">self</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//InputSource上下文 ，共有8个回调函数，目前只实现3个</span></span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopSourceContext</span> context = &#123;<span class=\"number\">0</span>, (__bridge <span class=\"keyword\">void</span> *)(<span class=\"keyword\">self</span>), <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">            &amp;RunLoopSourceScheduleRoutine,</span><br><span class=\"line\">            &amp;RunLoopSourceCancelRoutine,</span><br><span class=\"line\">            &amp;RunLoopSourcePerformRoutine&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//初始化自定义InputSource</span></span><br><span class=\"line\">        _runLoopSource = <span class=\"built_in\">CFRunLoopSourceCreate</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, &amp;context);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中可看的一共有8个与InputSource相关的回调函数，此处只配置了3个，分别是RunLoopSourceScheduleRoutine、RunLoopSourceCancelRoutine和RunLoopSourcePerformRoutine。这3个回调函数的实现会在后面进行介绍。</p>\n<p>对InputSource的基本操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加自定义InputSource到当前RunLoop</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addToCurrentRunLoop</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> runLoop = <span class=\"built_in\">CFRunLoopGetCurrent</span>();</span><br><span class=\"line\">    <span class=\"comment\">//添加到当前RunLoop的kCFRunLoopDefaultMode模式下</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopAddSource</span>(runLoop, _runLoopSource, kCFRunLoopDefaultMode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从指定RunLoop移除自定义InputSource</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)invalidateFromRunLoop:(<span class=\"built_in\">CFRunLoopRef</span> )runLoop</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRemoveSource</span>(runLoop, _runLoopSource, kCFRunLoopDefaultMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对指令集合的基本操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加指令到InputSource</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)addCommand:(<span class=\"built_in\">NSInteger</span>)command withData:(<span class=\"keyword\">id</span>)data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.commandInfo setObject:data forKey:@(command)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//触发InputSource指令</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)fireCommand:(<span class=\"built_in\">NSInteger</span>)command onRunLoop:(<span class=\"built_in\">CFRunLoopRef</span>)runloop</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _currCommand = command;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//通知InputSource准备触发指令</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopSourceSignal</span>(_runLoopSource);</span><br><span class=\"line\">    <span class=\"comment\">//唤醒InputSource所在的RunLoop，该RunLoop必须有的InputSource所在的RunLoop</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopWakeUp</span>(runloop);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可看的，正如之前理论概述总讲的顺序：发出指令之后，先通知InputSource，再唤醒其所在的RunLoop。</p>\n<p>指令通过RunLoop循环，触发相关的回调函数，最终派发给IBRunLoopInputSource对象，然后再处理。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行InputSource指令</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)performSourceCommands</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据指令获得对应的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> data = [<span class=\"keyword\">self</span>.commandInfo objectForKey:@(_currCommand)];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">        data = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Empty data for command : %ld\"</span> , _currCommand ];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//通过代理进行指令数据处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.delegate &amp;&amp; [<span class=\"keyword\">self</span>.delegate respondsToSelector:<span class=\"keyword\">@selector</span>(inputSourceForTest:)]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.delegate inputSourceForTest:data];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，也许有同学感到困惑：为什么绕了一大圈，最终指令执行的代码还是由IBRunLoopInputSource对象来处理，不如直接把指令处理的函数接口公开，直接调用好了？我之前也有类似的困惑，后面仔细一想才想通。可以从两个角度来解答这个困惑：</p>\n<ol>\n<li>自定义InputSource的一个主要目的在于在子线程中进行周期性的任务</li>\n<li>假设在主线程中直接调用，那么执行的代码也是在主线程，背离了初衷。而通过子线程的RunLoop派发之后，指令对应的处理执行是在子线程</li>\n<li>RunLoop的智能休眠配合自定义InputSource能将子线程长时间执行的情况下的资源开销降到最低</li>\n</ol>\n<p>上述3点恰恰的自定义InputSource的精华所在。</p>\n<h4 id=\"创建并配置InputSourceContext对象\"><a href=\"#创建并配置InputSourceContext对象\" class=\"headerlink\" title=\"创建并配置InputSourceContext对象\"></a>创建并配置InputSourceContext对象</h4><p>IBRunLoopContext类是一个容器类，用于管理InputSource与RunLoop之间的关系。Demo中的代码实现的最简单的一对一的关系，也可以实现一对多的关系，即一个InputSource关联多个RunLoop。</p>\n<p>初始化如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)initWithSource:(IBRunLoopInputSource *)runLoopSource andLoop:(<span class=\"built_in\">CFRunLoopRef</span> )runLoop</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//强引用InputSource和InputSource所在的RunLoop</span></span><br><span class=\"line\">        _runLoopInputSource = runLoopSource;</span><br><span class=\"line\">        </span><br><span class=\"line\">        _runLoop = runLoop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当InputSource加入RunLoop中之后，会触发相关的回调函数。在前文中提到，在创建InputSource的时候Demo中配置了3个与InputSource相关的回调函数，具体实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//inputsource部署回调</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> RunLoopSourceScheduleRoutine (<span class=\"keyword\">void</span> *info, <span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFStringRef</span> mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    IBRunLoopInputSource* inputSource = (__bridge IBRunLoopInputSource*)info;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个context，包含当前输入源和RunLoop</span></span><br><span class=\"line\">    IBRunLoopContext * theContext = [[IBRunLoopContext alloc] initWithSource:inputSource andLoop:rl];</span><br><span class=\"line\">    <span class=\"comment\">//将context传入主线程建立强引用，用于后续操作</span></span><br><span class=\"line\">    [(AppDelegate *)[<span class=\"built_in\">NSApp</span> delegate] performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(registerSource:)</span><br><span class=\"line\">                          withObject:theContext waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    <span class=\"comment\">//InputSource弱引用context，因为context已经强引用InputSource，避免循环引用，用于后续移除操作</span></span><br><span class=\"line\">    inputSource.context = theContext;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//inputsource执行任务回调</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> RunLoopSourcePerformRoutine (<span class=\"keyword\">void</span> *info)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    IBRunLoopInputSource*  inputSource = (__bridge IBRunLoopInputSource*)info;</span><br><span class=\"line\">    <span class=\"comment\">//执行InputSource相关的处理</span></span><br><span class=\"line\">    [inputSource performSourceCommands];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//inputsource移除回调</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> RunLoopSourceCancelRoutine (<span class=\"keyword\">void</span> *info, <span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFStringRef</span> mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    IBRunLoopInputSource* inputSource = (__bridge IBRunLoopInputSource*)info;</span><br><span class=\"line\">    <span class=\"comment\">//移除主线程中InputSource对应的Context引用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inputSource.context)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [(AppDelegate *)[<span class=\"built_in\">NSApp</span> delegate] performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(removeSource:)</span><br><span class=\"line\">                                                          withObject:inputSource.context waitUntilDone:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码分别是InputSource部署、执行和移除相关的回调函数：</p>\n<ol>\n<li>部署：在InputSource部署到RunLoop之后，触发回调函数RunLoopSourceScheduleRoutine，将inputSource对象和RunLoop打包成一个context，通过Apple实现的自定义InputSource函数，发送给主线程，用于发送指令</li>\n<li>执行：执行对应的指令</li>\n<li>移除：在主线程中的context引用</li>\n</ol>\n<h4 id=\"创建并配置工作线程\"><a href=\"#创建并配置工作线程\" class=\"headerlink\" title=\"创建并配置工作线程\"></a>创建并配置工作线程</h4><p>IBRunLoopInputSourceThread类用于配置RunLoop和InputSource。</p>\n<p>线程入口函数实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">//创建InputSource</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.inputSource = [[IBRunLoopInputSource alloc] init];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.inputSource setDelegate:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">        <span class=\"comment\">//添加InputSource到当前线程RunLoop</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.inputSource addToCurrentRunLoop];</span><br><span class=\"line\">        <span class=\"comment\">//配置RunLoop监听器</span></span><br><span class=\"line\">        [<span class=\"keyword\">self</span> configureRunLoopObserver];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!<span class=\"keyword\">self</span>.cancelled) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//作为对照，执行线程其他非InputSource任务</span></span><br><span class=\"line\">            [<span class=\"keyword\">self</span> doOtherTask];</span><br><span class=\"line\">            <span class=\"comment\">//切入指定模式RunLoop，且只执行一次</span></span><br><span class=\"line\">            [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runMode:<span class=\"built_in\">NSDefaultRunLoopMode</span> beforeDate:[<span class=\"built_in\">NSDate</span> distantFuture]];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在子线程中的入口函数中，创建InputSource并加入RunLoop，随后启动RunLoop。这里一定要在while循环中切换RunLoop，否则RunLoop只会执行一次便退出。原因在于[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]函数只会执行一次RunLoop，如果InputSource未添加或者已处理完或者超时会立即退出RunLoop。</p>\n<h4 id=\"完善主线程配置\"><a href=\"#完善主线程配置\" class=\"headerlink\" title=\"完善主线程配置\"></a>完善主线程配置</h4><p>主线程的配置在AppDelegate类中实现，包括创建工作线程、管理InputSource引用以及添加指令和发送通知。</p>\n<p>管理InputSource引用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册子线程中InputSource对应的context,用于后续通信</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)registerSource:(IBRunLoopContext*)sourceInfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.sourcesToPing addObject:sourceInfo];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除子线程中InputSource对应的context</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)removeSource:(IBRunLoopContext*)sourceInfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.sourcesToPing enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span> obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> *stop) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([obj isEqual:sourceInfo])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           [<span class=\"keyword\">self</span>.sourcesToPing removeObject:obj];</span><br><span class=\"line\">            *stop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>添加指令和发送通知</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> - (<span class=\"keyword\">void</span>)addCommand:(<span class=\"built_in\">NSInteger</span>)command withData:(<span class=\"keyword\">id</span>)data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAssert</span>([<span class=\"keyword\">self</span>.sourcesToPing count] !=  <span class=\"number\">0</span>, <span class=\"string\">@\"Empty Input Source...\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.sourcesToPing.count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//此处默认取第一个用于测试，可优化</span></span><br><span class=\"line\">        IBRunLoopContext *runLoopContext = [<span class=\"keyword\">self</span>.sourcesToPing objectAtIndex:<span class=\"number\">0</span>];</span><br><span class=\"line\">        IBRunLoopInputSource *inputSource = runLoopContext.runLoopInputSource;</span><br><span class=\"line\">        <span class=\"comment\">//向数据源添加指令</span></span><br><span class=\"line\">        [inputSource addCommand:command withData:data];</span><br><span class=\"line\">        <span class=\"comment\">//添加后并非要立刻触发，此处仅用于测试</span></span><br><span class=\"line\">        [inputSource fireCommand:command onRunLoop:runLoopContext.runLoop];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在写上一篇博客的时候，对与配置自定义InputSource还尚不了解。利用碎片时间和工作间隙仔细阅读了Apple开发文档的相关资料，并且在网上查阅了同行的一些博客之后，决定自己动手写了一个Demo。写Demo的过程的遇到一些新的困惑，随着Demo的完成，大部分困惑也随之而解。</p>\n","categories":["专业"],"tags":["RunLoop"]},{"title":"Cocoa RunLoop 系列之基础知识","url":"http://icebergcwp.com/Cocoa RunLoop 系列之基础知识.html","content":"<p>这篇博客主要结合Apple开发者文档和个人的理解，写的一篇关于Cocoa RunLoop基本知识点的文章。在文档的基础上，概况和梳理了RunLoop相关的知识点。</p>\n<h3 id=\"一、Event-Loop-amp-Cocoa-RunLoop\"><a href=\"#一、Event-Loop-amp-Cocoa-RunLoop\" class=\"headerlink\" title=\"一、Event Loop &amp; Cocoa RunLoop\"></a>一、Event Loop &amp; Cocoa RunLoop</h3><h4 id=\"宏观上：Event-Loop\"><a href=\"#宏观上：Event-Loop\" class=\"headerlink\" title=\"宏观上：Event Loop\"></a>宏观上：Event Loop</h4><ol>\n<li>RunLoop是一个用于循环监听和处理事件或者消息的模型，接收请求，然后派发给相关的处理模块，wikipedia上有更为全面的介绍：<a href=\"https://en.wikipedia.org/wiki/Event_loop\" target=\"_blank\" rel=\"noopener\">Event_loop</a></li>\n<li>Cocoa RunLoop属于Event Loop模型在Mac平台的具体实现</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Event_loop#Implementations\" target=\"_blank\" rel=\"noopener\">其他平台的类似实现</a>：X Window程序，Windows程序 ，Glib库等</li>\n</ol>\n<h4 id=\"微观上-Cocoa-RunLoop\"><a href=\"#微观上-Cocoa-RunLoop\" class=\"headerlink\" title=\"微观上: Cocoa RunLoop\"></a>微观上: Cocoa RunLoop</h4><ol>\n<li>Cocoa RunLoop本质上就是一个对象，提供一个入口函数启动事件循环，在满足特点条件后才会退出。</li>\n<li>Cocoa RunLoop与普通while/for循环不同的是它能监听处理事件和消息，能智能休眠和被唤醒，这些功能的其实现依赖于Mac Port。</li>\n</ol>\n<h3 id=\"二、-Cocoa-RunLoop的内部结构\"><a href=\"#二、-Cocoa-RunLoop的内部结构\" class=\"headerlink\" title=\"二、 Cocoa RunLoop的内部结构\"></a>二、 Cocoa RunLoop的内部结构</h3><p>但凡说到Cocoa RunLoop内部结构，都离不开下面这张图，来源于Apple开发者文档</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg\" alt=\"图1-1 RunLoop结构图\"></p>\n<p>结合上图，可将RunLoop架构划分为四个部分：</p>\n<ol>\n<li>事件源</li>\n<li>运行模式</li>\n<li>循环机制</li>\n<li>执行反馈</li>\n</ol>\n<h4 id=\"1-事件源\"><a href=\"#1-事件源\" class=\"headerlink\" title=\"1. 事件源\"></a>1. 事件源</h4><p>Cocoa RunLoop接受的事件源分为两种类型：Input Sources 和 Timer Sources</p>\n<h5 id=\"1-1-Input-Sources\"><a href=\"#1-1-Input-Sources\" class=\"headerlink\" title=\"1.1. Input Sources\"></a>1.1. Input Sources</h5><p>Input Sources通过异步派发的方式将事件转送到目标线程，事件类别分为两大块：</p>\n<ul>\n<li><p>Port-Based Sources ：</p>\n<p>  基于Mach端口的事件源，Cocoa和Core Foundation这两个框架已经提供了内部支持，只需要调用端口相关的对象或者函数就能提供端口进行通信。比如：将NSPort对象部署到RunLoop中，实现两个线程的循环通信。</p>\n</li>\n<li><p>Custom Input Sources ：</p>\n<ul>\n<li>用户自定义的输入源：使用Core Foundation框架中CFRunLoopSourceRef对象的相关函数实现。具体实现可以查看另外一篇博客：<a href=\"http://icebergcwp.com/2015/01/10/Cocoa%20RunLoop%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%BA%90/\">Cocoa RunLoop 系列之Configure Custom InputSource</a></li>\n<li><p>Cocoa Perform Selector Sources：Cocoa框架内部实现的自定义输入源，可以跨线程调用，实现线程见通信，有点类似于Port-Based事件源，不同的是这种事件源只在RunLoop上部署一次，执行结束后便会自动移除。如果目标线程中没有启动RunLoop也就意味着无法部署这类事件源，因此不会得到预期的结果。</p>\n<p>  使用Cocoa自定义事件源的函数接口，如下：</p>\n</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//部署在主线程</span></span><br><span class=\"line\">\t<span class=\"comment\">//参数列表：Selector:事件源处理函数,Selector参数,是否阻塞当前线程,指定RunLoop模式</span></span><br><span class=\"line\">\tperformSelectorOnMainThread:withObject:waitUntilDone:</span><br><span class=\"line\">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//部署在指定线程</span></span><br><span class=\"line\"><span class=\"comment\">//参数列表：Selector:事件源处理函数,指定线程,Selector参数,是否阻塞当前线程,指定RunLoop模式</span></span><br><span class=\"line\">permSelector:onThread:withObject:waitUntilDone:</span><br><span class=\"line\">performSelector:onThread:withObject:waitUntilDone:modes:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//部署在当前线程</span></span><br><span class=\"line\"><span class=\"comment\">//参数列表：Selector:事件源处理函数,Selector参数,延时执行时间,指定RunLoop模式</span></span><br><span class=\"line\">performSelector:withObject:afterDelay:</span><br><span class=\"line\">performSelector:withObject:afterDelay:inModes:</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//撤销某个对象通过函数performSelector:withObject:afterDelay:部署在当前线程的全部或者指定事件源</span></span><br><span class=\"line\">cancelPreviousPerformRequestsWithTarget:</span><br><span class=\"line\">cancelPreviousPerformRequestsWithTarget:selector:object:</span><br></pre></td></tr></table></figure>\n<p>综上，Input Sources包括基于Mach端口的事件源和自定义的事件源，二者的唯一区别在于被触发的方式：前者是由内核自动触发，后者则需要在其他线程中手动触发。</p>\n</li>\n</ul>\n<h5 id=\"1-2-Timer-Sources\"><a href=\"#1-2-Timer-Sources\" class=\"headerlink\" title=\"1.2. Timer Sources\"></a>1.2. Timer Sources</h5><p> 不同于Input Sources的异步派发，Timer Source是通过同步派发的方式，在预设时间到达时将事件转送到目标线程。这种事件源可用于线程的自我提醒功能，实现周期性的任务。</p>\n<ul>\n<li>如果RunLoop当前运行模式没有添加Time Sources，则在RunLoop中部署的定时器不会被执行。</li>\n<li>设定的间隔时间与真实的触发时间之间没有必然联系，定时器会根据设定的间隔时间周期性的派发消息到RunLoop，但是真实的触发时间由RunLoop决定，假设RunLoop当前正在处理其一个长时间的任务，则触发时间会被延迟，如果在最终触发之前Timer已经派发了N个消息，RunLoop也只会当做一次派发对待，触发一次对应的处理函数。</li>\n</ul>\n<h4 id=\"2-运行模式\"><a href=\"#2-运行模式\" class=\"headerlink\" title=\"2. 运行模式\"></a>2. 运行模式</h4><p>运行模式类似于一个过滤器，用于屏蔽那些不关心的事件源，让RunLoop专注于监听和处理指定的事件源和RunLoop Observer。</p>\n<p>CFRunLoopMode 和 CFRunLoop 的数据结构大致如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;     <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode;    <span class=\"comment\">// Current Runloop Mode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;           <span class=\"comment\">// Set</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;            <span class=\"comment\">// Mode Name, 例如 @\"kCFRunLoopDefaultMode\"</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers;    <span class=\"comment\">// Array</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>结合以上源码，总结以下几点：</p>\n<ul>\n<li>每种模式通过name属性作为标识。</li>\n<li>一种运行模式（Run Loop Mode）就是一个集合，包含需要监听的事件源Input Sources和Timer Soueces以及需要触发的RunLoop observers。</li>\n<li>Cocoa RunLoop包含若干个Mode，调用RunLoop是指定的Mode称之为CurrentMode。RunLoop可以在不同的Mode下切换，切换时退出CurrentMode,并保存相关上下文，再进入新的Mode。</li>\n<li>在启动Cocoa RunLoop是必须指定一种的运行模式，且如果指定的运行模式没有包含事件源或者observers，RunLoop会立刻退出。</li>\n<li>CFRunLoop结构中的commonModes是Mode集合,将某个Mode的name添加到commonModes集合中，表示这个Mode具有“common”属性。</li>\n<li>CFRunLoop结构中的commonModeItems则是共用源的集合，包括事件源和执行反馈。这些共用源会被自动添加到具有“common”属性的Mode中。</li>\n</ul>\n<p><strong> Note </strong> : 不同的运行模式区别在于事件源的不同，比如来源于不同端口的事件和端口事件与Timer事件。不能用于区分不同的事件类型，比如鼠标消息事件和键盘消息事件，因为这两种事件都属于基于端口的事件源。</p>\n<p>以下是苹果预定义好的一些运行模式：</p>\n<ul>\n<li>NSDefaultRunLoopMode //默认的运行模式，适用于大部分情况</li>\n<li>NSConnectionReplyMode //Cocoa库用于监听NSConnection对象响应，开发者很少使用</li>\n<li>NSModalPanelRunLoopMode //模态窗口相关事件源</li>\n<li>NSEventTrackingRunLoopMode  //鼠标拖拽或者屏幕滚动时的事件源</li>\n<li>NSRunLoopCommonModes //用于操作RunLoop结构中commonModes和commonModeItems两个属性</li>\n</ul>\n<h4 id=\"3-循环机制\"><a href=\"#3-循环机制\" class=\"headerlink\" title=\"3. 循环机制\"></a>3. 循环机制</h4><p>循环机制涉及两方面：</p>\n<h5 id=\"3-1-RunLoop与线程之间的关系\"><a href=\"#3-1-RunLoop与线程之间的关系\" class=\"headerlink\" title=\"3.1. RunLoop与线程之间的关系\"></a>3.1. RunLoop与线程之间的关系</h5><p>Apple文档中提到:开发者不需要手动创建RunLoop对象，每个线程包括主线程都关联了一个RunLoop对象。除了主线程的RunLoop在程序启动时被开启，其他线程的RunLoop都需要手动开启。</p>\n<p>待解决的疑问：</p>\n<ul>\n<li>线程中的RunLoop是一直存在还是需要时再创建？</li>\n<li>线程与RunLoop的是如何建立联系的？</li>\n<li>线程与RunLoop对象是否是一一对应的关系？</li>\n</ul>\n<h5 id=\"3-2-RunLoop事件处理流程\"><a href=\"#3-2-RunLoop事件处理流程\" class=\"headerlink\" title=\"3.2. RunLoop事件处理流程\"></a>3.2. RunLoop事件处理流程</h5><p>弄清楚RunLoop内部处理逻辑是理解RunLoop的关键，将单独写一篇博客进行分析。</p>\n<p>待解决的疑问：</p>\n<ul>\n<li>RunLoop如何处理不同事件源？</li>\n<li>RunLoop不同模式切换是如何实现的？</li>\n</ul>\n<p>以上两方面，将在下一篇博客<a href=\"\">Cocoa RunLoop 系列之源码解析</a>中结合源代码来找到答案。</p>\n<h4 id=\"4-执行反馈\"><a href=\"#4-执行反馈\" class=\"headerlink\" title=\"4. 执行反馈\"></a>4. 执行反馈</h4><p>RunLoop Observers机制属于RunLoop一个反馈机制，将RunLoop一次循环划分成若干个节点，当执行到对应的节点调用相应的回调函数，将RunLoop当前的执行状态反馈给用户。</p>\n<ul>\n<li>用户可以通过Core Foundation框架中的CFRunLoopObserverRef注册 observers。</li>\n<li><p>监听节点：</p>\n<ul>\n<li>The entrance to the run loop. //RunLoop启动</li>\n<li>When the run loop is about to process a timer. //即将处理Timer事件源</li>\n<li>When the run loop is about to process an input source. //即将处理Input事件源</li>\n<li>When the run loop is about to go to sleep. //即将进入休眠</li>\n<li>When the run loop has woken up, but before it has processed the event that woke it up. //重新被唤醒，且在处理唤醒事件之前</li>\n<li>The exit from the run loop. //退出RunLoop</li>\n</ul>\n</li>\n<li><p>监听类别分为两种：一次性和重复监听。</p>\n</li>\n</ul>\n<h3 id=\"三、何时使用RunLoop\"><a href=\"#三、何时使用RunLoop\" class=\"headerlink\" title=\"三、何时使用RunLoop\"></a>三、何时使用RunLoop</h3><p>由于主线程的RunLoop在程序启动时被自动创建并执行，因此只有在其他线程中才需要手动启动RunLoop。很多情况下，对于RunLoop的使用多数情况是在主线程中，包括进行RunLoop模式切换，设置RunLoop Observer等。</p>\n<p>在非主线程中，以下几种情况适用于RunLoop:</p>\n<ul>\n<li>使用基于端口或者自定义的事件源与其他线程进行通信。</li>\n<li>需要在当前线程中使用Timer，必须部署才RunLoop中才有效。</li>\n<li>在目标线程中调用performSelector… 函数，因为本质上使用了Cocoa自定义的事件源，依赖于RunLoop才能被触发。</li>\n<li>线程需要进行周期性的任务，需要长时间存在，而非执行一次。</li>\n</ul>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>一直以来，RunLoop对我来说都属于一个比较模糊的概念，在实际编程中也有用到RunLoop的一些功能，确实感觉到很强大，但是仅仅停留在应用层面，并不是很理解具体含义。因此，为了更好的使用RunLoop，有必要研究和梳理RunLoop相关的知识点。</p>\n","categories":["专业"],"tags":["RunLoop"]},{"title":"Objective-C Runtime 解析","url":"http://icebergcwp.com/objective-c_runtime_解析.html","content":"<p>这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以<a href=\"http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"noopener\">查看原文</a>。</p>\n<p><strong>以下是正文：</strong></p>\n<p>一般而言，当人们刚接触Cocoa/Objective-C的时候，运行时机制（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们通常会将大部分的时间和精力用于研究Cocoa Framework以及如何使用它。然而，每一个人至少应该清楚运行时是如何运转的，而不仅仅停留在编译方式的认知层面，如：[target doMethodWith:var];编译之后变成object_msgSend(target,@selector(doMethodWith:),var1)。了解运行时机制的工作原理可以帮助你进一步理解Objective-C这门语言以及你编写的App的运转流程。我相信各个水平层次的Mac/iPhone开发者都会在研究运行时机制的过程中有所收获。</p>\n<h3 id=\"Objective-C-Runtime库是开源的\"><a href=\"#Objective-C-Runtime库是开源的\" class=\"headerlink\" title=\"Objective-C Runtime库是开源的\"></a>Objective-C Runtime库是开源的</h3><p>Objective-C Runtime库是开源的，你随时可以在<a href=\"http://opensource.apple.com\" target=\"_blank\" rel=\"noopener\">源代码</a>上查阅。事实上，查阅源代码是弄清楚Objective-C原理的首选途径之一，胜过阅读苹果开发文档。下载最新版本的源代码<a href=\"http://opensource.apple.com/source/objc4/objc4-680/\" target=\"_blank\" rel=\"noopener\">点击我</a>。</p>\n<h3 id=\"动态-amp-静态-语言\"><a href=\"#动态-amp-静态-语言\" class=\"headerlink\" title=\"动态 &amp; 静态 语言\"></a>动态 &amp; 静态 语言</h3><p>Objective-C是基于运行时的语言，意味着它会尽可能地将决定代码执行逻辑的操作从编译&amp;链接阶段延迟到代码被执行的阶段。这将给你带来很大的灵活性，因此如果有必要的话你可以将消息重定向到合适的对象，或者你甚至可以交换两个方法实现，等等。实现上述功能需要运行时具备审查对象可以响应哪些请求和不能响应哪些请求然后准确地派发消息的能力。如果我们将Objective-C这一特性对比C语言。C语言程序运行始于main()函数，基于至上而下的设计执行你的逻辑和调用你实现的函数。C结构体不能通过发送请求到其他的结构体来执行某个函数。很可能你会编写一段C语言代码，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; stdio.h &gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码经过编译器编译、优化，然后将优化后的代码转化成汇编语言：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">.text</span></span><br><span class=\"line\"> <span class=\"meta\">.align</span> <span class=\"number\">4</span>,<span class=\"number\">0x90</span></span><br><span class=\"line\"> .globl _main</span><br><span class=\"line\"><span class=\"symbol\">_main</span>:</span><br><span class=\"line\"><span class=\"symbol\">Leh_func_begin1</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">pushq </span>%rbp</span><br><span class=\"line\"><span class=\"symbol\">Llabel1</span>:</span><br><span class=\"line\"> <span class=\"keyword\">movq </span>%rsp, %rbp</span><br><span class=\"line\"><span class=\"symbol\">Llabel2</span>:</span><br><span class=\"line\"> <span class=\"keyword\">subq </span><span class=\"number\">$16</span>, %rsp</span><br><span class=\"line\"><span class=\"symbol\">Llabel3</span>:</span><br><span class=\"line\"> <span class=\"keyword\">movq </span>%rsi, %rax</span><br><span class=\"line\"> <span class=\"keyword\">movl </span>%edi, %ecx</span><br><span class=\"line\"> <span class=\"keyword\">movl </span>%ecx, -<span class=\"number\">8</span>(%rbp)</span><br><span class=\"line\"> <span class=\"keyword\">movq </span>%rax, -<span class=\"number\">16</span>(%rbp)</span><br><span class=\"line\"> xorb %al, %al</span><br><span class=\"line\"> leaq LC(%rip), %rcx</span><br><span class=\"line\"> <span class=\"keyword\">movq </span>%rcx, %rdi</span><br><span class=\"line\"> call _printf</span><br><span class=\"line\"> <span class=\"keyword\">movl </span><span class=\"number\">$0</span>, -<span class=\"number\">4</span>(%rbp)</span><br><span class=\"line\"> <span class=\"keyword\">movl </span>-<span class=\"number\">4</span>(%rbp), %eax</span><br><span class=\"line\"> <span class=\"keyword\">addq </span><span class=\"number\">$16</span>, %rsp</span><br><span class=\"line\"> <span class=\"keyword\">popq </span>%rbp</span><br><span class=\"line\"> ret</span><br><span class=\"line\"><span class=\"symbol\">Leh_func_end1</span>:</span><br><span class=\"line\"> .cstring</span><br><span class=\"line\"><span class=\"symbol\">LC</span>:</span><br><span class=\"line\"> <span class=\"meta\">.asciz</span> <span class=\"string\">\"Hello World!\"</span></span><br></pre></td></tr></table></figure>\n<p>随后链接相关的库生成一个可执行文件。对比于Objective-C，虽然代码处理过程很相似，但是编译后的代码取决于Objective-C Runtime库。当我们最初学习Objective-C时被告知中括号里面的代码是如何被处理的，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> doSomethingWithVar:var1];</span><br></pre></td></tr></table></figure>\n<p>被转变成</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(doSomethingWithVar:),var1);</span><br></pre></td></tr></table></figure>\n<p>除此之外我们并不真的知道运行时机制是如何工作的，也许很久以后会知道。</p>\n<h3 id=\"何为Runtime-运行时\"><a href=\"#何为Runtime-运行时\" class=\"headerlink\" title=\"何为Runtime(运行时)\"></a>何为Runtime(运行时)</h3><p>Objective-C Runtime就是一个Runtime库，主要有C语言&amp;汇编语言编写而成，在C语言的基础上加上面向对象的功能之后就成为了Objective-C语言。这意味着运行时机制负责加载类，方法派发，方法传达等操作。本质上而言，运行时机制提供了所有的需要的结构用以支持Objective-C的面向对象编程。</p>\n<h3 id=\"Objective-C-运行时术语\"><a href=\"#Objective-C-运行时术语\" class=\"headerlink\" title=\"Objective-C 运行时术语\"></a>Objective-C 运行时术语</h3><p>在进一步深入之前，让我们扫清一些术语的障碍，这样使我们处于同一立场。就MacOS X App &amp; iPhone OS App开发者所关心而言，这里有两种运行时机制: Modern Runtime和Legacy Runtime。Modern Runtime适用于所有64位MacOS应用和所有iPhone应用，Legacy Runtime适用于所有的32位MacOS应用。运行时机制中有两种类型的函数：实例函数（以‘-’符号开头如-(void)doFoo）;类函数（以‘+’开头如+(id)alloc）。两种函数都与C函数很像，包含一组实现某个任务的代码，如下所示</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">NSString</span> *)movieTitle</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"Futurama: Into the Wild Green Yonder\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>选择器：在Objective-C中，选择器本质上是一个C数据结构体用以标识一个对象将要执行的函数。在运行时机制中的定义如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector  *SEL;</span><br></pre></td></tr></table></figure>\n<p>使用方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEL aSel = <span class=\"keyword\">@selector</span>(movieTitle);</span><br></pre></td></tr></table></figure>\n<p>消息调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[target getMovieTitleForObject:obj];</span><br></pre></td></tr></table></figure>\n<p>Objective-C消息就是中括号[]里面的所有东西，包括消息的接受者target，调用的函数getMovieTileForObject以及所有发送的参数obj。消息调用虽然样式上类似于c函数调用但是实现却不同。实际上，当你发送一个消息给一个对象并意味着函数会被执行。对象可能会检测谁是消息的发送者，基于此再决定执行一个不同的函数或者转送消息给其他不同的目标对象。如果你查看运行时机制里的类定义，你将会看到如下所示的内容：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>这里有几个要点。首先是类Class和对象Object都有一个对应的结构体。所有的objc_object结构体都有一个类指针isa，这就是我们所说的“<strong>isa指针</strong>”。运行时机制需要通过检测一个对象的isa指针去查看对象的类别，然后查看该对象是否能响应你当前发送过来的消息。接下来是id指针，id指针默认不属于任何类别只表明指向的是一个Objective-C对象。对于id指针指向的对象，你可以获知对象的类别，查看对象是否能响应某个函数等等，然后当你具体了解了id指针指向的对象之后便可以更好的使用该对象。你同样可以查看LLVM/Clang文档中Blocks的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> Block_literal_1 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *isa; <span class=\"comment\">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reserved; </span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor_1 &#123;</span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved; <span class=\"comment\">// NULL</span></span><br><span class=\"line\">     <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;  <span class=\"comment\">// sizeof(struct Block_literal_1)</span></span><br><span class=\"line\"> <span class=\"comment\">// optional helper functions</span></span><br><span class=\"line\">     <span class=\"keyword\">void</span> (*copy_helper)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</span><br><span class=\"line\">     <span class=\"keyword\">void</span> (*dispose_helper)(<span class=\"keyword\">void</span> *src); </span><br><span class=\"line\">    &#125; *descriptor;</span><br><span class=\"line\">    <span class=\"comment\">// imported variables</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Block结构的设计兼容于运行时机制。因此Block被视为一个Objective-C对象，所有也就可以响应消息如-retain,-release,-copy等等。</p>\n<p>IMP:Method Implementations</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">id</span> (*IMP)(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>,SEL _cmd,...);</span><br></pre></td></tr></table></figure>\n<p>IMP是一个函数指针，由编译器生成且指向函数的实现内容。如果你目前是一个Objective-C新手则浅尝辄止，但是我们随后会了解运行时机制是如何调用你的函数的。</p>\n<p>Objective-C类：类里面是什么？在Objective-C中，类实现基本上类似于：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//vars</span></span><br><span class=\"line\"><span class=\"built_in\">NSInteger</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//methods</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)doFoo;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>但是类在运行时机制中定义远不如此，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到一个类中声明了一个父类的引用，类名，实例变量列表，方法列表，缓存以及协议列表。当响应发送给类或对象的消息时，运行时机制需要用到这些信息。</p>\n<h3 id=\"类定义对象同时类本身也是对象？何解？\"><a href=\"#类定义对象同时类本身也是对象？何解？\" class=\"headerlink\" title=\"类定义对象同时类本身也是对象？何解？\"></a>类定义对象同时类本身也是对象？何解？</h3><p>之前我提到过在Objective-C中类本身也是对象，运行时机制通过引入元类（Meta Class）来处理类对象。当你发送一个类似于[NSObject alloc]消息的时候，实际上是发送一个消息给类对象，此时将类对象视为元类的实例对待，而元类本身也是一个根元类（Root Meta Class）的实例。While if you say subclass from NSObject, your class points to NSObject as it’s superclass. However all meta classes point to the root metaclass as their superclass. (原文似乎表达观点有误，暂不翻译)。所有的元类仅有一个类函数列表（不同于类处理实例函数列表，还有变量列表和协议列表等等）。因此，当你发送一个消息给类对象时，如[NSObject alloc]，objc_megSend()实际上是搜索元类的函数列表查看是否有响应的函数，如果存在则在该类对象上执行该函数。</p>\n<h3 id=\"为什么继承Apple的原生类？\"><a href=\"#为什么继承Apple的原生类？\" class=\"headerlink\" title=\"为什么继承Apple的原生类？\"></a>为什么继承Apple的原生类？</h3><p>在你刚开始Cocoa编程时，相关教程都是说创建一个类继承于NSObject然后开始编写自己的代码，简单地继承Apple的原生类会让你获益匪浅。其中一个你甚至意识不到的好处就是让你创建的类运行于运行时机制之上。当我们新建一个实例对象，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyObject *object = [[MyObject alloc] init];</span><br></pre></td></tr></table></figure>\n<p>最先被执行的消息是+alloc。如果你<a href=\"https://developer.apple.com/library/content/#documentation/cocoa/reference/Foundation/Classes/NSObject_Class/Reference/Reference.html\" target=\"_blank\" rel=\"noopener\">查阅这个文档</a>会发现：“isa这一实例变量被初始化指向一个描述对于类的数据结构体，其他所有的实例变量都被初始化为0”。所以，通过继承Apple原始类不仅仅继承一些不错的属性，而且还能让我们轻易地创建符合于运行时机制要求的对象（包含一个指向类的isa指针）。</p>\n<h3 id=\"类缓存机制\"><a href=\"#类缓存机制\" class=\"headerlink\" title=\"类缓存机制\"></a>类缓存机制</h3><p>当OC的运行时机制机制通过检视一个对象的isa指针指向的类时会发现该对象实现了很多函数。然而，你可能仅仅调用其中的一小部分也就意味没必要每一次查找某个函数时都去搜索一遍类中的函数列表。因此，类创建了缓存，将你每次搜索函数列表后找到的相应函数存入缓存中。所以，当objc_msgSend()在类中搜寻某个函数是首先会遍历缓存列表。这样做的理论依据在于如果你发送过某个消息给一个对象，你很可能回再次发送同样的消息。因此如果我们将该理论考虑在内意味着如果你有一个NSObject的子类MyObject,并运行以下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">MyObject *obj = [[MyObject alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></span><br><span class=\"line\">-(<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])&#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setVarA:@”blah”];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>接下来发生：</p>\n<ol>\n<li>[MyObject alloc]最先被执行。因为MyObject类没有实现alloc函数所以在该类自然找不到对应的函数，随后进入父类指针指向的NSObject类。</li>\n<li>询问NSObject类是否响应+alloc，发现其实现了alloc函数。+alloc检测到接收类是MyObject然后分配一块响应大小的内存并在其中初始化一个isa指针指向MyObject类。现在，我们获得了一个实例对象，随后运行时机制将NSObject类的+alloc函数指针存入NSObject对象对应的类中的缓存列表中。</li>\n<li>截至目前，我们发送了一个类消息，现在我们发送一个实例消息：调用-init函数或者自定义的初始化函数。显然，MyObject的实例对象能响应这个消息，因此-(id)init会被存入缓存列表中。</li>\n<li>随后self=[super init]被调用。super作为一个魔法关键字指向父类对象，因此转向NSObjct类中，调用init函数。这样做是为了确保面向对象继承体系（OOP inheritance）正常运转，因为所以的父类都将会正确地初始化它们的变量，然后作为子类对象可以正确地初始化自身的变量和必要时重载父类。</li>\n</ol>\n<p>在这个NSObject类的例子中，没有特别的要点出现。但是事实并不总是如此，有时候初始化很重要，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyObject</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *aString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSString</span> *aString;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\">-(<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">  [<span class=\"keyword\">self</span> setAString:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@synthesize</span> aString;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> main (<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAutoreleasePool</span> * pool = [[<span class=\"built_in\">NSAutoreleasePool</span> alloc] init];</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSMutableArray</span> alloc];</span><br><span class=\"line\"> <span class=\"keyword\">id</span> obj2 = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">id</span> obj3 = [<span class=\"built_in\">NSArray</span> alloc];</span><br><span class=\"line\"> <span class=\"keyword\">id</span> obj4 = [[<span class=\"built_in\">NSArray</span> alloc] initWithObjects:<span class=\"string\">@\"Hello\"</span>,<span class=\"literal\">nil</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj1 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj1 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj2 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj2 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj3 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj3 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj4 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj4 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">id</span> obj5 = [MyObject alloc];</span><br><span class=\"line\"> <span class=\"keyword\">id</span> obj6 = [[MyObject alloc] init];</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj5 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj5 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj6 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj6 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">  </span><br><span class=\"line\"> [pool drain];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你是Cocoa初学者，然后我问你上述代码的打印结果，你的回答可能如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableArray</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> </span><br><span class=\"line\"><span class=\"built_in\">NSArray</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span></span><br><span class=\"line\">MyObject</span><br><span class=\"line\">MyObject</span><br></pre></td></tr></table></figure>\n<p>但是运行结果却是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj1 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\">obj2 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></span><br><span class=\"line\">obj3 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\">obj4 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></span><br><span class=\"line\">obj5 <span class=\"keyword\">class</span> is MyObject</span><br><span class=\"line\">obj6 <span class=\"keyword\">class</span> is MyObject</span><br></pre></td></tr></table></figure>\n<p>这是因为在Objective-C中，调用+alloc会隐性地返回一个类的实例对象而调用-init会返回另外一个类的实例对象。</p>\n<h3 id=\"objc-msgSend的工作流程是什么？\"><a href=\"#objc-msgSend的工作流程是什么？\" class=\"headerlink\" title=\"objc_msgSend的工作流程是什么？\"></a>objc_msgSend的工作流程是什么？</h3><p>objc_msgSend函数实现比较复杂。比如我们写了如下代码…</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> printMessageWithString:<span class=\"string\">@\"Hello World!\"</span>];</span><br></pre></td></tr></table></figure>\n<p>上述代码实际上会被编译器转化成：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(printMessageWithString:),<span class=\"string\">@\"Hello World!\"</span>);</span><br></pre></td></tr></table></figure>\n<p>随后，objc_msgSend函数根据目标对象的isa指针去查询对应的类（或者任一父类）看是否响应选择器@selector(printMessageWithString:)。假设在类的函数派发列表或者缓存中找到了对应的函数实现，那么执行该函数。如此看来，objc_msgSend函数没有返回值，它开始执行然后找到对应的目标函数并执行，因此目标函数的返回值被视为objc_msgSend函数的返回值。</p>\n<p>Bill Bumgarner对于objc_msgSend的研究比我要表达的更为深入（<a href=\"http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"noopener\">part 1</a>,<a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage/\" target=\"_blank\" rel=\"noopener\">part 2</a>,<a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path/\" target=\"_blank\" rel=\"noopener\">part 3</a>）。总结一下他所要表达的以及你在查阅运行时机制源代码时可能发现的内容：</p>\n<ol>\n<li>检测屏蔽的函数和死循环，很显然如果代码运行在垃圾回收的环境下，我们可以忽略-retain,-release的调用，诸如此类。</li>\n<li>检测空对象。 不同于其他编程语言，在Objective-C中发送一个消息给空对象是完全合法的。[there are some valid reasons you’d want to. Assuming we have a non nil target we go on… ]</li>\n<li>然后在一个类中查找函数指针，首先是搜索缓存列表，如果找到了对应的函数指针就跳转对其实现代码段，即执行函数。</li>\n<li>如果在缓存列表中没有找到对应的函数指针，便搜索类中的函数派发列表。如果找到了对应的函数指针即跳转到其实现代码段。</li>\n<li>如果在缓存列表和函数列表都没有找到对应的函数，随即跳转到消息转发机制，意味着代码会被编译成c语言代码。所以一个函数如下所示：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">int</span>)doComputeWithNum:(<span class=\"keyword\">int</span>)aNum</span><br></pre></td></tr></table></figure>\n<p>将会被编译成：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> aClass_doComputeWithNum(aClass *<span class=\"keyword\">self</span>,SEL _cmd,<span class=\"keyword\">int</span> aNum)</span><br></pre></td></tr></table></figure>\n<p>此时，运行时机制通过这些函数的指针来调用这些转化后的函数，现在你已经不能直接调用这些函数，但是Cocoa库提供了一个方法来获得这些函数的函数指针。。。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//declare C function pointer</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (computeNum *)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//methodForSelector is COCOA &amp; not ObjC Runtime</span></span><br><span class=\"line\"><span class=\"comment\">//gets the same function pointer objc_msgSend gets</span></span><br><span class=\"line\">computeNum = (<span class=\"keyword\">int</span> (*)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>))[target methodForSelector:<span class=\"keyword\">@selector</span>(doComputeWithNum:)];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//execute the C function pointer returned by the runtime</span></span><br><span class=\"line\">computeNum(obj,<span class=\"keyword\">@selector</span>(doComputeWithNum:),aNum);</span><br></pre></td></tr></table></figure>\n<p>这样，你可以知道访问这些函数并在运行时中直接调用，甚至利用这种方法来绕开运行时的动态调用来确保一个指定的函数被执行。运行时机制同样可以调用你的函数，只不过是通过objc_msgSend()。</p>\n<h3 id=\"Objective-C消息传送\"><a href=\"#Objective-C消息传送\" class=\"headerlink\" title=\"Objective-C消息传送\"></a>Objective-C消息传送</h3><p>在Objective-C中，发送一个消息给一个不会做出响应的对象是合法的，甚至可能是有意这样设计的。苹果在其开发文档中给出的原因之一是为了模拟Objective-C不支持的多继承，或者你只是想抽象化你的设计，隐藏能处理这些消息的实例对象或类。这是运行时机制必要的功能之一。<br>消息传送工作流程：</p>\n<ol>\n<li>运行时机制搜寻了对象的类和它所有父类中的缓存列表和函数列表，但是并没有找到指定的方法。</li>\n<li>随后运行时机制将会调用你类中的 +(BOOL)resolveInstanceMethod:(SEL)aSEL方法给你一次机会为指定的函数提供函数实现，并告诉运行时机制你已经实现了这个方法。如果运行时机制再次搜索这个函数就能找到对应的函数实现。你可以如下所示，实现这个功能：</li>\n</ol>\n<p>定义一个函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> fooMethod(<span class=\"keyword\">id</span> obj, SEL _cmd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Doing Foo\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下所示，使用class_addMethod()来实现</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(aSEL == <span class=\"keyword\">@selector</span>(doFoo:))&#123;</span><br><span class=\"line\">        class_addMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],aSEL,(IMP)fooMethod,<span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>class_addMethod()最后一个参数“v@:”表示函数fooMethod的返回值和参数，你可以在运行时机制指南中类型编码<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"noopener\">Type Encodings</a>了解你可以具体的规则。</p>\n<ol>\n<li>运行时机制随后会调用- (id)forwardingTargetForSelector:(SEL)aSelector函数，给你一次机会将运行时指向另外一个能响应目标函数的对象。这样做比触发消耗更大的函数：-(void)forwardInvocation:(NSInvocation *)anInvocation更划算。你的具体实现可能如下所示：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(aSelector == <span class=\"keyword\">@selector</span>(mysteriousMethod:))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> alternateObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很显然你不想返回self指针，否则可能导致死循环。</p>\n<ol>\n<li>此时，运行时机制尝试最后一次去获取消息的预期目标，并调用- (void)forwardInvocation:(NSInvocation *)anInvocation。如果你未曾了解NSInvocation<a href=\"https://developer.apple.com/reference/foundation/nsinvocation\" target=\"_blank\" rel=\"noopener\">点击查看</a>,这是Objective-C消息中很重要的构成部分。一旦你持有一个NSInvocation对象，你基本上可以更改消息的任何内容，包括目标对象，选择器和函数参数。你可能操作如下：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SEL invSEL = invocation.selector;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>([altObject respondsToSelector:invSEL]) &#123;</span><br><span class=\"line\">        [invocation invokeWithTarget:altObject];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doesNotRecognizeSelector:invSEL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果类是继承自NSObjct，- (void)forwardInvocation:(NSInvocation *)anInvocation函数的默认实现是调用-doesNotRecognizeSelector函数，如果你还想做点什么来响应这次消息转送，重载这个函数将是最后一次机会。</p>\n<h3 id=\"实例变量的无碎片化（Modern-Runtime）\"><a href=\"#实例变量的无碎片化（Modern-Runtime）\" class=\"headerlink\" title=\"实例变量的无碎片化（Modern Runtime）\"></a>实例变量的无碎片化（Modern Runtime）</h3><p>目前我们所了解到关于Modern Runtime的概念之一是实例变量无碎片化（Non Fragile ivars）。编译器在编译类的时候确定了实例变量的布局，决定了某个实例变量的访问位置。这属于底层细节，关乎于获得一个对象的指针，查找某个实例变量相对于对象起始位置的偏移，根据实例变量的类型读取相应数量的字节。因此，实例变量的布局可能如下所示，左侧的数字表示实例变量的字节偏移量</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/translation/runtime-f-1.png\" alt=\"\"></p>\n<p>如上所示，NSObject对象的实例变量布局以及继承NSObject后添加了自己的变量之后的布局。这样的布局在苹果发布更新之前都能正常运行，但是苹果发布了Mac OS X 10.6之后，布局就会变成如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/translation/runtime-f-2.png\" alt=\"\"></p>\n<p>因为与父类的实例变量重叠，自定义的对象的实例变量被抹掉。防止这样的情况发生唯一的可能是苹果能保持更新之前的布局。但是如果苹果这样做的话，那么苹果的框架将不可能得到改进，因为这些框架的实例变量布局已经写死了。处于实例变量碎片化的情况下只能通过重新编译所有继承于苹果类的类来保证兼容新的框架。那么实例变量无碎片化的情况下会是如何处理？</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/translation/runtime-f-3.png\" alt=\"\"></p>\n<p>实例变量无碎片化的前提下，编译器创建同实例变量碎片化情况下一样的实例变量布局。但是当运行时检测到一个重叠的父类时会调整自定义变量的偏移量，因此子类中自定义的变量得以保留。</p>\n<h3 id=\"Objective-C-关联对象\"><a href=\"#Objective-C-关联对象\" class=\"headerlink\" title=\"Objective-C 关联对象\"></a>Objective-C 关联对象</h3><p>最近Mac OS X 10.6 Snow Leopard推出了一个新特性，称之为关联引用。不同于其他一些语言，Objective-C不支持动态添加实例变量到某个对象的类中。所以在此之前你不得不耗尽脑力去构建一个特定的基础架构，营造一个可以给某个对象动态添加变量的假象。现在在Mac OS X 10.6中，运行时已经支持这一功能。如果想添加一个变量到任一个已经存在的苹果原生类中，比如NSView，我们可以做如下操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Cocoa/Cocoa.h&gt;</span> //Cocoa</span></span><br><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt; objc/runtime.h&gt;</span> //objc runtime api’s</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSView</span> (<span class=\"title\">CustomAdditions</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSImage</span> *customImage;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSView</span> (<span class=\"title\">CustomAdditions</span>)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> img_key; <span class=\"comment\">//has a unique address (identifier)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">-(<span class=\"built_in\">NSImage</span> *)customImage</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>,&amp;img_key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setCustomImage:(<span class=\"built_in\">NSImage</span> *)image</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>,&amp;img_key,image,</span><br><span class=\"line\">                             OBJC_ASSOCIATION_RETAIN);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在runtime.h头文件中可以看到存储关联对象方式的可选项，作为objc_setAssociatedObject()函数的参数传入。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Associated Object support. */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/* objc_setAssociatedObject() options */</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,</span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>,</span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,</span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,</span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这些可选值与@property语法的可选值相匹配。</p>\n<h3 id=\"混合虚函数表派发（Hybrid-vTable-Dispatch）\"><a href=\"#混合虚函数表派发（Hybrid-vTable-Dispatch）\" class=\"headerlink\" title=\"混合虚函数表派发（Hybrid vTable Dispatch）\"></a>混合虚函数表派发（Hybrid vTable Dispatch）</h3><p>如果你查阅现代版运行时的源代码，你会看到以下内容（<a href=\"http://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.m\" target=\"_blank\" rel=\"noopener\">位于objc-runtime-new.m</a>）:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/***********************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">* vtable dispatch</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span></span><br><span class=\"line\"><span class=\"comment\">* The selectors represented in the vtable are the same for all classes</span></span><br><span class=\"line\"><span class=\"comment\">*   (i.e. no class has a bigger or smaller vtable).</span></span><br><span class=\"line\"><span class=\"comment\">* Each vtable index has an associated trampoline which dispatches to </span></span><br><span class=\"line\"><span class=\"comment\">*   the IMP at that index for the receiver class's vtable (after </span></span><br><span class=\"line\"><span class=\"comment\">*   checking for NULL). Dispatch fixup uses these trampolines instead </span></span><br><span class=\"line\"><span class=\"comment\">*   of objc_msgSend.</span></span><br><span class=\"line\"><span class=\"comment\">* Fragility: The vtable size and list of selectors is chosen at launch </span></span><br><span class=\"line\"><span class=\"comment\">*   time. No compiler-generated code depends on any particular vtable </span></span><br><span class=\"line\"><span class=\"comment\">*   configuration, or even the use of vtable dispatch at all.</span></span><br><span class=\"line\"><span class=\"comment\">* Memory size: If a class's vtable is identical to its superclass's </span></span><br><span class=\"line\"><span class=\"comment\">*   (i.e. the class overrides none of the vtable selectors), then </span></span><br><span class=\"line\"><span class=\"comment\">*   the class points directly to its superclass's vtable. This means </span></span><br><span class=\"line\"><span class=\"comment\">*   selectors to be included in the vtable should be chosen so they are </span></span><br><span class=\"line\"><span class=\"comment\">*   (1) frequently called, but (2) not too frequently overridden. In </span></span><br><span class=\"line\"><span class=\"comment\">*   particular, -dealloc is a bad choice.</span></span><br><span class=\"line\"><span class=\"comment\">* Forwarding: If a class doesn't implement some vtable selector, that </span></span><br><span class=\"line\"><span class=\"comment\">*   selector's IMP is set to objc_msgSend in that class's vtable.</span></span><br><span class=\"line\"><span class=\"comment\">* +initialize: Each class keeps the default vtable (which always </span></span><br><span class=\"line\"><span class=\"comment\">*   redirects to objc_msgSend) until its +initialize is completed.</span></span><br><span class=\"line\"><span class=\"comment\">*   Otherwise, the first message to a class could be a vtable dispatch, </span></span><br><span class=\"line\"><span class=\"comment\">*   and the vtable trampoline doesn't include +initialize checking.</span></span><br><span class=\"line\"><span class=\"comment\">* Changes: Categories, addMethod, and setImplementation all force vtable </span></span><br><span class=\"line\"><span class=\"comment\">*   reconstruction for the class and all of its subclasses, if the </span></span><br><span class=\"line\"><span class=\"comment\">*   vtable selectors are affected.</span></span><br><span class=\"line\"><span class=\"comment\">**********************************************************************/</span></span><br></pre></td></tr></table></figure>\n<p>上述内容阐述的要点就是运行时会尽量存储调用最频繁的函数以达到提高软件运行速度的目的，因为通过虚函数表查找比调用objc_msgSend函数使用的指令更少。虚函数表中的16个函数调用次数远多于其他所有函数。实际上，进一步深入研究代码你会发现垃圾回收机制和无垃圾回收机制下虚函数表中默认的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> defaultVtable[] = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"allocWithZone:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"alloc\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"class\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"self\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isKindOfClass:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"respondsToSelector:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isFlipped\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"length\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectForKey:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"count\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectAtIndex:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqualToString:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqual:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"retain\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"release\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"autorelease\"</span>, </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> defaultVtableGC[] = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"allocWithZone:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"alloc\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"class\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"self\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isKindOfClass:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"respondsToSelector:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isFlipped\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"length\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectForKey:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"count\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectAtIndex:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqualToString:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqual:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"hash\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"addObject:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"countByEnumeratingWithState:objects:count:\"</span>, </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>那么你如何知道是否调用了这些函数？调试模式下，你将会在栈中看到以下函数中的某一个被调用，出于调试的目的，所有的这些方法都可以视为通过objc_msgSend函数调用的。</p>\n<ol>\n<li>objc_msgSend_fixup：是当运行时正在派发一个位于虚函数表的函数时触发，即用于派发虚函数表中的函数。</li>\n<li>objc_msgSend_fixedup：是当调用一个本应存在于虚函数表的函数但是现在已经不存在的函数时触发（个人觉得应该是调用在objc_msgSend_fixup函数之后，并且由前者触发的）。</li>\n<li>objc_msgSend_vtable[0-15]：调试模式下，也许会看到某个函数调用类似于objc_msgSend_vtable5意味着正在调用虚函数表中对应序号的某个函数。</li>\n</ol>\n<p>运行时可以决定是否派发这些函数，所以不要指望以下这种情况存在：objc_msgSend_vtable10在运行时的一次循环中对应的函数是-length,意味着后面任一次循环中也是同样情况。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>我希望你能喜欢这些内容，这篇文章基本上覆盖了我在<a href=\"http://cocoaheads.org/us/DesMoinesIowa/index.html\" target=\"_blank\" rel=\"noopener\">Des Moines Cocoaheads </a>上谈及的内容。Objective-C运行时是一个了不起的杰作，它为我们的Cocoa/Objective-C应用提供了一个强大的平台，让很多我们正在受用的功能都成为可能。如果你还没有查阅关于如何使用Objective-C运行时的Apple开发文档，我希望你马上行动，谢谢。附上：<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">运行时开发文档</a>，<a href=\"https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime\" target=\"_blank\" rel=\"noopener\">运行时介绍文档</a></p>\n","categories":["专业","翻译"],"tags":["Runtime"]},{"title":"Hello,World","url":"http://icebergcwp.com/hello-world.html","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"about","url":"http://icebergcwp.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://icebergcwp.com/css/personal-style.css","content":"\n@font-face {\n  font-family: \"Meiryo\";\n  src: url(\"/fonts/Meiryo.eot\");\n  /* IE9 */\n  src: url(\"/fonts/Meiryo.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */\n  url(\"/fonts/Meiryo.woff\") format(\"woff\"), /* chrome, firefox */\n  url(\"/fonts/Meiryo.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url(\"/fonts/Meiryo.svg#Meiryo\") format(\"svg\");\n  /* iOS 4.1- */\n  font-style: normal;\n  font-weight: normal;\n}\n\nhtml.page-home {\n\n\tbackground: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);\n\tbackground-blend-mode: screen;\n\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n\n}\n","categories":[],"tags":[]},{"title":"category","url":"http://icebergcwp.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://icebergcwp.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://icebergcwp.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://icebergcwp.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://icebergcwp.com/tag/index.html","content":"","categories":[],"tags":[]}]