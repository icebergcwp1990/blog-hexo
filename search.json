[{"title":"Hello,Hexo","url":"http://yoursite.com/2016/09/28/Hello-Hexo/","content":"<h3 id=\"hello-Hexo\"><a href=\"#hello-Hexo\" class=\"headerlink\" title=\"hello , Hexo\"></a>hello , Hexo</h3><blockquote>\n<p>Where there is a will , there is a way.<br>-— for my self</p>\n</blockquote>\n<p>Wow, I think hexo is a amazing stuff! I like it really! Let’s start !</p>\n"},{"title":"Hello World","url":"http://yoursite.com/2016/09/28/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"Objective-C Runtime 解析","url":"http://yoursite.com/2015/10/13/objective-c_runtime_解析/","content":"<p>这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以<a href=\"http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"external\">查看原文</a>。</p>\n<p><strong>以下是正文：</strong></p>\n<p>一般而言，当人们刚接触Cocoa/Objective-C的时候，运行时机制（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们通常会将大部分的时间和精力用于研究Cocoa Framework以及如何使用它。然而，每一个人至少应该清楚运行时是如何运转的，而不仅仅停留在编译方式的认知层面，如：[target doMethodWith:var];编译之后变成object_msgSend(target,@selector(doMethodWith:),var1)。了解运行时机制的工作原理可以帮助你进一步理解Objective-C这门语言以及你编写的App的运转流程。我相信各个水平层次的Mac/iPhone开发者都会在研究运行时机制的过程中有所收获。</p>\n<h3 id=\"Objective-C-Runtime库是开源的\"><a href=\"#Objective-C-Runtime库是开源的\" class=\"headerlink\" title=\"Objective-C Runtime库是开源的\"></a>Objective-C Runtime库是开源的</h3><p>Objective-C Runtime库是开源的，你随时可以在<a href=\"http://opensource.apple.com\" target=\"_blank\" rel=\"external\">源代码</a>上查阅。事实上，查阅源代码是弄清楚Objective-C原理的首选途径之一，胜过阅读苹果开发文档。下载最新版本的源代码<a href=\"http://opensource.apple.com/source/objc4/objc4-680/\" target=\"_blank\" rel=\"external\">点击我</a>。</p>\n<h3 id=\"动态-amp-静态-语言\"><a href=\"#动态-amp-静态-语言\" class=\"headerlink\" title=\"动态 &amp; 静态 语言\"></a>动态 &amp; 静态 语言</h3><p>Objective-C是基于运行时的语言，意味着它会尽可能地将决定代码执行逻辑的操作从编译&amp;链接阶段延迟到代码被执行的阶段。这将给你带来很大的灵活性，因此如果有必要的话你可以将消息重定向到合适的对象，或者你甚至可以交换两个方法实现，等等。实现上述功能需要运行时具备审查对象可以响应哪些请求和不能响应哪些请求然后准确地派发消息的能力。如果我们将Objective-C这一特性对比C语言。C语言程序运行始于main()函数，基于至上而下的设计执行你的逻辑和调用你实现的函数。C结构体不能通过发送请求到其他的结构体来执行某个函数。很可能你会编写一段C语言代码，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; stdio.h &gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\"</span>);</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码经过编译器编译、优化，然后将优化后的代码转化成汇编语言：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"symbol\">.text</span></div><div class=\"line\"> <span class=\"meta\">.align</span> <span class=\"number\">4</span>,<span class=\"number\">0x90</span></div><div class=\"line\"> .globl _main</div><div class=\"line\"><span class=\"symbol\">_main</span>:</div><div class=\"line\"><span class=\"symbol\">Leh_func_begin1</span>:</div><div class=\"line\">\t<span class=\"keyword\">pushq </span>%rbp</div><div class=\"line\"><span class=\"symbol\">Llabel1</span>:</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rsp, %rbp</div><div class=\"line\"><span class=\"symbol\">Llabel2</span>:</div><div class=\"line\"> <span class=\"keyword\">subq </span><span class=\"number\">$16</span>, %rsp</div><div class=\"line\"><span class=\"symbol\">Llabel3</span>:</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rsi, %rax</div><div class=\"line\"> <span class=\"keyword\">movl </span>%edi, %ecx</div><div class=\"line\"> <span class=\"keyword\">movl </span>%ecx, -<span class=\"number\">8</span>(%rbp)</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rax, -<span class=\"number\">16</span>(%rbp)</div><div class=\"line\"> xorb %al, %al</div><div class=\"line\"> leaq LC(%rip), %rcx</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rcx, %rdi</div><div class=\"line\"> call _printf</div><div class=\"line\"> <span class=\"keyword\">movl </span><span class=\"number\">$0</span>, -<span class=\"number\">4</span>(%rbp)</div><div class=\"line\"> <span class=\"keyword\">movl </span>-<span class=\"number\">4</span>(%rbp), %eax</div><div class=\"line\"> <span class=\"keyword\">addq </span><span class=\"number\">$16</span>, %rsp</div><div class=\"line\"> <span class=\"keyword\">popq </span>%rbp</div><div class=\"line\"> ret</div><div class=\"line\"><span class=\"symbol\">Leh_func_end1</span>:</div><div class=\"line\"> .cstring</div><div class=\"line\"><span class=\"symbol\">LC</span>:</div><div class=\"line\"> <span class=\"meta\">.asciz</span> <span class=\"string\">\"Hello World!\"</span></div></pre></td></tr></table></figure>\n<p>随后链接相关的库生成一个可执行文件。对比于Objective-C，虽然代码处理过程很相似，但是编译后的代码取决于Objective-C Runtime库。当我们最初学习Objective-C时被告知中括号里面的代码是如何被处理的，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> doSomethingWithVar:var1];</div></pre></td></tr></table></figure>\n<p>被转变成</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(doSomethingWithVar:),var1);</div></pre></td></tr></table></figure>\n<p>除此之外我们并不真的知道运行时机制是如何工作的，也许很久以后会知道。</p>\n<h3 id=\"何为Runtime-运行时\"><a href=\"#何为Runtime-运行时\" class=\"headerlink\" title=\"何为Runtime(运行时)\"></a>何为Runtime(运行时)</h3><p>Objective-C Runtime就是一个Runtime库，主要有C语言&amp;汇编语言编写而成，在C语言的基础上加上面向对象的功能之后就成为了Objective-C语言。这意味着运行时机制负责加载类，方法派发，方法传达等操作。本质上而言，运行时机制提供了所有的需要的结构用以支持Objective-C的面向对象编程。</p>\n<h3 id=\"Objective-C-运行时术语\"><a href=\"#Objective-C-运行时术语\" class=\"headerlink\" title=\"Objective-C 运行时术语\"></a>Objective-C 运行时术语</h3><p>在进一步深入之前，让我们扫清一些术语的障碍，这样使我们处于同一立场。就MacOS X App &amp; iPhone OS App开发者所关心而言，这里有两种运行时机制: Modern Runtime和Legacy Runtime。Modern Runtime适用于所有64位MacOS应用和所有iPhone应用，Legacy Runtime适用于所有的32位MacOS应用。运行时机制中有两种类型的函数：实例函数（以‘-’符号开头如-(void)doFoo）;类函数（以‘+’开头如+(id)alloc）。两种函数都与C函数很像，包含一组实现某个任务的代码，如下所示</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">NSString</span> *)movieTitle</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"Futurama: Into the Wild Green Yonder\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>选择器：在Objective-C中，选择器本质上是一个C数据结构体用以标识一个对象将要执行的函数。在运行时机制中的定义如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector  *SEL;</div></pre></td></tr></table></figure>\n<p>使用方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SEL aSel = <span class=\"keyword\">@selector</span>(movieTitle);</div></pre></td></tr></table></figure>\n<p>消息调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[target getMovieTitleForObject:obj];</div></pre></td></tr></table></figure>\n<p>Objective-C消息就是中括号[]里面的所有东西，包括消息的接受者target，调用的函数getMovieTileForObject以及所有发送的参数obj。消息调用虽然样式上类似于c函数调用但是实现却不同。实际上，当你发送一个消息给一个对象并意味着函数会被执行。对象可能会检测谁是消息的发送者，基于此再决定执行一个不同的函数或者转送消息给其他不同的目标对象。如果你查看运行时机制里的类定义，你将会看到如下所示的内容：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa;</div><div class=\"line\">&#125; *<span class=\"keyword\">id</span>;</div></pre></td></tr></table></figure>\n<p>这里有几个要点。首先是类Class和对象Object都有一个对应的结构体。所有的objc_object结构体都有一个类指针isa，这就是我们所说的“<strong>isa指针</strong>”。运行时机制需要通过检测一个对象的isa指针去查看对象的类别，然后查看该对象是否能响应你当前发送过来的消息。接下来是id指针，id指针默认不属于任何类别只表明指向的是一个Objective-C对象。对于id指针指向的对象，你可以获知对象的类别，查看对象是否能响应某个函数等等，然后当你具体了解了id指针指向的对象之后便可以更好的使用该对象。你同样可以查看LLVM/Clang文档中Blocks的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Block_literal_1 &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> *isa; <span class=\"comment\">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></div><div class=\"line\">    <span class=\"keyword\">int</span> flags;</div><div class=\"line\">    <span class=\"keyword\">int</span> reserved; </div><div class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</div><div class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor_1 &#123;</div><div class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved; <span class=\"comment\">// NULL</span></div><div class=\"line\">     <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;  <span class=\"comment\">// sizeof(struct Block_literal_1)</span></div><div class=\"line\"> <span class=\"comment\">// optional helper functions</span></div><div class=\"line\">     <span class=\"keyword\">void</span> (*copy_helper)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</div><div class=\"line\">     <span class=\"keyword\">void</span> (*dispose_helper)(<span class=\"keyword\">void</span> *src); </div><div class=\"line\">    &#125; *descriptor;</div><div class=\"line\">    <span class=\"comment\">// imported variables</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Block结构的设计兼容于运行时机制。因此Block被视为一个Objective-C对象，所有也就可以响应消息如-retain,-release,-copy等等。</p>\n<p>IMP:Method Implementations</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">id</span> (*IMP)(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>,SEL _cmd,...);</div></pre></td></tr></table></figure>\n<p>IMP是一个函数指针，由编译器生成且指向函数的实现内容。如果你目前是一个Objective-C新手则浅尝辄止，但是我们随后会了解运行时机制是如何调用你的函数的。</p>\n<p>Objective-C类：类里面是什么？在Objective-C中，类实现基本上类似于：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//vars</span></div><div class=\"line\"><span class=\"built_in\">NSInteger</span> counter;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//methods</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)doFoo;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>但是类在运行时机制中定义远不如此，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\"><span class=\"meta\">#endif</span></div></pre></td></tr></table></figure>\n<p>我们可以看到一个类中声明了一个父类的引用，类名，实例变量列表，方法列表，缓存以及协议列表。当响应发送给类或对象的消息时，运行时机制需要用到这些信息。</p>\n<h3 id=\"类定义对象同时类本身也是对象？何解？\"><a href=\"#类定义对象同时类本身也是对象？何解？\" class=\"headerlink\" title=\"类定义对象同时类本身也是对象？何解？\"></a>类定义对象同时类本身也是对象？何解？</h3><p>之前我提到过在Objective-C中类本身也是对象，运行时机制通过引入元类（Meta Class）来处理类对象。当你发送一个类似于[NSObject alloc]消息的时候，实际上是发送一个消息给类对象，此时将类对象视为元类的实例对待，而元类本身也是一个根元类（Root Meta Class）的实例。While if you say subclass from NSObject, your class points to NSObject as it’s superclass. However all meta classes point to the root metaclass as their superclass. (原文似乎表达观点有误，暂不翻译)。所有的元类仅有一个类函数列表（不同于类处理实例函数列表，还有变量列表和协议列表等等）。因此，当你发送一个消息给类对象时，如[NSObject alloc]，objc_megSend()实际上是搜索元类的函数列表查看是否有响应的函数，如果存在则在该类对象上执行该函数。</p>\n<h3 id=\"为什么继承Apple的原生类？\"><a href=\"#为什么继承Apple的原生类？\" class=\"headerlink\" title=\"为什么继承Apple的原生类？\"></a>为什么继承Apple的原生类？</h3><p>在你刚开始Cocoa编程时，相关教程都是说创建一个类继承于NSObject然后开始编写自己的代码，简单地继承Apple的原生类会让你获益匪浅。其中一个你甚至意识不到的好处就是让你创建的类运行于运行时机制之上。当我们新建一个实例对象，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyObject *object = [[MyObject alloc] init];</div></pre></td></tr></table></figure>\n<p>最先被执行的消息是+alloc。如果你<a href=\"https://developer.apple.com/library/content/#documentation/cocoa/reference/Foundation/Classes/NSObject_Class/Reference/Reference.html\" target=\"_blank\" rel=\"external\">查阅这个文档</a>会发现：“isa这一实例变量被初始化指向一个描述对于类的数据结构体，其他所有的实例变量都被初始化为0”。所以，通过继承Apple原始类不仅仅继承一些不错的属性，而且还能让我们轻易地创建符合于运行时机制要求的对象（包含一个指向类的isa指针）。</p>\n<h3 id=\"类缓存机制\"><a href=\"#类缓存机制\" class=\"headerlink\" title=\"类缓存机制\"></a>类缓存机制</h3><p>当OC的运行时机制机制通过检视一个对象的isa指针指向的类时会发现该对象实现了很多函数。然而，你可能仅仅调用其中的一小部分也就意味没必要每一次查找某个函数时都去搜索一遍类中的函数列表。因此，类创建了缓存，将你每次搜索函数列表后找到的相应函数存入缓存中。所以，当objc_msgSend()在类中搜寻某个函数是首先会遍历缓存列表。这样做的理论依据在于如果你发送过某个消息给一个对象，你很可能回再次发送同样的消息。因此如果我们将该理论考虑在内意味着如果你有一个NSObject的子类MyObject,并运行以下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">MyObject *obj = [[MyObject alloc] init];</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></div><div class=\"line\">-(<span class=\"keyword\">id</span>)init &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> setVarA:@”blah”];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>接下来发生：</p>\n<ol>\n<li>[MyObject alloc]最先被执行。因为MyObject类没有实现alloc函数所以在该类自然找不到对应的函数，随后进入父类指针指向的NSObject类。</li>\n<li>询问NSObject类是否响应+alloc，发现其实现了alloc函数。+alloc检测到接收类是MyObject然后分配一块响应大小的内存并在其中初始化一个isa指针指向MyObject类。现在，我们获得了一个实例对象，随后运行时机制将NSObject类的+alloc函数指针存入NSObject对象对应的类中的缓存列表中。</li>\n<li>截至目前，我们发送了一个类消息，现在我们发送一个实例消息：调用-init函数或者自定义的初始化函数。显然，MyObject的实例对象能响应这个消息，因此-(id)init会被存入缓存列表中。</li>\n<li>随后self=[super init]被调用。super作为一个魔法关键字指向父类对象，因此转向NSObjct类中，调用init函数。这样做是为了确保面向对象继承体系（OOP inheritance）正常运转，因为所以的父类都将会正确地初始化它们的变量，然后作为子类对象可以正确地初始化自身的变量和必要时重载父类。</li>\n</ol>\n<p>在这个NSObject类的例子中，没有特别的要点出现。但是事实并不总是如此，有时候初始化很重要，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyObject</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"built_in\">NSString</span> *aString;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSString</span> *aString;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></div><div class=\"line\"> </div><div class=\"line\">-(<span class=\"keyword\">id</span>)init</div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">  [<span class=\"keyword\">self</span> setAString:<span class=\"literal\">nil</span>];</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@synthesize</span> aString;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">int</span> main (<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSAutoreleasePool</span> * pool = [[<span class=\"built_in\">NSAutoreleasePool</span> alloc] init];</div><div class=\"line\"> </div><div class=\"line\"> <span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSMutableArray</span> alloc];</div><div class=\"line\"> <span class=\"keyword\">id</span> obj2 = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"keyword\">id</span> obj3 = [<span class=\"built_in\">NSArray</span> alloc];</div><div class=\"line\"> <span class=\"keyword\">id</span> obj4 = [[<span class=\"built_in\">NSArray</span> alloc] initWithObjects:<span class=\"string\">@\"Hello\"</span>,<span class=\"literal\">nil</span>];</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj1 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj1 <span class=\"keyword\">class</span>]));</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj2 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj2 <span class=\"keyword\">class</span>]));</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj3 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj3 <span class=\"keyword\">class</span>]));</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj4 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj4 <span class=\"keyword\">class</span>]));</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"keyword\">id</span> obj5 = [MyObject alloc];</div><div class=\"line\"> <span class=\"keyword\">id</span> obj6 = [[MyObject alloc] init];</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj5 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj5 <span class=\"keyword\">class</span>]));</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj6 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj6 <span class=\"keyword\">class</span>]));</div><div class=\"line\">  </div><div class=\"line\"> [pool drain];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你是Cocoa初学者，然后我问你上述代码的打印结果，你的回答可能如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSMutableArray</span></div><div class=\"line\"><span class=\"built_in\">NSMutableArray</span> </div><div class=\"line\"><span class=\"built_in\">NSArray</span></div><div class=\"line\"><span class=\"built_in\">NSArray</span></div><div class=\"line\">MyObject</div><div class=\"line\">MyObject</div></pre></td></tr></table></figure>\n<p>但是运行结果却是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj1 <span class=\"keyword\">class</span> is __NSPlaceholderArray</div><div class=\"line\">obj2 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></div><div class=\"line\">obj3 <span class=\"keyword\">class</span> is __NSPlaceholderArray</div><div class=\"line\">obj4 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></div><div class=\"line\">obj5 <span class=\"keyword\">class</span> is MyObject</div><div class=\"line\">obj6 <span class=\"keyword\">class</span> is MyObject</div></pre></td></tr></table></figure>\n<p>这是因为在Objective-C中，调用+alloc会隐性地返回一个类的实例对象而调用-init会返回另外一个类的实例对象。</p>\n<h3 id=\"objc-msgSend的工作流程是什么？\"><a href=\"#objc-msgSend的工作流程是什么？\" class=\"headerlink\" title=\"objc_msgSend的工作流程是什么？\"></a>objc_msgSend的工作流程是什么？</h3><p>objc_msgSend函数实现比较复杂。比如我们写了如下代码…</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> printMessageWithString:<span class=\"string\">@\"Hello World!\"</span>];</div></pre></td></tr></table></figure>\n<p>上述代码实际上会被编译器转化成：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(printMessageWithString:),<span class=\"string\">@\"Hello World!\"</span>);</div></pre></td></tr></table></figure>\n<p>随后，objc_msgSend函数根据目标对象的isa指针去查询对应的类（或者任一父类）看是否响应选择器@selector(printMessageWithString:)。假设在类的函数派发列表或者缓存中找到了对应的函数实现，那么执行该函数。如此看来，objc_msgSend函数没有返回值，它开始执行然后找到对应的目标函数并执行，因此目标函数的返回值被视为objc_msgSend函数的返回值。</p>\n<p>Bill Bumgarner对于objc_msgSend的研究比我要表达的更为深入（<a href=\"http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"external\">part 1</a>,<a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage/\" target=\"_blank\" rel=\"external\">part 2</a>,<a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path/\" target=\"_blank\" rel=\"external\">part 3</a>）。总结一下他所要表达的以及你在查阅运行时机制源代码时可能发现的内容：</p>\n<ol>\n<li>检测屏蔽的函数和死循环，很显然如果代码运行在垃圾回收的环境下，我们可以忽略-retain,-release的调用，诸如此类。</li>\n<li>检测空对象。 不同于其他编程语言，在Objective-C中发送一个消息给空对象是完全合法的。[there are some valid reasons you’d want to. Assuming we have a non nil target we go on… ]</li>\n<li>然后在一个类中查找函数指针，首先是搜索缓存列表，如果找到了对应的函数指针就跳转对其实现代码段，即执行函数。</li>\n<li>如果在缓存列表中没有找到对应的函数指针，便搜索类中的函数派发列表。如果找到了对应的函数指针即跳转到其实现代码段。</li>\n<li>如果在缓存列表和函数列表都没有找到对应的函数，随即跳转到消息转发机制，意味着代码会被编译成c语言代码。所以一个函数如下所示：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">int</span>)doComputeWithNum:(<span class=\"keyword\">int</span>)aNum</div></pre></td></tr></table></figure>\n<p>将会被编译成：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> aClass_doComputeWithNum(aClass *<span class=\"keyword\">self</span>,SEL _cmd,<span class=\"keyword\">int</span> aNum)</div></pre></td></tr></table></figure>\n<p>此时，运行时机制通过这些函数的指针来调用这些转化后的函数，现在你已经不能直接调用这些函数，但是Cocoa库提供了一个方法来获得这些函数的函数指针。。。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//declare C function pointer</span></div><div class=\"line\"><span class=\"keyword\">int</span> (computeNum *)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>);</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//methodForSelector is COCOA &amp; not ObjC Runtime</span></div><div class=\"line\"><span class=\"comment\">//gets the same function pointer objc_msgSend gets</span></div><div class=\"line\">computeNum = (<span class=\"keyword\">int</span> (*)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>))[target methodForSelector:<span class=\"keyword\">@selector</span>(doComputeWithNum:)];</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//execute the C function pointer returned by the runtime</span></div><div class=\"line\">computeNum(obj,<span class=\"keyword\">@selector</span>(doComputeWithNum:),aNum);</div></pre></td></tr></table></figure>\n<p>这样，你可以知道访问这些函数并在运行时中直接调用，甚至利用这种方法来绕开运行时的动态调用来确保一个指定的函数被执行。运行时机制同样可以调用你的函数，只不过是通过objc_msgSend()。</p>\n<h3 id=\"Objective-C消息传送\"><a href=\"#Objective-C消息传送\" class=\"headerlink\" title=\"Objective-C消息传送\"></a>Objective-C消息传送</h3><p>在Objective-C中，发送一个消息给一个不会做出响应的对象是合法的，甚至可能是有意这样设计的。苹果在其开发文档中给出的原因之一是为了模拟Objective-C不支持的多继承，或者你只是想抽象化你的设计，隐藏能处理这些消息的实例对象或类。这是运行时机制必要的功能之一。<br>消息传送工作流程：</p>\n<ol>\n<li>运行时机制搜寻了对象的类和它所有父类中的缓存列表和函数列表，但是并没有找到指定的方法。</li>\n<li>随后运行时机制将会调用你类中的 +(BOOL)resolveInstanceMethod:(SEL)aSEL方法给你一次机会为指定的函数提供函数实现，并告诉运行时机制你已经实现了这个方法。如果运行时机制再次搜索这个函数就能找到对应的函数实现。你可以如下所示，实现这个功能：</li>\n</ol>\n<p>定义一个函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> fooMethod(<span class=\"keyword\">id</span> obj, SEL _cmd)</div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Doing Foo\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如下所示，使用class_addMethod()来实现</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(aSEL == <span class=\"keyword\">@selector</span>(doFoo:))&#123;</div><div class=\"line\">        class_addMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],aSEL,(IMP)fooMethod,<span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>class_addMethod()最后一个参数“v@:”表示函数fooMethod的返回值和参数，你可以在运行时机制指南中类型编码<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"external\">Type Encodings</a>了解你可以具体的规则。</p>\n<ol>\n<li>运行时机制随后会调用- (id)forwardingTargetForSelector:(SEL)aSelector函数，给你一次机会将运行时指向另外一个能响应目标函数的对象。这样做比触发消耗更大的函数：-(void)forwardInvocation:(NSInvocation *)anInvocation更划算。你的具体实现可能如下所示：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(aSelector == <span class=\"keyword\">@selector</span>(mysteriousMethod:))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> alternateObject;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>很显然你不想返回self指针，否则可能导致死循环。</p>\n<ol>\n<li>此时，运行时机制尝试最后一次去获取消息的预期目标，并调用- (void)forwardInvocation:(NSInvocation *)anInvocation。如果你未曾了解NSInvocation<a href=\"https://developer.apple.com/reference/foundation/nsinvocation\" target=\"_blank\" rel=\"external\">点击查看</a>,这是Objective-C消息中很重要的构成部分。一旦你持有一个NSInvocation对象，你基本上可以更改消息的任何内容，包括目标对象，选择器和函数参数。你可能操作如下：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation</div><div class=\"line\">&#123;</div><div class=\"line\">    SEL invSEL = invocation.selector;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span>([altObject respondsToSelector:invSEL]) &#123;</div><div class=\"line\">        [invocation invokeWithTarget:altObject];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doesNotRecognizeSelector:invSEL];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果类是继承自NSObjct，- (void)forwardInvocation:(NSInvocation *)anInvocation函数的默认实现是调用-doesNotRecognizeSelector函数，如果你还想做点什么来响应这次消息转送，重载这个函数将是最后一次机会。</p>\n<h3 id=\"实例变量的无碎片化\"><a href=\"#实例变量的无碎片化\" class=\"headerlink\" title=\"实例变量的无碎片化\"></a>实例变量的无碎片化</h3>"},{"title":"about","url":"http://yoursite.com/about/index.html","content":""},{"title":"category","url":"http://yoursite.com/category/index.html","content":""},{"title":"","url":"http://yoursite.com/css/personal-style.css","content":"\n@font-face {\n  font-family: \"Meiryo\";\n  src: url(\"/fonts/Meiryo.eot\");\n  /* IE9 */\n  src: url(\"/fonts/Meiryo.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */\n  url(\"/fonts/Meiryo.woff\") format(\"woff\"), /* chrome, firefox */\n  url(\"/fonts/Meiryo.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url(\"/fonts/Meiryo.svg#Meiryo\") format(\"svg\");\n  /* iOS 4.1- */\n  font-style: normal;\n  font-weight: normal;\n}\n\nhtml.page-home {\n\n\tbackground: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);\n\tbackground-blend-mode: screen;\n\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n\n}\n"},{"title":"link","url":"http://yoursite.com/link/index.html","content":""},{"title":"project","url":"http://yoursite.com/project/index.html","content":""},{"title":"search","url":"http://yoursite.com/search/index.html","content":""},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":""}]