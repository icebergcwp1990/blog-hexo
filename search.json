[{"title":"Hello,Hexo","url":"http://yoursite.com/2016/09/28/Hello-Hexo/","content":"<h3 id=\"hello-Hexo\"><a href=\"#hello-Hexo\" class=\"headerlink\" title=\"hello , Hexo\"></a>hello , Hexo</h3><blockquote>\n<p>Where there is a will , there is a way.<br>-— for my self</p>\n</blockquote>\n<p>Wow, I think hexo is a amazing stuff! I like it really! Let’s start !</p>\n"},{"title":"Hello World","url":"http://yoursite.com/2016/09/28/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"Objective-C Runtime 解析","url":"http://yoursite.com/2015/10/13/objective-c_runtime_解析/","content":"<p>这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以<a href=\"http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"external\">查看原文</a>。</p>\n<p>以下是正文：</p>\n<p>一般而言，当人们刚接触Coacoa/Objective-C的时候，运行时（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们通常会将大部分的时间和精力用于研究Cocoa Framework以及如何使用它。然而，每一个人至少应该清楚运行时是如何运转的，而不仅仅停留在编译方式的认知层面，如：[target doMethodWith:var];编译之后变成object_msgSend(target,@selector(doMethodWith:),var1)。了解Runtime的工作原理可以帮助你进一步理解Objective-C这门语言以及你编写的App的运转流程。我相信各个水平层次的Mac/iPhone开发者都会在研究Runtime的过程中有所收获。</p>\n<p><strong>Objective-C Runtime是开源的</strong></p>\n<p>Runtime是开源的，你随时可以在<a href=\"http://opensource.apple.com\" target=\"_blank\" rel=\"external\">源代码</a>上查阅。事实上，查阅源代码是弄清楚Objective-C原理的首选途径之一，胜过阅读苹果开发文档。下载最新版本的源代码<a href=\"http://opensource.apple.com/source/objc4/objc4-680/\" target=\"_blank\" rel=\"external\">点击我</a>。</p>\n<p><strong>动态 &amp; 静态 语言</strong></p>\n<p>Objective-C是基于运行时的语言，意味着它会尽可能地将决定代码执行逻辑的操作从编译&amp;链接阶段延迟到代码被执行的阶段。这将给你带来很大的灵活性，因此如果有必要的话你可以将消息重定向到合适的对象，或者你甚至可以交换两个方法实现，等等。实现上述功能需要运行时具备审查对象可以响应哪些请求和不能响应哪些请求然后准确地派发消息的能力。如果我们将Objective-C这一特性对比C语言。C语言程序运行始于main()函数，基于至上而下的设计执行你的逻辑和调用你实现的函数。C结构体不能通过发送请求到其他的结构体来执行某个函数。很可能你会编写一段C语言代码，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; stdio.h &gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\"</span>);</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码经过编译器编译、优化，然后将优化后的代码转化成汇编语言：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"symbol\">.text</span></div><div class=\"line\"> <span class=\"meta\">.align</span> <span class=\"number\">4</span>,<span class=\"number\">0x90</span></div><div class=\"line\"> .globl _main</div><div class=\"line\"><span class=\"symbol\">_main</span>:</div><div class=\"line\"><span class=\"symbol\">Leh_func_begin1</span>:</div><div class=\"line\">\t<span class=\"keyword\">pushq </span>%rbp</div><div class=\"line\"><span class=\"symbol\">Llabel1</span>:</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rsp, %rbp</div><div class=\"line\"><span class=\"symbol\">Llabel2</span>:</div><div class=\"line\"> <span class=\"keyword\">subq </span><span class=\"number\">$16</span>, %rsp</div><div class=\"line\"><span class=\"symbol\">Llabel3</span>:</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rsi, %rax</div><div class=\"line\"> <span class=\"keyword\">movl </span>%edi, %ecx</div><div class=\"line\"> <span class=\"keyword\">movl </span>%ecx, -<span class=\"number\">8</span>(%rbp)</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rax, -<span class=\"number\">16</span>(%rbp)</div><div class=\"line\"> xorb %al, %al</div><div class=\"line\"> leaq LC(%rip), %rcx</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rcx, %rdi</div><div class=\"line\"> call _printf</div><div class=\"line\"> <span class=\"keyword\">movl </span><span class=\"number\">$0</span>, -<span class=\"number\">4</span>(%rbp)</div><div class=\"line\"> <span class=\"keyword\">movl </span>-<span class=\"number\">4</span>(%rbp), %eax</div><div class=\"line\"> <span class=\"keyword\">addq </span><span class=\"number\">$16</span>, %rsp</div><div class=\"line\"> <span class=\"keyword\">popq </span>%rbp</div><div class=\"line\"> ret</div><div class=\"line\"><span class=\"symbol\">Leh_func_end1</span>:</div><div class=\"line\"> .cstring</div><div class=\"line\"><span class=\"symbol\">LC</span>:</div><div class=\"line\"> <span class=\"meta\">.asciz</span> <span class=\"string\">\"Hello World!\"</span></div></pre></td></tr></table></figure>\n<p>随后链接相关的库生成一个可执行文件。对比于Objective-C，虽然代码处理过程很相似，但是编译后的代码取决于Objective-C Runtime库。当我们最初学习Objective-C时被告知中括号里面的代码是如何被处理的，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> doSomethingWithVar:var1];</div></pre></td></tr></table></figure>\n<p>被转变成</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(doSomethingWithVar:),var1);</div></pre></td></tr></table></figure>\n<p>除此之外我们并不真的知道Runtime是如何工作的，也许很久以后会知道。</p>\n<p><strong>何为Runtime(运行时)</strong></p>\n<p>Objective-C Runtime是一个Runtime库，主要有C语言&amp;汇编语言编写而成，在C语言的基础上加上面向对象的功能之后就成为了Objective-C语言。这意味着Runtime负责加载类，方法派发，方法传达等操作。本质上而言，Runtime提供了所有的需要的结构用以支持Objective-C的面向对象编程。</p>\n<p><strong>Objective-C 运行时术语</strong></p>\n<p>在进一步深入之前，让我们扫清一些术语的障碍，这样使我们处于同一立场。就MacOS X App &amp; iPhone OS App开发者所关心而言，这里有两种Runtime: Modern Runtime和Legacy Runtime。Modern Runtime适用于所有64位MacOS应用和所有iPhone应用，Legacy Runtime适用于所有的32位MacOS应用。Runtime中有两种类型的函数：实例函数（以‘-’符号开头如-(void)doFoo）;类函数（以‘+’开头如+(id)alloc）。两种函数都与C函数很像，包含一组实现某个任务的代码，如下所示</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">NSString</span> *)movieTitle</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"Futurama: Into the Wild Green Yonder\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>选择器：在Objective-C中，选择器本质上是一个C数据结构体用以标识一个对象将要执行的函数。在Runtime中的定义如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector  *SEL;</div></pre></td></tr></table></figure>\n<p>使用方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SEL aSel = <span class=\"keyword\">@selector</span>(movieTitle);</div></pre></td></tr></table></figure>\n<p>消息调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[target getMovieTitleForObject:obj];</div></pre></td></tr></table></figure>\n<p>Objective-C消息就是中括号[]里面的所有东西，包括消息的接受者target，调用的函数getMovieTileForObject以及所有发送的参数obj。消息调用虽然样式上类似于c函数调用但是实现却不同。实际上，当你发送一个消息给一个对象并意味着函数会被执行。对象可能会检测谁是消息的发送者，基于此再决定执行一个不同的函数或者转送消息给其他不同的目标对象。如果你查看Runtime里的类定义，你将会看到如下所示的内容：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa;</div><div class=\"line\">&#125; *<span class=\"keyword\">id</span>;</div></pre></td></tr></table></figure>\n<p>这里有几个要点。首先是类Class和对象Object都有一个对应的结构体。所有的objc_object结构体都有一个类指针isa，这就是我们所说的“isa指针”。Runtime需要通过检测一个对象的isa指针去查看对象的类别，然后查看该对象是否能响应你当前发送过来的消息。接下来是id指针，id指针默认不属于任何类别只表明指向的是一个Objective-C对象。对于id指针指向的对象，你可以获知对象的类别，查看对象是否能响应某个函数等等，然后当你具体了解了id指针指向的对象之后便可以更好的使用该对象。你同样可以查看LLVM/Clang文档中Blocks的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Block_literal_1 &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> *isa; <span class=\"comment\">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></div><div class=\"line\">    <span class=\"keyword\">int</span> flags;</div><div class=\"line\">    <span class=\"keyword\">int</span> reserved; </div><div class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</div><div class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor_1 &#123;</div><div class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved; <span class=\"comment\">// NULL</span></div><div class=\"line\">     <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;  <span class=\"comment\">// sizeof(struct Block_literal_1)</span></div><div class=\"line\"> <span class=\"comment\">// optional helper functions</span></div><div class=\"line\">     <span class=\"keyword\">void</span> (*copy_helper)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</div><div class=\"line\">     <span class=\"keyword\">void</span> (*dispose_helper)(<span class=\"keyword\">void</span> *src); </div><div class=\"line\">    &#125; *descriptor;</div><div class=\"line\">    <span class=\"comment\">// imported variables</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Block结构的设计兼容于Runtime。因此Block被视为一个Objective-C对象，所有也就可以响应消息如-retain,-release,-copy等等。</p>\n<p>IMP:Method Implementations</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">id</span> (*IMP)(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>,SEL _cmd,...);</div></pre></td></tr></table></figure>\n<p>IMP是一个函数指针，由编译器生成且指向函数的实现内容。如果你目前是一个Objective-C新手则浅尝辄止，但是我们随后会了解Runtime是如何调用你的函数的。</p>\n<p>Objective-C类：类里面是什么？在Objective-C中，类实现基本上类似于：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//vars</span></div><div class=\"line\"><span class=\"built_in\">NSInteger</span> counter;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//methods</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)doFoo;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>但是类在Runtime中定义远不如此，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\"><span class=\"meta\">#endif</span></div></pre></td></tr></table></figure>\n<p>我们可以看到一个类中声明了一个父类的引用，类名，实例变量列表，方法列表，缓存以及协议列表。当响应发送给类或对象的消息时，Runtime需要用到这些信息。</p>\n<p><strong>类定义对象同时类本身也是对象？何解？</strong></p>\n<p>之前我提到过在Objective-C中类本身也是对象，Runtime通过引入元类（Meta Class）来处理类对象。当你发送一个类似于[NSObject alloc]消息的时候，实际上是发送一个消息给类对象，此时将类对象视为元类的实例对待，而元类本身也是一个根元类（Root Meta Class）的实例。While if you say subclass from NSObject, your class points to NSObject as it’s superclass. However all meta classes point to the root metaclass as their superclass. (原文似乎表达观点有误，暂不翻译)。所有的元类仅有一个类函数列表（不同于类处理实例函数列表，还有变量列表和协议列表等等）。因此，当你发送一个消息给类对象时，如[NSObject alloc]，objc_megSend()实际上是搜索元类的函数列表查看是否有响应的函数，如果存在则在该类对象上执行该函数。</p>\n<p><strong>为什么继承Apple的原生类？</strong></p>\n<p>在你刚开始Cocoa编程时，相关教程都是说创建一个类继承于NSObject然后开始编写自己的代码，简单地继承Apple的原生类会让你获益匪浅。其中一个你甚至意识不到的好处就是让你创建的类运行于Runtime之上。当我们新建一个实例对象，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyObject *object = [[MyObject alloc] init];</div></pre></td></tr></table></figure>\n<p>最先被执行的消息是+alloc。如果你<a href=\"https://developer.apple.com/library/content/#documentation/cocoa/reference/Foundation/Classes/NSObject_Class/Reference/Reference.html\" target=\"_blank\" rel=\"external\">查阅这个文档</a>会发现：“isa这一实例变量被初始化指向一个描述对于类的数据结构体，其他所有的实例变量都被初始化为0”。所以，通过继承Apple原始类不仅仅继承一些不错的属性，而且还能让我们轻易地创建符合于Runtime要求的对象（包含一个指向类的isa指针）。</p>\n<p><strong>类缓存机制</strong></p>\n"},{"title":"about","url":"http://yoursite.com/about/index.html","content":""},{"title":"category","url":"http://yoursite.com/category/index.html","content":""},{"title":"link","url":"http://yoursite.com/link/index.html","content":""},{"title":"","url":"http://yoursite.com/css/personal-style.css","content":"\n@font-face {\n  font-family: \"Meiryo\";\n  src: url(\"/fonts/Meiryo.eot\");\n  /* IE9 */\n  src: url(\"/fonts/Meiryo.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */\n  url(\"/fonts/Meiryo.woff\") format(\"woff\"), /* chrome, firefox */\n  url(\"/fonts/Meiryo.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url(\"/fonts/Meiryo.svg#Meiryo\") format(\"svg\");\n  /* iOS 4.1- */\n  font-style: normal;\n  font-weight: normal;\n}\n\nhtml.page-home {\n\n\tbackground: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);\n\tbackground-blend-mode: screen;\n\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n\n}\n"},{"title":"project","url":"http://yoursite.com/project/index.html","content":""},{"title":"search","url":"http://yoursite.com/search/index.html","content":""},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":""}]