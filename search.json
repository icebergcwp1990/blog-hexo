[{"title":"Hello World","url":"http://yoursite.com/2016/09/28/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"Cocoa RunLoop 系列之实现原理","url":"http://yoursite.com/2015/01/05/Cocoa RunLoop 系列之实现原理/","content":"<h3 id=\"Event-Loop-amp-Cocoa-RunLoop\"><a href=\"#Event-Loop-amp-Cocoa-RunLoop\" class=\"headerlink\" title=\"Event Loop &amp; Cocoa RunLoop\"></a>Event Loop &amp; Cocoa RunLoop</h3><h4 id=\"宏观上：Event-Loop\"><a href=\"#宏观上：Event-Loop\" class=\"headerlink\" title=\"宏观上：Event Loop\"></a>宏观上：Event Loop</h4><ol>\n<li>RunLoop是一个用于循环监听和处理事件或者消息的模型，接收请求，然后派发给相关的处理模块，wikipedia上有更为全面的介绍：<a href=\"https://en.wikipedia.org/wiki/Event_loop\" target=\"_blank\" rel=\"external\">Event_loop</a></li>\n<li>Cocoa RunLoop属于Event Loop模型在Mac平台的具体实现</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Event_loop#Implementations\" target=\"_blank\" rel=\"external\">其他平台的类似实现</a>：X Window程序，Windows程序 ，Glib库等</li>\n</ol>\n<h4 id=\"微观上-Cocoa-RunLoop\"><a href=\"#微观上-Cocoa-RunLoop\" class=\"headerlink\" title=\"微观上: Cocoa RunLoop\"></a>微观上: Cocoa RunLoop</h4><ol>\n<li>Cocoa RunLoop本质上就是一个对象，提供一个入口函数启动事件循环，在满足特点条件后才会退出。</li>\n<li>Cocoa RunLoop与普通while/for循环不同的是它能监听处理事件和消息，能智能休眠和被唤醒，这些功能的其实现依赖于Mac Port。</li>\n</ol>\n<h3 id=\"Cocoa-RunLoop的内部结构\"><a href=\"#Cocoa-RunLoop的内部结构\" class=\"headerlink\" title=\"Cocoa RunLoop的内部结构\"></a>Cocoa RunLoop的内部结构</h3><p>但凡说到Cocoa RunLoop内部结构，都离不开下面这张图，来源于Apple开发者文档</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg\" alt=\"图1-1 RunLoop结构图\"></p>\n<p>结合上图，可将RunLoop架构划分为四个部分：</p>\n<ol>\n<li>事件源</li>\n<li>运行模式</li>\n<li>循环机制</li>\n<li>执行反馈</li>\n</ol>\n<h4 id=\"事件源\"><a href=\"#事件源\" class=\"headerlink\" title=\"事件源\"></a>事件源</h4><p>Cocoa RunLoop接受的事件源分为两种类型：Input Sources 和 Timer Sources</p>\n<p><strong> Input Sources </strong></p>\n<p>Input Sources通过异步派发的方式将事件转送到目标线程，事件类别分为两大块：</p>\n<ol>\n<li><p>Port-Based Sources ：</p>\n<p> 基于Mach端口的事件源，Cocoa和Core Foundation这两个框架已经提供了内部支持，只需要调用端口相关的对象或者函数就能提供端口进行通信。比如：将NSPort对象部署到RunLoop中，实现两个线程的循环通信。</p>\n</li>\n<li><p>Custom Input Sources ：</p>\n<ol>\n<li>用户自定义的输入源：使用Core Foundation框架中CFRunLoopSourceRef对象的相关函数实现。（具体流程暂未研究，留坑待填）</li>\n<li><p>Cocoa Perform Selector Sources：Cocoa框架内部实现的自定义输入源，可以跨线程调用，实现线程见通信，有点类似于Port-Based事件源，不同的是这种事件源只在RunLoop上部署一次，执行结束后便会自动移除。如果目标线程中没有启动RunLoop也就意味着无法部署这类事件源，因此不会得到预期的结果。</p>\n<p> 使用Cocoa自定义事件源的函数接口，如下：</p>\n</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">//部署在主线程</span></div><div class=\"line\">\t<span class=\"comment\">//参数列表：Selector:事件源处理函数,Selector参数,是否阻塞当前线程,指定RunLoop模式</span></div><div class=\"line\">\tperformSelectorOnMainThread:withObject:waitUntilDone:</div><div class=\"line\">performSelectorOnMainThread:withObject:waitUntilDone:modes:</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//部署在指定线程</span></div><div class=\"line\"><span class=\"comment\">//参数列表：Selector:事件源处理函数,指定线程,Selector参数,是否阻塞当前线程,指定RunLoop模式</span></div><div class=\"line\">permSelector:onThread:withObject:waitUntilDone:</div><div class=\"line\">performSelector:onThread:withObject:waitUntilDone:modes:</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//部署在当前线程</span></div><div class=\"line\"><span class=\"comment\">//参数列表：Selector:事件源处理函数,Selector参数,延时执行时间,指定RunLoop模式</span></div><div class=\"line\">performSelector:withObject:afterDelay:</div><div class=\"line\">performSelector:withObject:afterDelay:inModes:</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//撤销某个对象通过函数performSelector:withObject:afterDelay:部署在当前线程的全部或者指定事件源</span></div><div class=\"line\">cancelPreviousPerformRequestsWithTarget:</div><div class=\"line\">cancelPreviousPerformRequestsWithTarget:selector:object:</div></pre></td></tr></table></figure>\n<p>综上，Input Sources包括基于Mach端口的事件源和自定义的事件源，二者的唯一区别在于被触发的方式：前者是由内核自动触发，后者则需要在其他线程中手动触发。</p>\n<p><strong> Timer Sources </strong></p>\n<p>不同于Input Sources的异步派发，Timer Source是通过同步派发的方式，在预设时间到达时将事件转送到目标线程。这种事件源可用于线程的自我提醒功能，实现周期性的任务。</p>\n<ol>\n<li>如果RunLoop当前运行模式没有添加Time Sources，则在RunLoop中部署的定时器不会被执行。</li>\n<li>设定的间隔时间与真实的触发时间之间没有必然联系，定时器会根据设定的间隔时间周期性的派发消息到RunLoop，但是真实的触发时间由RunLoop决定，假设RunLoop当前正在处理其一个长时间的任务，则触发时间会被延迟，如果在最终触发之前Timer已经派发了N个消息，RunLoop也只会当做一次派发对待，触发一次对应的处理函数。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"运行模式\"><a href=\"#运行模式\" class=\"headerlink\" title=\"运行模式\"></a>运行模式</h4><p>运行模式类似于一个过滤器，用于屏蔽那些不关心的事件源，让RunLoop专注于监听和处理指定的事件源和回调监听。</p>\n<p>CFRunLoopMode 和 CFRunLoop 的数据结构大致如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;     <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// Set&lt;Source/Observer/Timer&gt;</span></div><div class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode;    <span class=\"comment\">// Current Runloop Mode</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;           <span class=\"comment\">// Set</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</div><div class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;            <span class=\"comment\">// Mode Name, 例如 @\"kCFRunLoopDefaultMode\"</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0;    <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1;    <span class=\"comment\">// Set</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array</span></div><div class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers;    <span class=\"comment\">// Array</span></div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>结合以上源码，总结以下几点：</p>\n<ol>\n<li>每种模式通过name属性作为标识。</li>\n<li>一种运行模式（Run Loop Mode）就是一个集合，包含需要监听的事件源Input Sources和Timer Soueces以及需要触发的回调监听observers。</li>\n<li>Cocoa RunLoop包含若干个Mode，调用RunLoop是指定的Mode称之为CurrentMode。RunLoop可以在不同的Mode下切换，切换时退出CurrentMode,并保存相关上下文，再进入新的Mode。</li>\n<li>在启动Cocoa RunLoop是必须指定一种的运行模式，且如果指定的运行模式没有包含事件源或者回调监听，RunLoop会立刻退出。</li>\n<li>CFRunLoop结构中的commonModes是Mode集合,将某个Mode的name添加到commonModes集合中，表示这个Mode具有“common”属性。</li>\n<li>CFRunLoop结构中的commonModeItems则是共用源的集合，包括事件源和回调监听。这些共用源会被自动添加到具有“common”属性的Mode中。</li>\n</ol>\n<p><strong> Note </strong> : 不同的运行模式区别在于事件源的不同，比如来源于不同端口的事件和端口事件与Timer事件。不能用于区分不同的事件类型，比如鼠标消息事件和键盘消息事件，这两种事件同属于基于端口的事件源。</p>\n<p>以下是苹果预定义好的一些运行模式：</p>\n<ul>\n<li>NSDefaultRunLoopMode //默认的运行模式，适用于大部分情况</li>\n<li>NSConnectionReplyMode //Cocoa库用于监听NSConnection对象响应，开发者很少使用</li>\n<li>NSModalPanelRunLoopMode //模态窗口相关事件源</li>\n<li>NSEventTrackingRunLoopMode  //鼠标拖拽或者屏幕滚动时的事件源</li>\n<li>NSRunLoopCommonModes //用于操作RunLoop结构中commonModes和commonModeItems两个属性</li>\n</ul>\n<h4 id=\"循环机制\"><a href=\"#循环机制\" class=\"headerlink\" title=\"循环机制\"></a>循环机制</h4><p>循环机制涉及两方面：</p>\n<p><strong> RunLoop与线程之间的关系 </strong></p>\n<p>Apple文档中提到:开发者不需要手动创建RunLoop对象，每个线程包括主线程都关联了一个RunLoop对象。除了主线程的RunLoop在程序启动时被开启，其他线程的RunLoop都需要手动开启。</p>\n<p>待解决的疑问：</p>\n<ol>\n<li>线程中的RunLoop是一直存在还是需要时再创建？</li>\n<li>线程与RunLoop的是如何建立联系的？</li>\n<li>线程与RunLoop对象是否是一一对应的关系？</li>\n</ol>\n<p><strong> RunLoop事件处理流程 </strong></p>\n<p>弄清楚RunLoop内部处理逻辑是理解RunLoop的关键，将单独写一篇博客进行分析。</p>\n<p>待解决的疑问：</p>\n<ol>\n<li>RunLoop如何处理不同事件源？</li>\n<li>RunLoop不同模式切换是如何实现的？</li>\n</ol>\n<p>以上两方面，将在下一篇博客<a href=\"\">Cocoa RunLoop 系列之源码解析</a>中结合源代码来找到答案。</p>\n<h4 id=\"执行反馈\"><a href=\"#执行反馈\" class=\"headerlink\" title=\"执行反馈\"></a>执行反馈</h4><p>RunLoop Observers机制属于RunLoop一个反馈机制，将RunLoop一次循环划分成若干个节点，当执行到对应的节点调用相应的回调函数，将RunLoop当前的执行状态反馈给用户。</p>\n<ol>\n<li>用户可以通过Core Foundation框架中的CFRunLoopObserverRef注册回调监听。</li>\n<li><p>监听节点：</p>\n<ul>\n<li>The entrance to the run loop. //RunLoop启动</li>\n<li>When the run loop is about to process a timer. //即将处理Timer事件源</li>\n<li>When the run loop is about to process an input source. //即将处理Input事件源</li>\n<li>When the run loop is about to go to sleep. //即将进入休眠</li>\n<li>When the run loop has woken up, but before it has processed the event that woke it up. //重新被唤醒，且在处理唤醒事件之前</li>\n<li>The exit from the run loop. //退出RunLoop</li>\n</ul>\n</li>\n<li><p>监听类别分为两种：一次性和重复监听。</p>\n</li>\n</ol>\n<h3 id=\"何时使用RunLoop\"><a href=\"#何时使用RunLoop\" class=\"headerlink\" title=\"何时使用RunLoop\"></a>何时使用RunLoop</h3><p>由于主线程的RunLoop在程序启动时被自动创建并执行，因此只有在其他线程中才需要手动启动RunLoop。</p>\n<p>在非主线程中，以下几种情况适用于RunLoop:</p>\n<ol>\n<li>使用基于端口或者自定义的事件源与其他线程进行通信。</li>\n<li>需要在当前线程中使用Timer，必须部署才RunLoop中才有效。</li>\n<li>在目标线程中调用performSelector… 函数，因为本质上使用了Cocoa自定义的事件源，依赖于RunLoop才能被触发。</li>\n<li>线程需要进行周期性的任务，需要长时间存在，而非执行一次。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>一直以来，RunLoop对我来说都属于一个比较模糊的概念，在实际编程中也有用到RunLoop的一些功能，确实感觉到很强大，但是仅仅停留在应用层面，并不是很理解具体含义。因此，为了更好的使用RunLoop，决定好好的研究和梳理一下RunLoop相关的知识点。</p>\n"},{"title":"Objective-C Runtime 解析","url":"http://yoursite.com/2015/01/01/objective-c_runtime_解析/","content":"<p>这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以<a href=\"http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"external\">查看原文</a>。</p>\n<p><strong>以下是正文：</strong></p>\n<p>一般而言，当人们刚接触Cocoa/Objective-C的时候，运行时机制（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们通常会将大部分的时间和精力用于研究Cocoa Framework以及如何使用它。然而，每一个人至少应该清楚运行时是如何运转的，而不仅仅停留在编译方式的认知层面，如：[target doMethodWith:var];编译之后变成object_msgSend(target,@selector(doMethodWith:),var1)。了解运行时机制的工作原理可以帮助你进一步理解Objective-C这门语言以及你编写的App的运转流程。我相信各个水平层次的Mac/iPhone开发者都会在研究运行时机制的过程中有所收获。</p>\n<h3 id=\"Objective-C-Runtime库是开源的\"><a href=\"#Objective-C-Runtime库是开源的\" class=\"headerlink\" title=\"Objective-C Runtime库是开源的\"></a>Objective-C Runtime库是开源的</h3><p>Objective-C Runtime库是开源的，你随时可以在<a href=\"http://opensource.apple.com\" target=\"_blank\" rel=\"external\">源代码</a>上查阅。事实上，查阅源代码是弄清楚Objective-C原理的首选途径之一，胜过阅读苹果开发文档。下载最新版本的源代码<a href=\"http://opensource.apple.com/source/objc4/objc4-680/\" target=\"_blank\" rel=\"external\">点击我</a>。</p>\n<h3 id=\"动态-amp-静态-语言\"><a href=\"#动态-amp-静态-语言\" class=\"headerlink\" title=\"动态 &amp; 静态 语言\"></a>动态 &amp; 静态 语言</h3><p>Objective-C是基于运行时的语言，意味着它会尽可能地将决定代码执行逻辑的操作从编译&amp;链接阶段延迟到代码被执行的阶段。这将给你带来很大的灵活性，因此如果有必要的话你可以将消息重定向到合适的对象，或者你甚至可以交换两个方法实现，等等。实现上述功能需要运行时具备审查对象可以响应哪些请求和不能响应哪些请求然后准确地派发消息的能力。如果我们将Objective-C这一特性对比C语言。C语言程序运行始于main()函数，基于至上而下的设计执行你的逻辑和调用你实现的函数。C结构体不能通过发送请求到其他的结构体来执行某个函数。很可能你会编写一段C语言代码，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt; stdio.h &gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\"</span>);</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码经过编译器编译、优化，然后将优化后的代码转化成汇编语言：</p>\n<figure class=\"highlight arm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"symbol\">.text</span></div><div class=\"line\"> <span class=\"meta\">.align</span> <span class=\"number\">4</span>,<span class=\"number\">0x90</span></div><div class=\"line\"> .globl _main</div><div class=\"line\"><span class=\"symbol\">_main</span>:</div><div class=\"line\"><span class=\"symbol\">Leh_func_begin1</span>:</div><div class=\"line\">\t<span class=\"keyword\">pushq </span>%rbp</div><div class=\"line\"><span class=\"symbol\">Llabel1</span>:</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rsp, %rbp</div><div class=\"line\"><span class=\"symbol\">Llabel2</span>:</div><div class=\"line\"> <span class=\"keyword\">subq </span><span class=\"number\">$16</span>, %rsp</div><div class=\"line\"><span class=\"symbol\">Llabel3</span>:</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rsi, %rax</div><div class=\"line\"> <span class=\"keyword\">movl </span>%edi, %ecx</div><div class=\"line\"> <span class=\"keyword\">movl </span>%ecx, -<span class=\"number\">8</span>(%rbp)</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rax, -<span class=\"number\">16</span>(%rbp)</div><div class=\"line\"> xorb %al, %al</div><div class=\"line\"> leaq LC(%rip), %rcx</div><div class=\"line\"> <span class=\"keyword\">movq </span>%rcx, %rdi</div><div class=\"line\"> call _printf</div><div class=\"line\"> <span class=\"keyword\">movl </span><span class=\"number\">$0</span>, -<span class=\"number\">4</span>(%rbp)</div><div class=\"line\"> <span class=\"keyword\">movl </span>-<span class=\"number\">4</span>(%rbp), %eax</div><div class=\"line\"> <span class=\"keyword\">addq </span><span class=\"number\">$16</span>, %rsp</div><div class=\"line\"> <span class=\"keyword\">popq </span>%rbp</div><div class=\"line\"> ret</div><div class=\"line\"><span class=\"symbol\">Leh_func_end1</span>:</div><div class=\"line\"> .cstring</div><div class=\"line\"><span class=\"symbol\">LC</span>:</div><div class=\"line\"> <span class=\"meta\">.asciz</span> <span class=\"string\">\"Hello World!\"</span></div></pre></td></tr></table></figure>\n<p>随后链接相关的库生成一个可执行文件。对比于Objective-C，虽然代码处理过程很相似，但是编译后的代码取决于Objective-C Runtime库。当我们最初学习Objective-C时被告知中括号里面的代码是如何被处理的，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> doSomethingWithVar:var1];</div></pre></td></tr></table></figure>\n<p>被转变成</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(doSomethingWithVar:),var1);</div></pre></td></tr></table></figure>\n<p>除此之外我们并不真的知道运行时机制是如何工作的，也许很久以后会知道。</p>\n<h3 id=\"何为Runtime-运行时\"><a href=\"#何为Runtime-运行时\" class=\"headerlink\" title=\"何为Runtime(运行时)\"></a>何为Runtime(运行时)</h3><p>Objective-C Runtime就是一个Runtime库，主要有C语言&amp;汇编语言编写而成，在C语言的基础上加上面向对象的功能之后就成为了Objective-C语言。这意味着运行时机制负责加载类，方法派发，方法传达等操作。本质上而言，运行时机制提供了所有的需要的结构用以支持Objective-C的面向对象编程。</p>\n<h3 id=\"Objective-C-运行时术语\"><a href=\"#Objective-C-运行时术语\" class=\"headerlink\" title=\"Objective-C 运行时术语\"></a>Objective-C 运行时术语</h3><p>在进一步深入之前，让我们扫清一些术语的障碍，这样使我们处于同一立场。就MacOS X App &amp; iPhone OS App开发者所关心而言，这里有两种运行时机制: Modern Runtime和Legacy Runtime。Modern Runtime适用于所有64位MacOS应用和所有iPhone应用，Legacy Runtime适用于所有的32位MacOS应用。运行时机制中有两种类型的函数：实例函数（以‘-’符号开头如-(void)doFoo）;类函数（以‘+’开头如+(id)alloc）。两种函数都与C函数很像，包含一组实现某个任务的代码，如下所示</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">NSString</span> *)movieTitle</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"Futurama: Into the Wild Green Yonder\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>选择器：在Objective-C中，选择器本质上是一个C数据结构体用以标识一个对象将要执行的函数。在运行时机制中的定义如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector  *SEL;</div></pre></td></tr></table></figure>\n<p>使用方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SEL aSel = <span class=\"keyword\">@selector</span>(movieTitle);</div></pre></td></tr></table></figure>\n<p>消息调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[target getMovieTitleForObject:obj];</div></pre></td></tr></table></figure>\n<p>Objective-C消息就是中括号[]里面的所有东西，包括消息的接受者target，调用的函数getMovieTileForObject以及所有发送的参数obj。消息调用虽然样式上类似于c函数调用但是实现却不同。实际上，当你发送一个消息给一个对象并意味着函数会被执行。对象可能会检测谁是消息的发送者，基于此再决定执行一个不同的函数或者转送消息给其他不同的目标对象。如果你查看运行时机制里的类定义，你将会看到如下所示的内容：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa;</div><div class=\"line\">&#125; *<span class=\"keyword\">id</span>;</div></pre></td></tr></table></figure>\n<p>这里有几个要点。首先是类Class和对象Object都有一个对应的结构体。所有的objc_object结构体都有一个类指针isa，这就是我们所说的“<strong>isa指针</strong>”。运行时机制需要通过检测一个对象的isa指针去查看对象的类别，然后查看该对象是否能响应你当前发送过来的消息。接下来是id指针，id指针默认不属于任何类别只表明指向的是一个Objective-C对象。对于id指针指向的对象，你可以获知对象的类别，查看对象是否能响应某个函数等等，然后当你具体了解了id指针指向的对象之后便可以更好的使用该对象。你同样可以查看LLVM/Clang文档中Blocks的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Block_literal_1 &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> *isa; <span class=\"comment\">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></div><div class=\"line\">    <span class=\"keyword\">int</span> flags;</div><div class=\"line\">    <span class=\"keyword\">int</span> reserved; </div><div class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</div><div class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor_1 &#123;</div><div class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved; <span class=\"comment\">// NULL</span></div><div class=\"line\">     <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;  <span class=\"comment\">// sizeof(struct Block_literal_1)</span></div><div class=\"line\"> <span class=\"comment\">// optional helper functions</span></div><div class=\"line\">     <span class=\"keyword\">void</span> (*copy_helper)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</div><div class=\"line\">     <span class=\"keyword\">void</span> (*dispose_helper)(<span class=\"keyword\">void</span> *src); </div><div class=\"line\">    &#125; *descriptor;</div><div class=\"line\">    <span class=\"comment\">// imported variables</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Block结构的设计兼容于运行时机制。因此Block被视为一个Objective-C对象，所有也就可以响应消息如-retain,-release,-copy等等。</p>\n<p>IMP:Method Implementations</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">id</span> (*IMP)(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>,SEL _cmd,...);</div></pre></td></tr></table></figure>\n<p>IMP是一个函数指针，由编译器生成且指向函数的实现内容。如果你目前是一个Objective-C新手则浅尝辄止，但是我们随后会了解运行时机制是如何调用你的函数的。</p>\n<p>Objective-C类：类里面是什么？在Objective-C中，类实现基本上类似于：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//vars</span></div><div class=\"line\"><span class=\"built_in\">NSInteger</span> counter;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//methods</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)doFoo;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>但是类在运行时机制中定义远不如此，如下</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\"><span class=\"meta\">#endif</span></div></pre></td></tr></table></figure>\n<p>我们可以看到一个类中声明了一个父类的引用，类名，实例变量列表，方法列表，缓存以及协议列表。当响应发送给类或对象的消息时，运行时机制需要用到这些信息。</p>\n<h3 id=\"类定义对象同时类本身也是对象？何解？\"><a href=\"#类定义对象同时类本身也是对象？何解？\" class=\"headerlink\" title=\"类定义对象同时类本身也是对象？何解？\"></a>类定义对象同时类本身也是对象？何解？</h3><p>之前我提到过在Objective-C中类本身也是对象，运行时机制通过引入元类（Meta Class）来处理类对象。当你发送一个类似于[NSObject alloc]消息的时候，实际上是发送一个消息给类对象，此时将类对象视为元类的实例对待，而元类本身也是一个根元类（Root Meta Class）的实例。While if you say subclass from NSObject, your class points to NSObject as it’s superclass. However all meta classes point to the root metaclass as their superclass. (原文似乎表达观点有误，暂不翻译)。所有的元类仅有一个类函数列表（不同于类处理实例函数列表，还有变量列表和协议列表等等）。因此，当你发送一个消息给类对象时，如[NSObject alloc]，objc_megSend()实际上是搜索元类的函数列表查看是否有响应的函数，如果存在则在该类对象上执行该函数。</p>\n<h3 id=\"为什么继承Apple的原生类？\"><a href=\"#为什么继承Apple的原生类？\" class=\"headerlink\" title=\"为什么继承Apple的原生类？\"></a>为什么继承Apple的原生类？</h3><p>在你刚开始Cocoa编程时，相关教程都是说创建一个类继承于NSObject然后开始编写自己的代码，简单地继承Apple的原生类会让你获益匪浅。其中一个你甚至意识不到的好处就是让你创建的类运行于运行时机制之上。当我们新建一个实例对象，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyObject *object = [[MyObject alloc] init];</div></pre></td></tr></table></figure>\n<p>最先被执行的消息是+alloc。如果你<a href=\"https://developer.apple.com/library/content/#documentation/cocoa/reference/Foundation/Classes/NSObject_Class/Reference/Reference.html\" target=\"_blank\" rel=\"external\">查阅这个文档</a>会发现：“isa这一实例变量被初始化指向一个描述对于类的数据结构体，其他所有的实例变量都被初始化为0”。所以，通过继承Apple原始类不仅仅继承一些不错的属性，而且还能让我们轻易地创建符合于运行时机制要求的对象（包含一个指向类的isa指针）。</p>\n<h3 id=\"类缓存机制\"><a href=\"#类缓存机制\" class=\"headerlink\" title=\"类缓存机制\"></a>类缓存机制</h3><p>当OC的运行时机制机制通过检视一个对象的isa指针指向的类时会发现该对象实现了很多函数。然而，你可能仅仅调用其中的一小部分也就意味没必要每一次查找某个函数时都去搜索一遍类中的函数列表。因此，类创建了缓存，将你每次搜索函数列表后找到的相应函数存入缓存中。所以，当objc_msgSend()在类中搜寻某个函数是首先会遍历缓存列表。这样做的理论依据在于如果你发送过某个消息给一个对象，你很可能回再次发送同样的消息。因此如果我们将该理论考虑在内意味着如果你有一个NSObject的子类MyObject,并运行以下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">MyObject *obj = [[MyObject alloc] init];</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></div><div class=\"line\">-(<span class=\"keyword\">id</span>)init &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init])&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> setVarA:@”blah”];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>接下来发生：</p>\n<ol>\n<li>[MyObject alloc]最先被执行。因为MyObject类没有实现alloc函数所以在该类自然找不到对应的函数，随后进入父类指针指向的NSObject类。</li>\n<li>询问NSObject类是否响应+alloc，发现其实现了alloc函数。+alloc检测到接收类是MyObject然后分配一块响应大小的内存并在其中初始化一个isa指针指向MyObject类。现在，我们获得了一个实例对象，随后运行时机制将NSObject类的+alloc函数指针存入NSObject对象对应的类中的缓存列表中。</li>\n<li>截至目前，我们发送了一个类消息，现在我们发送一个实例消息：调用-init函数或者自定义的初始化函数。显然，MyObject的实例对象能响应这个消息，因此-(id)init会被存入缓存列表中。</li>\n<li>随后self=[super init]被调用。super作为一个魔法关键字指向父类对象，因此转向NSObjct类中，调用init函数。这样做是为了确保面向对象继承体系（OOP inheritance）正常运转，因为所以的父类都将会正确地初始化它们的变量，然后作为子类对象可以正确地初始化自身的变量和必要时重载父类。</li>\n</ol>\n<p>在这个NSObject类的例子中，没有特别的要点出现。但是事实并不总是如此，有时候初始化很重要，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyObject</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"built_in\">NSString</span> *aString;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSString</span> *aString;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></div><div class=\"line\"> </div><div class=\"line\">-(<span class=\"keyword\">id</span>)init</div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">  [<span class=\"keyword\">self</span> setAString:<span class=\"literal\">nil</span>];</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@synthesize</span> aString;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">int</span> main (<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSAutoreleasePool</span> * pool = [[<span class=\"built_in\">NSAutoreleasePool</span> alloc] init];</div><div class=\"line\"> </div><div class=\"line\"> <span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSMutableArray</span> alloc];</div><div class=\"line\"> <span class=\"keyword\">id</span> obj2 = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"keyword\">id</span> obj3 = [<span class=\"built_in\">NSArray</span> alloc];</div><div class=\"line\"> <span class=\"keyword\">id</span> obj4 = [[<span class=\"built_in\">NSArray</span> alloc] initWithObjects:<span class=\"string\">@\"Hello\"</span>,<span class=\"literal\">nil</span>];</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj1 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj1 <span class=\"keyword\">class</span>]));</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj2 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj2 <span class=\"keyword\">class</span>]));</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj3 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj3 <span class=\"keyword\">class</span>]));</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj4 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj4 <span class=\"keyword\">class</span>]));</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"keyword\">id</span> obj5 = [MyObject alloc];</div><div class=\"line\"> <span class=\"keyword\">id</span> obj6 = [[MyObject alloc] init];</div><div class=\"line\">  </div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj5 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj5 <span class=\"keyword\">class</span>]));</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj6 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj6 <span class=\"keyword\">class</span>]));</div><div class=\"line\">  </div><div class=\"line\"> [pool drain];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你是Cocoa初学者，然后我问你上述代码的打印结果，你的回答可能如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSMutableArray</span></div><div class=\"line\"><span class=\"built_in\">NSMutableArray</span> </div><div class=\"line\"><span class=\"built_in\">NSArray</span></div><div class=\"line\"><span class=\"built_in\">NSArray</span></div><div class=\"line\">MyObject</div><div class=\"line\">MyObject</div></pre></td></tr></table></figure>\n<p>但是运行结果却是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj1 <span class=\"keyword\">class</span> is __NSPlaceholderArray</div><div class=\"line\">obj2 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></div><div class=\"line\">obj3 <span class=\"keyword\">class</span> is __NSPlaceholderArray</div><div class=\"line\">obj4 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></div><div class=\"line\">obj5 <span class=\"keyword\">class</span> is MyObject</div><div class=\"line\">obj6 <span class=\"keyword\">class</span> is MyObject</div></pre></td></tr></table></figure>\n<p>这是因为在Objective-C中，调用+alloc会隐性地返回一个类的实例对象而调用-init会返回另外一个类的实例对象。</p>\n<h3 id=\"objc-msgSend的工作流程是什么？\"><a href=\"#objc-msgSend的工作流程是什么？\" class=\"headerlink\" title=\"objc_msgSend的工作流程是什么？\"></a>objc_msgSend的工作流程是什么？</h3><p>objc_msgSend函数实现比较复杂。比如我们写了如下代码…</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> printMessageWithString:<span class=\"string\">@\"Hello World!\"</span>];</div></pre></td></tr></table></figure>\n<p>上述代码实际上会被编译器转化成：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(printMessageWithString:),<span class=\"string\">@\"Hello World!\"</span>);</div></pre></td></tr></table></figure>\n<p>随后，objc_msgSend函数根据目标对象的isa指针去查询对应的类（或者任一父类）看是否响应选择器@selector(printMessageWithString:)。假设在类的函数派发列表或者缓存中找到了对应的函数实现，那么执行该函数。如此看来，objc_msgSend函数没有返回值，它开始执行然后找到对应的目标函数并执行，因此目标函数的返回值被视为objc_msgSend函数的返回值。</p>\n<p>Bill Bumgarner对于objc_msgSend的研究比我要表达的更为深入（<a href=\"http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"external\">part 1</a>,<a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage/\" target=\"_blank\" rel=\"external\">part 2</a>,<a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path/\" target=\"_blank\" rel=\"external\">part 3</a>）。总结一下他所要表达的以及你在查阅运行时机制源代码时可能发现的内容：</p>\n<ol>\n<li>检测屏蔽的函数和死循环，很显然如果代码运行在垃圾回收的环境下，我们可以忽略-retain,-release的调用，诸如此类。</li>\n<li>检测空对象。 不同于其他编程语言，在Objective-C中发送一个消息给空对象是完全合法的。[there are some valid reasons you’d want to. Assuming we have a non nil target we go on… ]</li>\n<li>然后在一个类中查找函数指针，首先是搜索缓存列表，如果找到了对应的函数指针就跳转对其实现代码段，即执行函数。</li>\n<li>如果在缓存列表中没有找到对应的函数指针，便搜索类中的函数派发列表。如果找到了对应的函数指针即跳转到其实现代码段。</li>\n<li>如果在缓存列表和函数列表都没有找到对应的函数，随即跳转到消息转发机制，意味着代码会被编译成c语言代码。所以一个函数如下所示：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">int</span>)doComputeWithNum:(<span class=\"keyword\">int</span>)aNum</div></pre></td></tr></table></figure>\n<p>将会被编译成：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> aClass_doComputeWithNum(aClass *<span class=\"keyword\">self</span>,SEL _cmd,<span class=\"keyword\">int</span> aNum)</div></pre></td></tr></table></figure>\n<p>此时，运行时机制通过这些函数的指针来调用这些转化后的函数，现在你已经不能直接调用这些函数，但是Cocoa库提供了一个方法来获得这些函数的函数指针。。。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//declare C function pointer</span></div><div class=\"line\"><span class=\"keyword\">int</span> (computeNum *)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>);</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//methodForSelector is COCOA &amp; not ObjC Runtime</span></div><div class=\"line\"><span class=\"comment\">//gets the same function pointer objc_msgSend gets</span></div><div class=\"line\">computeNum = (<span class=\"keyword\">int</span> (*)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>))[target methodForSelector:<span class=\"keyword\">@selector</span>(doComputeWithNum:)];</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//execute the C function pointer returned by the runtime</span></div><div class=\"line\">computeNum(obj,<span class=\"keyword\">@selector</span>(doComputeWithNum:),aNum);</div></pre></td></tr></table></figure>\n<p>这样，你可以知道访问这些函数并在运行时中直接调用，甚至利用这种方法来绕开运行时的动态调用来确保一个指定的函数被执行。运行时机制同样可以调用你的函数，只不过是通过objc_msgSend()。</p>\n<h3 id=\"Objective-C消息传送\"><a href=\"#Objective-C消息传送\" class=\"headerlink\" title=\"Objective-C消息传送\"></a>Objective-C消息传送</h3><p>在Objective-C中，发送一个消息给一个不会做出响应的对象是合法的，甚至可能是有意这样设计的。苹果在其开发文档中给出的原因之一是为了模拟Objective-C不支持的多继承，或者你只是想抽象化你的设计，隐藏能处理这些消息的实例对象或类。这是运行时机制必要的功能之一。<br>消息传送工作流程：</p>\n<ol>\n<li>运行时机制搜寻了对象的类和它所有父类中的缓存列表和函数列表，但是并没有找到指定的方法。</li>\n<li>随后运行时机制将会调用你类中的 +(BOOL)resolveInstanceMethod:(SEL)aSEL方法给你一次机会为指定的函数提供函数实现，并告诉运行时机制你已经实现了这个方法。如果运行时机制再次搜索这个函数就能找到对应的函数实现。你可以如下所示，实现这个功能：</li>\n</ol>\n<p>定义一个函数</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> fooMethod(<span class=\"keyword\">id</span> obj, SEL _cmd)</div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Doing Foo\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如下所示，使用class_addMethod()来实现</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(aSEL == <span class=\"keyword\">@selector</span>(doFoo:))&#123;</div><div class=\"line\">        class_addMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],aSEL,(IMP)fooMethod,<span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>class_addMethod()最后一个参数“v@:”表示函数fooMethod的返回值和参数，你可以在运行时机制指南中类型编码<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\" target=\"_blank\" rel=\"external\">Type Encodings</a>了解你可以具体的规则。</p>\n<ol>\n<li>运行时机制随后会调用- (id)forwardingTargetForSelector:(SEL)aSelector函数，给你一次机会将运行时指向另外一个能响应目标函数的对象。这样做比触发消耗更大的函数：-(void)forwardInvocation:(NSInvocation *)anInvocation更划算。你的具体实现可能如下所示：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(aSelector == <span class=\"keyword\">@selector</span>(mysteriousMethod:))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> alternateObject;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>很显然你不想返回self指针，否则可能导致死循环。</p>\n<ol>\n<li>此时，运行时机制尝试最后一次去获取消息的预期目标，并调用- (void)forwardInvocation:(NSInvocation *)anInvocation。如果你未曾了解NSInvocation<a href=\"https://developer.apple.com/reference/foundation/nsinvocation\" target=\"_blank\" rel=\"external\">点击查看</a>,这是Objective-C消息中很重要的构成部分。一旦你持有一个NSInvocation对象，你基本上可以更改消息的任何内容，包括目标对象，选择器和函数参数。你可能操作如下：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation</div><div class=\"line\">&#123;</div><div class=\"line\">    SEL invSEL = invocation.selector;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span>([altObject respondsToSelector:invSEL]) &#123;</div><div class=\"line\">        [invocation invokeWithTarget:altObject];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doesNotRecognizeSelector:invSEL];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果类是继承自NSObjct，- (void)forwardInvocation:(NSInvocation *)anInvocation函数的默认实现是调用-doesNotRecognizeSelector函数，如果你还想做点什么来响应这次消息转送，重载这个函数将是最后一次机会。</p>\n<h3 id=\"实例变量的无碎片化（Modern-Runtime）\"><a href=\"#实例变量的无碎片化（Modern-Runtime）\" class=\"headerlink\" title=\"实例变量的无碎片化（Modern Runtime）\"></a>实例变量的无碎片化（Modern Runtime）</h3><p>目前我们所了解到关于Modern Runtime的概念之一是实例变量无碎片化（Non Fragile ivars）。编译器在编译类的时候确定了实例变量的布局，决定了某个实例变量的访问位置。这属于底层细节，关乎于获得一个对象的指针，查找某个实例变量相对于对象起始位置的偏移，根据实例变量的类型读取相应数量的字节。因此，实例变量的布局可能如下所示，左侧的数字表示实例变量的字节偏移量</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/runtime-f-1.png\" alt=\"\"></p>\n<p>如上所示，NSObject对象的实例变量布局以及继承NSObject后添加了自己的变量之后的布局。这样的布局在苹果发布更新之前都能正常运行，但是苹果发布了Mac OS X 10.6之后，布局就会变成如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/runtime-f-2.png\" alt=\"\"></p>\n<p>因为与父类的实例变量重叠，自定义的对象的实例变量被抹掉。防止这样的情况发生唯一的可能是苹果能保持更新之前的布局。但是如果苹果这样做的话，那么苹果的框架将不可能得到改进，因为这些框架的实例变量布局已经写死了。处于实例变量碎片化的情况下只能通过重新编译所有继承于苹果类的类来保证兼容新的框架。那么实例变量无碎片化的情况下会是如何处理？</p>\n<p><img src=\"https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/runtime-f-3.png\" alt=\"\"></p>\n<p>实例变量无碎片化的前提下，编译器创建同实例变量碎片化情况下一样的实例变量布局。但是当运行时检测到一个重叠的父类时会调整自定义变量的偏移量，因此子类中自定义的变量得以保留。</p>\n<h3 id=\"Objective-C-关联对象\"><a href=\"#Objective-C-关联对象\" class=\"headerlink\" title=\"Objective-C 关联对象\"></a>Objective-C 关联对象</h3><p>最近Mac OS X 10.6 Snow Leopard推出了一个新特性，称之为关联引用。不同于其他一些语言，Objective-C不支持动态添加实例变量到某个对象的类中。所以在此之前你不得不耗尽脑力去构建一个特定的基础架构，营造一个可以给某个对象动态添加变量的假象。现在在Mac OS X 10.6中，运行时已经支持这一功能。如果想添加一个变量到任一个已经存在的苹果原生类中，比如NSView，我们可以做如下操作：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Cocoa/Cocoa.h&gt;</span> //Cocoa</span></div><div class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt; objc/runtime.h&gt;</span> //objc runtime api’s</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSView</span> (<span class=\"title\">CustomAdditions</span>)</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSImage</span> *customImage;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSView</span> (<span class=\"title\">CustomAdditions</span>)</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> img_key; <span class=\"comment\">//has a unique address (identifier)</span></div><div class=\"line\"> </div><div class=\"line\">-(<span class=\"built_in\">NSImage</span> *)customImage</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>,&amp;img_key);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">-(<span class=\"keyword\">void</span>)setCustomImage:(<span class=\"built_in\">NSImage</span> *)image</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>,&amp;img_key,image,</div><div class=\"line\">                             OBJC_ASSOCIATION_RETAIN);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>在runtime.h头文件中可以看到存储关联对象方式的可选项，作为objc_setAssociatedObject()函数的参数传入。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Associated Object support. */</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/* objc_setAssociatedObject() options */</span></div><div class=\"line\"><span class=\"keyword\">enum</span> &#123;</div><div class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,</div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>,</div><div class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,</div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,</div><div class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这些可选值与@property语法的可选值相匹配。</p>\n<h3 id=\"混合虚函数表派发（Hybrid-vTable-Dispatch）\"><a href=\"#混合虚函数表派发（Hybrid-vTable-Dispatch）\" class=\"headerlink\" title=\"混合虚函数表派发（Hybrid vTable Dispatch）\"></a>混合虚函数表派发（Hybrid vTable Dispatch）</h3><p>如果你查阅现代版运行时的源代码，你会看到以下内容（<a href=\"http://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.m\" target=\"_blank\" rel=\"external\">位于objc-runtime-new.m</a>）:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/***********************************************************************</span></div><div class=\"line\">* vtable dispatch</div><div class=\"line\">* </div><div class=\"line\">* Every class gets a vtable pointer. The vtable is an array of IMPs.</div><div class=\"line\">* The selectors represented in the vtable are the same for all classes</div><div class=\"line\">*   (i.e. no class has a bigger or smaller vtable).</div><div class=\"line\">* Each vtable index has an associated trampoline which dispatches to </div><div class=\"line\">*   the IMP at that index for the receiver class's vtable (after </div><div class=\"line\">*   checking for NULL). Dispatch fixup uses these trampolines instead </div><div class=\"line\">*   of objc_msgSend.</div><div class=\"line\">* Fragility: The vtable size and list of selectors is chosen at launch </div><div class=\"line\">*   time. No compiler-generated code depends on any particular vtable </div><div class=\"line\">*   configuration, or even the use of vtable dispatch at all.</div><div class=\"line\">* Memory size: If a class's vtable is identical to its superclass's </div><div class=\"line\">*   (i.e. the class overrides none of the vtable selectors), then </div><div class=\"line\">*   the class points directly to its superclass's vtable. This means </div><div class=\"line\">*   selectors to be included in the vtable should be chosen so they are </div><div class=\"line\">*   (1) frequently called, but (2) not too frequently overridden. In </div><div class=\"line\">*   particular, -dealloc is a bad choice.</div><div class=\"line\">* Forwarding: If a class doesn't implement some vtable selector, that </div><div class=\"line\">*   selector's IMP is set to objc_msgSend in that class's vtable.</div><div class=\"line\">* +initialize: Each class keeps the default vtable (which always </div><div class=\"line\">*   redirects to objc_msgSend) until its +initialize is completed.</div><div class=\"line\">*   Otherwise, the first message to a class could be a vtable dispatch, </div><div class=\"line\">*   and the vtable trampoline doesn't include +initialize checking.</div><div class=\"line\">* Changes: Categories, addMethod, and setImplementation all force vtable </div><div class=\"line\">*   reconstruction for the class and all of its subclasses, if the </div><div class=\"line\">*   vtable selectors are affected.</div><div class=\"line\">**********************************************************************/</div></pre></td></tr></table></figure>\n<p>上述内容阐述的要点就是运行时会尽量存储调用最频繁的函数以达到提高软件运行速度的目的，因为通过虚函数表查找比调用objc_msgSend函数使用的指令更少。虚函数表中的16个函数调用次数远多于其他所有函数。实际上，进一步深入研究代码你会发现垃圾回收机制和无垃圾回收机制下虚函数表中默认的函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> defaultVtable[] = &#123;</div><div class=\"line\">    <span class=\"string\">\"allocWithZone:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"alloc\"</span>, </div><div class=\"line\">    <span class=\"string\">\"class\"</span>, </div><div class=\"line\">    <span class=\"string\">\"self\"</span>, </div><div class=\"line\">    <span class=\"string\">\"isKindOfClass:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"respondsToSelector:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"isFlipped\"</span>, </div><div class=\"line\">    <span class=\"string\">\"length\"</span>, </div><div class=\"line\">    <span class=\"string\">\"objectForKey:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"count\"</span>, </div><div class=\"line\">    <span class=\"string\">\"objectAtIndex:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"isEqualToString:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"isEqual:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"retain\"</span>, </div><div class=\"line\">    <span class=\"string\">\"release\"</span>, </div><div class=\"line\">    <span class=\"string\">\"autorelease\"</span>, </div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> defaultVtableGC[] = &#123;</div><div class=\"line\">    <span class=\"string\">\"allocWithZone:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"alloc\"</span>, </div><div class=\"line\">    <span class=\"string\">\"class\"</span>, </div><div class=\"line\">    <span class=\"string\">\"self\"</span>, </div><div class=\"line\">    <span class=\"string\">\"isKindOfClass:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"respondsToSelector:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"isFlipped\"</span>, </div><div class=\"line\">    <span class=\"string\">\"length\"</span>, </div><div class=\"line\">    <span class=\"string\">\"objectForKey:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"count\"</span>, </div><div class=\"line\">    <span class=\"string\">\"objectAtIndex:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"isEqualToString:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"isEqual:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"hash\"</span>, </div><div class=\"line\">    <span class=\"string\">\"addObject:\"</span>, </div><div class=\"line\">    <span class=\"string\">\"countByEnumeratingWithState:objects:count:\"</span>, </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>那么你如何知道是否调用了这些函数？调试模式下，你将会在栈中看到以下函数中的某一个被调用，出于调试的目的，所有的这些方法都可以视为通过objc_msgSend函数调用的。</p>\n<ol>\n<li>objc_msgSend_fixup：是当运行时正在派发一个位于虚函数表的函数时触发，即用于派发虚函数表中的函数。</li>\n<li>objc_msgSend_fixedup：是当调用一个本应存在于虚函数表的函数但是现在已经不存在的函数时触发（个人觉得应该是调用在objc_msgSend_fixup函数之后，并且由前者触发的）。</li>\n<li>objc_msgSend_vtable[0-15]：调试模式下，也许会看到某个函数调用类似于objc_msgSend_vtable5意味着正在调用虚函数表中对应序号的某个函数。</li>\n</ol>\n<p>运行时可以决定是否派发这些函数，所以不要指望以下这种情况存在：objc_msgSend_vtable10在运行时的一次循环中对应的函数是-length,意味着后面任一次循环中也是同样情况。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>我希望你能喜欢这些内容，这篇文章基本上覆盖了我在<a href=\"http://cocoaheads.org/us/DesMoinesIowa/index.html\" target=\"_blank\" rel=\"external\">Des Moines Cocoaheads </a>上谈及的内容。Objective-C运行时是一个了不起的杰作，它为我们的Cocoa/Objective-C应用提供了一个强大的平台，让很多我们正在受用的功能都成为可能。如果你还没有查阅关于如何使用Objective-C运行时的Apple开发文档，我希望你马上行动，谢谢。附上：<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\" target=\"_blank\" rel=\"external\">运行时开发文档</a>，<a href=\"https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime\" target=\"_blank\" rel=\"external\">运行时介绍文档</a></p>\n"},{"title":"about","url":"http://yoursite.com/about/index.html","content":""},{"title":"category","url":"http://yoursite.com/category/index.html","content":""},{"title":"link","url":"http://yoursite.com/link/index.html","content":""},{"title":"","url":"http://yoursite.com/css/personal-style.css","content":"\n@font-face {\n  font-family: \"Meiryo\";\n  src: url(\"/fonts/Meiryo.eot\");\n  /* IE9 */\n  src: url(\"/fonts/Meiryo.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */\n  url(\"/fonts/Meiryo.woff\") format(\"woff\"), /* chrome, firefox */\n  url(\"/fonts/Meiryo.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url(\"/fonts/Meiryo.svg#Meiryo\") format(\"svg\");\n  /* iOS 4.1- */\n  font-style: normal;\n  font-weight: normal;\n}\n\nhtml.page-home {\n\n\tbackground: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);\n\tbackground-blend-mode: screen;\n\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n\n}\n"},{"title":"project","url":"http://yoursite.com/project/index.html","content":""},{"title":"search","url":"http://yoursite.com/search/index.html","content":""},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":""}]