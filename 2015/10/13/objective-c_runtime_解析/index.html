<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Objective-C Runtime 解析 | Iceberg</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Objective-C,Runtime," />
  

  <meta name="description" content="这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以查看原文。
以下是正文：
一般而言，当人们刚接触Coacoa/Objective-C的时候，运行时（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C Runtime 解析">
<meta property="og:url" content="http://yoursite.com/2015/10/13/objective-c_runtime_解析/index.html">
<meta property="og:site_name" content="Iceberg">
<meta property="og:description" content="这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以查看原文。
以下是正文：
一般而言，当人们刚接触Coacoa/Objective-C的时候，运行时（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们">
<meta property="og:updated_time" content="2016-10-18T07:15:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C Runtime 解析">
<meta name="twitter:description" content="这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以查看原文。
以下是正文：
一般而言，当人们刚接触Coacoa/Objective-C的时候，运行时（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=028c63b1" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Objective-C-Runtime是开源的"><span class="toc-text">Objective-C Runtime是开源的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态-amp-静态-语言"><span class="toc-text">动态 & 静态 语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#何为Runtime-运行时"><span class="toc-text">何为Runtime(运行时)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Objective-C-运行时术语"><span class="toc-text">Objective-C 运行时术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类定义对象同时类本身也是对象？何解？"><span class="toc-text">类定义对象同时类本身也是对象？何解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么继承Apple的原生类？"><span class="toc-text">为什么继承Apple的原生类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类缓存机制"><span class="toc-text">类缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objc-msgSend究竟是如何运转的？"><span class="toc-text">objc_msgSend究竟是如何运转的？</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-objective-c_runtime_解析" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Objective-C Runtime 解析</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2015.10.13</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>iceberg</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Objective-C/">Objective-C</a> / <a class="article-category-link" href="/categories/Objective-C/Cocoa/">Cocoa</a> / <a class="article-category-link" href="/categories/Objective-C/Cocoa/翻译/">翻译</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://www.icebergcwp.com/2015/10/13/objective-c_runtime_解析/#disqus_thread"></a>
        </span>
      

    </div>
  </header>

  <div class="article-content">
    
      <p>这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以<a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="external">查看原文</a>。</p>
<p><strong>以下是正文：</strong></p>
<p>一般而言，当人们刚接触Coacoa/Objective-C的时候，运行时（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们通常会将大部分的时间和精力用于研究Cocoa Framework以及如何使用它。然而，每一个人至少应该清楚运行时是如何运转的，而不仅仅停留在编译方式的认知层面，如：[target doMethodWith:var];编译之后变成object_msgSend(target,@selector(doMethodWith:),var1)。了解Runtime的工作原理可以帮助你进一步理解Objective-C这门语言以及你编写的App的运转流程。我相信各个水平层次的Mac/iPhone开发者都会在研究Runtime的过程中有所收获。</p>
<h3 id="Objective-C-Runtime是开源的"><a href="#Objective-C-Runtime是开源的" class="headerlink" title="Objective-C Runtime是开源的"></a>Objective-C Runtime是开源的</h3><p>Runtime是开源的，你随时可以在<a href="http://opensource.apple.com" target="_blank" rel="external">源代码</a>上查阅。事实上，查阅源代码是弄清楚Objective-C原理的首选途径之一，胜过阅读苹果开发文档。下载最新版本的源代码<a href="http://opensource.apple.com/source/objc4/objc4-680/" target="_blank" rel="external">点击我</a>。</p>
<h3 id="动态-amp-静态-语言"><a href="#动态-amp-静态-语言" class="headerlink" title="动态 &amp; 静态 语言"></a>动态 &amp; 静态 语言</h3><p>Objective-C是基于运行时的语言，意味着它会尽可能地将决定代码执行逻辑的操作从编译&amp;链接阶段延迟到代码被执行的阶段。这将给你带来很大的灵活性，因此如果有必要的话你可以将消息重定向到合适的对象，或者你甚至可以交换两个方法实现，等等。实现上述功能需要运行时具备审查对象可以响应哪些请求和不能响应哪些请求然后准确地派发消息的能力。如果我们将Objective-C这一特性对比C语言。C语言程序运行始于main()函数，基于至上而下的设计执行你的逻辑和调用你实现的函数。C结构体不能通过发送请求到其他的结构体来执行某个函数。很可能你会编写一段C语言代码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio.h &gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv[])</span></span></div><div class="line">&#123;</div><div class="line">       <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码经过编译器编译、优化，然后将优化后的代码转化成汇编语言：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">.text</span></div><div class="line"> <span class="meta">.align</span> <span class="number">4</span>,<span class="number">0x90</span></div><div class="line"> .globl _main</div><div class="line"><span class="symbol">_main</span>:</div><div class="line"><span class="symbol">Leh_func_begin1</span>:</div><div class="line">	<span class="keyword">pushq </span>%rbp</div><div class="line"><span class="symbol">Llabel1</span>:</div><div class="line"> <span class="keyword">movq </span>%rsp, %rbp</div><div class="line"><span class="symbol">Llabel2</span>:</div><div class="line"> <span class="keyword">subq </span><span class="number">$16</span>, %rsp</div><div class="line"><span class="symbol">Llabel3</span>:</div><div class="line"> <span class="keyword">movq </span>%rsi, %rax</div><div class="line"> <span class="keyword">movl </span>%edi, %ecx</div><div class="line"> <span class="keyword">movl </span>%ecx, -<span class="number">8</span>(%rbp)</div><div class="line"> <span class="keyword">movq </span>%rax, -<span class="number">16</span>(%rbp)</div><div class="line"> xorb %al, %al</div><div class="line"> leaq LC(%rip), %rcx</div><div class="line"> <span class="keyword">movq </span>%rcx, %rdi</div><div class="line"> call _printf</div><div class="line"> <span class="keyword">movl </span><span class="number">$0</span>, -<span class="number">4</span>(%rbp)</div><div class="line"> <span class="keyword">movl </span>-<span class="number">4</span>(%rbp), %eax</div><div class="line"> <span class="keyword">addq </span><span class="number">$16</span>, %rsp</div><div class="line"> <span class="keyword">popq </span>%rbp</div><div class="line"> ret</div><div class="line"><span class="symbol">Leh_func_end1</span>:</div><div class="line"> .cstring</div><div class="line"><span class="symbol">LC</span>:</div><div class="line"> <span class="meta">.asciz</span> <span class="string">"Hello World!"</span></div></pre></td></tr></table></figure>
<p>随后链接相关的库生成一个可执行文件。对比于Objective-C，虽然代码处理过程很相似，但是编译后的代码取决于Objective-C Runtime库。当我们最初学习Objective-C时被告知中括号里面的代码是如何被处理的，如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> doSomethingWithVar:var1];</div></pre></td></tr></table></figure>
<p>被转变成</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(<span class="keyword">self</span>,<span class="keyword">@selector</span>(doSomethingWithVar:),var1);</div></pre></td></tr></table></figure>
<p>除此之外我们并不真的知道Runtime是如何工作的，也许很久以后会知道。</p>
<h3 id="何为Runtime-运行时"><a href="#何为Runtime-运行时" class="headerlink" title="何为Runtime(运行时)"></a>何为Runtime(运行时)</h3><p>Objective-C Runtime是一个Runtime库，主要有C语言&amp;汇编语言编写而成，在C语言的基础上加上面向对象的功能之后就成为了Objective-C语言。这意味着Runtime负责加载类，方法派发，方法传达等操作。本质上而言，Runtime提供了所有的需要的结构用以支持Objective-C的面向对象编程。</p>
<h3 id="Objective-C-运行时术语"><a href="#Objective-C-运行时术语" class="headerlink" title="Objective-C 运行时术语"></a>Objective-C 运行时术语</h3><p>在进一步深入之前，让我们扫清一些术语的障碍，这样使我们处于同一立场。就MacOS X App &amp; iPhone OS App开发者所关心而言，这里有两种Runtime: Modern Runtime和Legacy Runtime。Modern Runtime适用于所有64位MacOS应用和所有iPhone应用，Legacy Runtime适用于所有的32位MacOS应用。Runtime中有两种类型的函数：实例函数（以‘-’符号开头如-(void)doFoo）;类函数（以‘+’开头如+(id)alloc）。两种函数都与C函数很像，包含一组实现某个任务的代码，如下所示</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSString</span> *)movieTitle</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">@"Futurama: Into the Wild Green Yonder"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>选择器：在Objective-C中，选择器本质上是一个C数据结构体用以标识一个对象将要执行的函数。在Runtime中的定义如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector  *SEL;</div></pre></td></tr></table></figure>
<p>使用方式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SEL aSel = <span class="keyword">@selector</span>(movieTitle);</div></pre></td></tr></table></figure>
<p>消息调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[target getMovieTitleForObject:obj];</div></pre></td></tr></table></figure>
<p>Objective-C消息就是中括号[]里面的所有东西，包括消息的接受者target，调用的函数getMovieTileForObject以及所有发送的参数obj。消息调用虽然样式上类似于c函数调用但是实现却不同。实际上，当你发送一个消息给一个对象并意味着函数会被执行。对象可能会检测谁是消息的发送者，基于此再决定执行一个不同的函数或者转送消息给其他不同的目标对象。如果你查看Runtime里的类定义，你将会看到如下所示的内容：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa;</div><div class="line">&#125; *<span class="keyword">id</span>;</div></pre></td></tr></table></figure>
<p>这里有几个要点。首先是类Class和对象Object都有一个对应的结构体。所有的objc_object结构体都有一个类指针isa，这就是我们所说的“<strong>isa指针</strong>”。Runtime需要通过检测一个对象的isa指针去查看对象的类别，然后查看该对象是否能响应你当前发送过来的消息。接下来是id指针，id指针默认不属于任何类别只表明指向的是一个Objective-C对象。对于id指针指向的对象，你可以获知对象的类别，查看对象是否能响应某个函数等等，然后当你具体了解了id指针指向的对象之后便可以更好的使用该对象。你同样可以查看LLVM/Clang文档中Blocks的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Block_literal_1 &#123;</div><div class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></div><div class="line">    <span class="keyword">int</span> flags;</div><div class="line">    <span class="keyword">int</span> reserved; </div><div class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</div><div class="line">    <span class="keyword">struct</span> Block_descriptor_1 &#123;</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved; <span class="comment">// NULL</span></div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;  <span class="comment">// sizeof(struct Block_literal_1)</span></div><div class="line"> <span class="comment">// optional helper functions</span></div><div class="line">     <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</div><div class="line">     <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src); </div><div class="line">    &#125; *descriptor;</div><div class="line">    <span class="comment">// imported variables</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Block结构的设计兼容于Runtime。因此Block被视为一个Objective-C对象，所有也就可以响应消息如-retain,-release,-copy等等。</p>
<p>IMP:Method Implementations</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd,...);</div></pre></td></tr></table></figure>
<p>IMP是一个函数指针，由编译器生成且指向函数的实现内容。如果你目前是一个Objective-C新手则浅尝辄止，但是我们随后会了解Runtime是如何调用你的函数的。</p>
<p>Objective-C类：类里面是什么？在Objective-C中，类实现基本上类似于：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line"><span class="comment">//vars</span></div><div class="line"><span class="built_in">NSInteger</span> counter;</div><div class="line">&#125;</div><div class="line"><span class="comment">//methods</span></div><div class="line">-(<span class="keyword">void</span>)doFoo;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>但是类在Runtime中定义远不如此，如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>我们可以看到一个类中声明了一个父类的引用，类名，实例变量列表，方法列表，缓存以及协议列表。当响应发送给类或对象的消息时，Runtime需要用到这些信息。</p>
<h3 id="类定义对象同时类本身也是对象？何解？"><a href="#类定义对象同时类本身也是对象？何解？" class="headerlink" title="类定义对象同时类本身也是对象？何解？"></a>类定义对象同时类本身也是对象？何解？</h3><p>之前我提到过在Objective-C中类本身也是对象，Runtime通过引入元类（Meta Class）来处理类对象。当你发送一个类似于[NSObject alloc]消息的时候，实际上是发送一个消息给类对象，此时将类对象视为元类的实例对待，而元类本身也是一个根元类（Root Meta Class）的实例。While if you say subclass from NSObject, your class points to NSObject as it’s superclass. However all meta classes point to the root metaclass as their superclass. (原文似乎表达观点有误，暂不翻译)。所有的元类仅有一个类函数列表（不同于类处理实例函数列表，还有变量列表和协议列表等等）。因此，当你发送一个消息给类对象时，如[NSObject alloc]，objc_megSend()实际上是搜索元类的函数列表查看是否有响应的函数，如果存在则在该类对象上执行该函数。</p>
<h3 id="为什么继承Apple的原生类？"><a href="#为什么继承Apple的原生类？" class="headerlink" title="为什么继承Apple的原生类？"></a>为什么继承Apple的原生类？</h3><p>在你刚开始Cocoa编程时，相关教程都是说创建一个类继承于NSObject然后开始编写自己的代码，简单地继承Apple的原生类会让你获益匪浅。其中一个你甚至意识不到的好处就是让你创建的类运行于Runtime之上。当我们新建一个实例对象，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyObject *object = [[MyObject alloc] init];</div></pre></td></tr></table></figure>
<p>最先被执行的消息是+alloc。如果你<a href="https://developer.apple.com/library/content/#documentation/cocoa/reference/Foundation/Classes/NSObject_Class/Reference/Reference.html" target="_blank" rel="external">查阅这个文档</a>会发现：“isa这一实例变量被初始化指向一个描述对于类的数据结构体，其他所有的实例变量都被初始化为0”。所以，通过继承Apple原始类不仅仅继承一些不错的属性，而且还能让我们轻易地创建符合于Runtime要求的对象（包含一个指向类的isa指针）。</p>
<h3 id="类缓存机制"><a href="#类缓存机制" class="headerlink" title="类缓存机制"></a>类缓存机制</h3><p>当OC的Runtime机制通过检视一个对象的isa指针指向的类时会发现该对象实现了很多函数。然而，你可能仅仅调用其中的一小部分也就意味没必要每一次查找某个函数时都去搜索一遍类中的函数列表。因此，类创建了缓存，将你每次搜索函数列表后找到的相应函数存入缓存中。所以，当objc_msgSend()在类中搜寻某个函数是首先会遍历缓存列表。这样做的理论依据在于如果你发送过某个消息给一个对象，你很可能回再次发送同样的消息。因此如果我们将该理论考虑在内意味着如果你有一个NSObject的子类MyObject,并运行以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">MyObject *obj = [[MyObject alloc] init];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></div><div class="line">-(<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init])&#123;</div><div class="line">        [<span class="keyword">self</span> setVarA:@”blah”];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>接下来发生：</p>
<ol>
<li>[MyObject alloc]最先被执行。因为MyObject类没有实现alloc函数所以在该类自然找不到对应的函数，随后进入父类指针指向的NSObject类。</li>
<li>询问NSObject类是否响应+alloc，发现其实现了alloc函数。+alloc检测到接收类是MyObject然后分配一块响应大小的内存并在其中初始化一个isa指针指向MyObject类。现在，我们获得了一个实例对象，随后Runtime将NSObject类的+alloc函数指针存入NSObject对象对应的类中的缓存列表中。</li>
<li>截至目前，我们发送了一个类消息，现在我们发送一个实例消息：调用-init函数或者自定义的初始化函数。显然，MyObject的实例对象能响应这个消息，因此-(id)init会被存入缓存列表中。</li>
<li>随后self=[super init]被调用。super作为一个魔法关键字指向父类对象，因此转向NSObjct类中，调用init函数。这样做是为了确保面向对象继承体系（OOP inheritance）正常运转，因为所以的父类都将会正确地初始化它们的变量，然后作为子类对象可以正确地初始化自身的变量和必要时重载父类。</li>
</ol>
<p>在这个NSObject类的例子中，没有特别的要点出现。但是事实并不总是如此，有时候初始化很重要，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt; Foundation/Foundation.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line"> <span class="built_in">NSString</span> *aString;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSString</span> *aString;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></div><div class="line"> </div><div class="line">-(<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line"> <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">  [<span class="keyword">self</span> setAString:<span class="literal">nil</span>];</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">@synthesize</span> aString;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div><div class="line"> </div><div class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="built_in">NSAutoreleasePool</span> * pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"> </div><div class="line"> <span class="keyword">id</span> obj1 = [<span class="built_in">NSMutableArray</span> alloc];</div><div class="line"> <span class="keyword">id</span> obj2 = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">  </div><div class="line"> <span class="keyword">id</span> obj3 = [<span class="built_in">NSArray</span> alloc];</div><div class="line"> <span class="keyword">id</span> obj4 = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"Hello"</span>,<span class="literal">nil</span>];</div><div class="line">  </div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj1 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj1 <span class="keyword">class</span>]));</div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj2 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj2 <span class="keyword">class</span>]));</div><div class="line">  </div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj3 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj3 <span class="keyword">class</span>]));</div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj4 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj4 <span class="keyword">class</span>]));</div><div class="line">  </div><div class="line"> <span class="keyword">id</span> obj5 = [MyObject alloc];</div><div class="line"> <span class="keyword">id</span> obj6 = [[MyObject alloc] init];</div><div class="line">  </div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj5 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj5 <span class="keyword">class</span>]));</div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj6 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj6 <span class="keyword">class</span>]));</div><div class="line">  </div><div class="line"> [pool drain];</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你是Cocoa初学者，然后我问你上述代码的打印结果，你的回答可能如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span></div><div class="line"><span class="built_in">NSMutableArray</span> </div><div class="line"><span class="built_in">NSArray</span></div><div class="line"><span class="built_in">NSArray</span></div><div class="line">MyObject</div><div class="line">MyObject</div></pre></td></tr></table></figure>
<p>但是运行结果却是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">obj1 <span class="keyword">class</span> is __NSPlaceholderArray</div><div class="line">obj2 <span class="keyword">class</span> is <span class="built_in">NSCFArray</span></div><div class="line">obj3 <span class="keyword">class</span> is __NSPlaceholderArray</div><div class="line">obj4 <span class="keyword">class</span> is <span class="built_in">NSCFArray</span></div><div class="line">obj5 <span class="keyword">class</span> is MyObject</div><div class="line">obj6 <span class="keyword">class</span> is MyObject</div></pre></td></tr></table></figure>
<p>这是因为在Objective-C中，调用+alloc会隐性地返回一个类的实例对象而调用-init会返回另外一个类的实例对象。</p>
<h3 id="objc-msgSend究竟是如何运转的？"><a href="#objc-msgSend究竟是如何运转的？" class="headerlink" title="objc_msgSend究竟是如何运转的？"></a>objc_msgSend究竟是如何运转的？</h3>
    
  </div>
</article>

</div>


  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">Kick my ass</span>
      <div class="donation-body">
        <div class="tip text-center">Buy me a coke ?</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>




  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'iceberg';
    
    var disqus_url = 'http://yoursite.com/2015/10/13/objective-c_runtime_解析/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//iceberg.disqus.com/count.js" async></script>



    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
